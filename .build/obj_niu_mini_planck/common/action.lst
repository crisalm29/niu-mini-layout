   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB13:
  15               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "backlight.h"
  24:tmk_core/common/action.c **** #include "action_layer.h"
  25:tmk_core/common/action.c **** #include "action_tapping.h"
  26:tmk_core/common/action.c **** #include "action_macro.h"
  27:tmk_core/common/action.c **** #include "action_util.h"
  28:tmk_core/common/action.c **** #include "action.h"
  29:tmk_core/common/action.c **** #include "wait.h"
  30:tmk_core/common/action.c **** 
  31:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  32:tmk_core/common/action.c **** #include "debug.h"
  33:tmk_core/common/action.c **** #else
  34:tmk_core/common/action.c **** #include "nodebug.h"
  35:tmk_core/common/action.c **** #endif
  36:tmk_core/common/action.c **** 
  37:tmk_core/common/action.c **** int tp_buttons;
  38:tmk_core/common/action.c **** 
  39:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  40:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  41:tmk_core/common/action.c **** #endif
  42:tmk_core/common/action.c **** 
  43:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  44:tmk_core/common/action.c **** #include <fauxclicky.h>
  45:tmk_core/common/action.c **** #endif
  46:tmk_core/common/action.c **** 
  47:tmk_core/common/action.c **** /** \brief Called to execute an action.
  48:tmk_core/common/action.c ****  *
  49:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  50:tmk_core/common/action.c ****  */
  51:tmk_core/common/action.c **** void action_exec(keyevent_t event)
  52:tmk_core/common/action.c **** {
  16               		.loc 1 52 0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  53:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  54:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  55:tmk_core/common/action.c ****         dprint("EVENT: "); debug_event(event); dprintln();
  56:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  57:tmk_core/common/action.c ****         retro_tapping_counter++;
  58:tmk_core/common/action.c **** #endif
  59:tmk_core/common/action.c ****     }
  60:tmk_core/common/action.c **** 
  61:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  62:tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  63:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  64:tmk_core/common/action.c ****     }
  65:tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  66:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  67:tmk_core/common/action.c ****     }
  68:tmk_core/common/action.c ****     fauxclicky_check();
  69:tmk_core/common/action.c **** #endif
  70:tmk_core/common/action.c **** 
  71:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  72:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  73:tmk_core/common/action.c ****         process_hand_swap(&event);
  74:tmk_core/common/action.c ****     }
  75:tmk_core/common/action.c **** #endif
  76:tmk_core/common/action.c **** 
  77:tmk_core/common/action.c ****     keyrecord_t record = { .event = event };
  48               		.loc 1 77 0
  49 001e DE01      		movw r26,r28
  50 0020 1196      		adiw r26,1
  51 0022 86E0      		ldi r24,lo8(6)
  52 0024 FD01      		movw r30,r26
  53               		0:
  54 0026 1192      		st Z+,__zero_reg__
  55 0028 8A95      		dec r24
  56 002a 01F4      		brne 0b
  57 002c 85E0      		ldi r24,lo8(5)
  58 002e FE01      		movw r30,r28
  59 0030 3796      		adiw r30,7
  60               		0:
  61 0032 0190      		ld r0,Z+
  62 0034 0D92      		st X+,r0
  63 0036 8A95      		dec r24
  64 0038 01F4      		brne 0b
  78:tmk_core/common/action.c **** 
  79:tmk_core/common/action.c **** #if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  80:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  81:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  82:tmk_core/common/action.c ****     }
  83:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  84:tmk_core/common/action.c ****         clear_oneshot_mods();
  85:tmk_core/common/action.c ****     }
  86:tmk_core/common/action.c **** #endif
  87:tmk_core/common/action.c **** 
  88:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
  89:tmk_core/common/action.c ****     action_tapping_process(record);
  65               		.loc 1 89 0
  66 003a 4981      		ldd r20,Y+1
  67               	.LVL1:
  68 003c 5A81      		ldd r21,Y+2
  69               	.LVL2:
  70 003e 6B81      		ldd r22,Y+3
  71 0040 7C81      		ldd r23,Y+4
  72 0042 8D81      		ldd r24,Y+5
  73 0044 9E81      		ldd r25,Y+6
  74 0046 0E94 0000 		call action_tapping_process
  75               	.LVL3:
  76               	/* epilogue start */
  90:tmk_core/common/action.c **** #else
  91:tmk_core/common/action.c ****     process_record(&record);
  92:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
  93:tmk_core/common/action.c ****         dprint("processed: "); debug_record(record); dprintln();
  94:tmk_core/common/action.c ****     }
  95:tmk_core/common/action.c **** #endif
  96:tmk_core/common/action.c **** }
  77               		.loc 1 96 0
  78 004a 2B96      		adiw r28,11
  79 004c 0FB6      		in __tmp_reg__,__SREG__
  80 004e F894      		cli
  81 0050 DEBF      		out __SP_H__,r29
  82 0052 0FBE      		out __SREG__,__tmp_reg__
  83 0054 CDBF      		out __SP_L__,r28
  84 0056 DF91      		pop r29
  85 0058 CF91      		pop r28
  86 005a 0895      		ret
  87               		.cfi_endproc
  88               	.LFE13:
  90               		.section	.text.process_record_quantum,"ax",@progbits
  91               		.weak	process_record_quantum
  93               	process_record_quantum:
  94               	.LFB15:
  97:tmk_core/common/action.c **** 
  98:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  99:tmk_core/common/action.c **** bool swap_hands = false;
 100:tmk_core/common/action.c **** bool swap_held = false;
 101:tmk_core/common/action.c **** 
 102:tmk_core/common/action.c **** /** \brief Process Hand Swap
 103:tmk_core/common/action.c ****  *
 104:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 105:tmk_core/common/action.c ****  */
 106:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 107:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 108:tmk_core/common/action.c **** 
 109:tmk_core/common/action.c ****     keypos_t pos = event->key;
 110:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1<<pos.col;
 111:tmk_core/common/action.c ****     bool do_swap = event->pressed ? swap_hands :
 112:tmk_core/common/action.c ****                                     swap_state[pos.row] & (col_bit);
 113:tmk_core/common/action.c **** 
 114:tmk_core/common/action.c ****     if (do_swap) {
 115:tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 116:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 117:tmk_core/common/action.c ****     } else {
 118:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 119:tmk_core/common/action.c ****     }
 120:tmk_core/common/action.c **** }
 121:tmk_core/common/action.c **** #endif
 122:tmk_core/common/action.c **** 
 123:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && defined(PREVENT_STUCK_MODIFIERS)
 124:tmk_core/common/action.c **** bool disable_action_cache = false;
 125:tmk_core/common/action.c **** 
 126:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record)
 127:tmk_core/common/action.c **** {
 128:tmk_core/common/action.c ****     disable_action_cache = true;
 129:tmk_core/common/action.c ****     process_record(record);
 130:tmk_core/common/action.c ****     disable_action_cache = false;
 131:tmk_core/common/action.c **** }
 132:tmk_core/common/action.c **** #else
 133:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record)
 134:tmk_core/common/action.c **** {
 135:tmk_core/common/action.c ****     process_record(record);
 136:tmk_core/common/action.c **** }
 137:tmk_core/common/action.c **** #endif
 138:tmk_core/common/action.c **** 
 139:tmk_core/common/action.c **** __attribute__ ((weak))
 140:tmk_core/common/action.c **** bool process_record_quantum(keyrecord_t *record) {
  95               		.loc 1 140 0
  96               		.cfi_startproc
  97               	.LVL4:
  98               	/* prologue: function */
  99               	/* frame size = 0 */
 100               	/* stack size = 0 */
 101               	.L__stack_usage = 0
 141:tmk_core/common/action.c ****     return true;
 142:tmk_core/common/action.c **** }
 102               		.loc 1 142 0
 103 0000 81E0      		ldi r24,lo8(1)
 104               	.LVL5:
 105 0002 0895      		ret
 106               		.cfi_endproc
 107               	.LFE15:
 109               		.section	.text.process_record_tap_hint,"ax",@progbits
 110               	.global	process_record_tap_hint
 112               	process_record_tap_hint:
 113               	.LFB16:
 143:tmk_core/common/action.c **** 
 144:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 145:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 146:tmk_core/common/action.c ****  *
 147:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 148:tmk_core/common/action.c ****  */
 149:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record)
 150:tmk_core/common/action.c **** {
 114               		.loc 1 150 0
 115               		.cfi_startproc
 116               	.LVL6:
 117               	/* prologue: function */
 118               	/* frame size = 0 */
 119               	/* stack size = 0 */
 120               	.L__stack_usage = 0
 151:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 121               		.loc 1 151 0
 122 0000 FC01      		movw r30,r24
 123 0002 8081      		ld r24,Z
 124 0004 9181      		ldd r25,Z+1
 125               	.LVL7:
 126 0006 0E94 0000 		call layer_switch_get_action
 127               	.LVL8:
 128 000a 0895      		ret
 129               		.cfi_endproc
 130               	.LFE16:
 132               		.section	.text.register_code,"ax",@progbits
 133               	.global	register_code
 135               	register_code:
 136               	.LFB19:
 152:tmk_core/common/action.c **** 
 153:tmk_core/common/action.c ****     switch (action.kind.id) {
 154:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 155:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 156:tmk_core/common/action.c ****             switch (action.swap.code) {
 157:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 158:tmk_core/common/action.c ****                 default:
 159:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 160:tmk_core/common/action.c ****                     swap_held = true;
 161:tmk_core/common/action.c ****             }
 162:tmk_core/common/action.c ****             break;
 163:tmk_core/common/action.c **** #endif
 164:tmk_core/common/action.c ****     }
 165:tmk_core/common/action.c **** }
 166:tmk_core/common/action.c **** #endif
 167:tmk_core/common/action.c **** 
 168:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 169:tmk_core/common/action.c ****  *
 170:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 171:tmk_core/common/action.c ****  */
 172:tmk_core/common/action.c **** void process_record(keyrecord_t *record)
 173:tmk_core/common/action.c **** {
 174:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 175:tmk_core/common/action.c **** 
 176:tmk_core/common/action.c ****     if(!process_record_quantum(record))
 177:tmk_core/common/action.c ****         return;
 178:tmk_core/common/action.c **** 
 179:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 180:tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 181:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 182:tmk_core/common/action.c ****     dprint(" layer_state: "); layer_debug();
 183:tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 184:tmk_core/common/action.c **** #endif
 185:tmk_core/common/action.c ****     dprintln();
 186:tmk_core/common/action.c **** 
 187:tmk_core/common/action.c ****     process_action(record, action);
 188:tmk_core/common/action.c **** }
 189:tmk_core/common/action.c **** 
 190:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 191:tmk_core/common/action.c ****  *
 192:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 193:tmk_core/common/action.c ****  */
 194:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action)
 195:tmk_core/common/action.c **** {
 196:tmk_core/common/action.c ****     keyevent_t event = record->event;
 197:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 198:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 199:tmk_core/common/action.c **** #endif
 200:tmk_core/common/action.c **** 
 201:tmk_core/common/action.c ****     if (event.pressed) {
 202:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 203:tmk_core/common/action.c ****         clear_weak_mods();
 204:tmk_core/common/action.c ****     }
 205:tmk_core/common/action.c **** 
 206:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 207:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 208:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 209:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && !IS_MOD(action.key.code)) {
 210:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 211:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 212:tmk_core/common/action.c ****     }
 213:tmk_core/common/action.c **** #endif
 214:tmk_core/common/action.c **** 
 215:tmk_core/common/action.c ****     switch (action.kind.id) {
 216:tmk_core/common/action.c ****         /* Key and Mods */
 217:tmk_core/common/action.c ****         case ACT_LMODS:
 218:tmk_core/common/action.c ****         case ACT_RMODS:
 219:tmk_core/common/action.c ****             {
 220:tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS) ?  action.key.mods :
 221:tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 222:tmk_core/common/action.c ****                 if (event.pressed) {
 223:tmk_core/common/action.c ****                     if (mods) {
 224:tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 225:tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 226:tmk_core/common/action.c ****                             // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSF
 227:tmk_core/common/action.c ****                             // Same applies for some keys like KC_MEH which are declared as MEH(KC_
 228:tmk_core/common/action.c ****                             add_mods(mods);
 229:tmk_core/common/action.c ****                         } else {
 230:tmk_core/common/action.c ****                             add_weak_mods(mods);
 231:tmk_core/common/action.c ****                         }
 232:tmk_core/common/action.c ****                         send_keyboard_report();
 233:tmk_core/common/action.c ****                     }
 234:tmk_core/common/action.c ****                     register_code(action.key.code);
 235:tmk_core/common/action.c ****                 } else {
 236:tmk_core/common/action.c ****                     unregister_code(action.key.code);
 237:tmk_core/common/action.c ****                     if (mods) {
 238:tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 239:tmk_core/common/action.c ****                             del_mods(mods);
 240:tmk_core/common/action.c ****                         } else {
 241:tmk_core/common/action.c ****                             del_weak_mods(mods);
 242:tmk_core/common/action.c ****                         }
 243:tmk_core/common/action.c ****                         send_keyboard_report();
 244:tmk_core/common/action.c ****                     }
 245:tmk_core/common/action.c ****                 }
 246:tmk_core/common/action.c ****             }
 247:tmk_core/common/action.c ****             break;
 248:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 249:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 250:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 251:tmk_core/common/action.c ****             {
 252:tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ?  action.key.mods :
 253:tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 254:tmk_core/common/action.c ****                 switch (action.layer_tap.code) {
 255:tmk_core/common/action.c ****     #ifndef NO_ACTION_ONESHOT
 256:tmk_core/common/action.c ****                     case MODS_ONESHOT:
 257:tmk_core/common/action.c ****                         // Oneshot modifier
 258:tmk_core/common/action.c ****                         if (event.pressed) {
 259:tmk_core/common/action.c ****                             if (tap_count == 0) {
 260:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 261:tmk_core/common/action.c ****                                 register_mods(mods | get_oneshot_mods());
 262:tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 263:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 264:tmk_core/common/action.c ****                                 set_oneshot_mods(mods | get_oneshot_mods());
 265:tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 266:tmk_core/common/action.c ****                             } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 267:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Toggling oneshot");
 268:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 269:tmk_core/common/action.c ****                                 set_oneshot_locked_mods(mods);
 270:tmk_core/common/action.c ****                                 register_mods(mods);
 271:tmk_core/common/action.c ****                     #endif
 272:tmk_core/common/action.c ****                             } else {
 273:tmk_core/common/action.c ****                                 register_mods(mods | get_oneshot_mods());
 274:tmk_core/common/action.c ****                             }
 275:tmk_core/common/action.c ****                         } else {
 276:tmk_core/common/action.c ****                             if (tap_count == 0) {
 277:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 278:tmk_core/common/action.c ****                                 unregister_mods(mods);
 279:tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 280:tmk_core/common/action.c ****                                 // Retain Oneshot mods
 281:tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 282:tmk_core/common/action.c ****                                 if (mods & get_mods()) {
 283:tmk_core/common/action.c ****                                     clear_oneshot_locked_mods();
 284:tmk_core/common/action.c ****                                     clear_oneshot_mods();
 285:tmk_core/common/action.c ****                                     unregister_mods(mods);
 286:tmk_core/common/action.c ****                                 }
 287:tmk_core/common/action.c ****                             } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 288:tmk_core/common/action.c ****                                 // Toggle Oneshot Layer
 289:tmk_core/common/action.c ****                     #endif
 290:tmk_core/common/action.c ****                             } else {
 291:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 292:tmk_core/common/action.c ****                                 unregister_mods(mods);
 293:tmk_core/common/action.c ****                             }
 294:tmk_core/common/action.c ****                         }
 295:tmk_core/common/action.c ****                         break;
 296:tmk_core/common/action.c ****     #endif
 297:tmk_core/common/action.c ****                     case MODS_TAP_TOGGLE:
 298:tmk_core/common/action.c ****                         if (event.pressed) {
 299:tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 300:tmk_core/common/action.c ****                                 register_mods(mods);
 301:tmk_core/common/action.c ****                             }
 302:tmk_core/common/action.c ****                         } else {
 303:tmk_core/common/action.c ****                             if (tap_count < TAPPING_TOGGLE) {
 304:tmk_core/common/action.c ****                                 unregister_mods(mods);
 305:tmk_core/common/action.c ****                             }
 306:tmk_core/common/action.c ****                         }
 307:tmk_core/common/action.c ****                         break;
 308:tmk_core/common/action.c ****                     default:
 309:tmk_core/common/action.c ****                         if (event.pressed) {
 310:tmk_core/common/action.c ****                             if (tap_count > 0) {
 311:tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 312:tmk_core/common/action.c ****                                 if (record->tap.interrupted) {
 313:tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 314:tmk_core/common/action.c ****                                     // ad hoc: set 0 to cancel tap
 315:tmk_core/common/action.c ****                                     record->tap.count = 0;
 316:tmk_core/common/action.c ****                                     register_mods(mods);
 317:tmk_core/common/action.c ****                                 } else
 318:tmk_core/common/action.c **** #endif
 319:tmk_core/common/action.c ****                                 {
 320:tmk_core/common/action.c ****                                     dprint("MODS_TAP: Tap: register_code\n");
 321:tmk_core/common/action.c ****                                     register_code(action.key.code);
 322:tmk_core/common/action.c ****                                 }
 323:tmk_core/common/action.c ****                             } else {
 324:tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 325:tmk_core/common/action.c ****                                 register_mods(mods);
 326:tmk_core/common/action.c ****                             }
 327:tmk_core/common/action.c ****                         } else {
 328:tmk_core/common/action.c ****                             if (tap_count > 0) {
 329:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 330:tmk_core/common/action.c ****                                 unregister_code(action.key.code);
 331:tmk_core/common/action.c ****                             } else {
 332:tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 333:tmk_core/common/action.c ****                                 unregister_mods(mods);
 334:tmk_core/common/action.c ****                             }
 335:tmk_core/common/action.c ****                         }
 336:tmk_core/common/action.c ****                         break;
 337:tmk_core/common/action.c ****                 }
 338:tmk_core/common/action.c ****             }
 339:tmk_core/common/action.c ****             break;
 340:tmk_core/common/action.c **** #endif
 341:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 342:tmk_core/common/action.c ****         /* other HID usage */
 343:tmk_core/common/action.c ****         case ACT_USAGE:
 344:tmk_core/common/action.c ****             switch (action.usage.page) {
 345:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 346:tmk_core/common/action.c ****                     if (event.pressed) {
 347:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 348:tmk_core/common/action.c ****                     } else {
 349:tmk_core/common/action.c ****                         host_system_send(0);
 350:tmk_core/common/action.c ****                     }
 351:tmk_core/common/action.c ****                     break;
 352:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 353:tmk_core/common/action.c ****                     if (event.pressed) {
 354:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 355:tmk_core/common/action.c ****                     } else {
 356:tmk_core/common/action.c ****                         host_consumer_send(0);
 357:tmk_core/common/action.c ****                     }
 358:tmk_core/common/action.c ****                     break;
 359:tmk_core/common/action.c ****             }
 360:tmk_core/common/action.c ****             break;
 361:tmk_core/common/action.c **** #endif
 362:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 363:tmk_core/common/action.c ****         /* Mouse key */
 364:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 365:tmk_core/common/action.c ****             if (event.pressed) {
 366:tmk_core/common/action.c ****                 switch (action.key.code) {
 367:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 368:tmk_core/common/action.c ****                         tp_buttons |= (1<<0);
 369:tmk_core/common/action.c ****                         break;
 370:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 371:tmk_core/common/action.c ****                         tp_buttons |= (1<<1);
 372:tmk_core/common/action.c ****                         break;
 373:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 374:tmk_core/common/action.c ****                         tp_buttons |= (1<<2);
 375:tmk_core/common/action.c ****                         break;
 376:tmk_core/common/action.c ****                     default:
 377:tmk_core/common/action.c ****                         break;
 378:tmk_core/common/action.c ****                 }
 379:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 380:tmk_core/common/action.c ****                 mousekey_send();
 381:tmk_core/common/action.c ****             } else {
 382:tmk_core/common/action.c ****                 switch (action.key.code) {
 383:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 384:tmk_core/common/action.c ****                         tp_buttons &= ~(1<<0);
 385:tmk_core/common/action.c ****                         break;
 386:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 387:tmk_core/common/action.c ****                         tp_buttons &= ~(1<<1);
 388:tmk_core/common/action.c ****                         break;
 389:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 390:tmk_core/common/action.c ****                         tp_buttons &= ~(1<<2);
 391:tmk_core/common/action.c ****                         break;
 392:tmk_core/common/action.c ****                     default:
 393:tmk_core/common/action.c ****                         break;
 394:tmk_core/common/action.c ****                 }
 395:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 396:tmk_core/common/action.c ****                 mousekey_send();
 397:tmk_core/common/action.c ****             }
 398:tmk_core/common/action.c ****             break;
 399:tmk_core/common/action.c **** #endif
 400:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 401:tmk_core/common/action.c ****         case ACT_LAYER:
 402:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 403:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 404:tmk_core/common/action.c ****                 if (!event.pressed) {
 405:tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 406:tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 407:tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 408:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 409:tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 410:tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 411:tmk_core/common/action.c ****                         case OP_BIT_XOR: default_layer_xor(bits | mask); break;
 412:tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 413:tmk_core/common/action.c ****                     }
 414:tmk_core/common/action.c ****                 }
 415:tmk_core/common/action.c ****             } else {
 416:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 417:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) :
 418:tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 419:tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 420:tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 421:tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 422:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 423:tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 424:tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 425:tmk_core/common/action.c ****                         case OP_BIT_XOR: layer_xor(bits | mask); break;
 426:tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 427:tmk_core/common/action.c ****                     }
 428:tmk_core/common/action.c ****                 }
 429:tmk_core/common/action.c ****             }
 430:tmk_core/common/action.c ****             break;
 431:tmk_core/common/action.c ****     #ifndef NO_ACTION_TAPPING
 432:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 433:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 434:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 435:tmk_core/common/action.c ****                 case 0xe0 ... 0xef:
 436:tmk_core/common/action.c ****                     /* layer On/Off with modifiers(left only) */
 437:tmk_core/common/action.c ****                     if (event.pressed) {
 438:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 439:tmk_core/common/action.c ****                         register_mods(action.layer_tap.code & 0x0f);
 440:tmk_core/common/action.c ****                     } else {
 441:tmk_core/common/action.c ****                         layer_off(action.layer_tap.val);
 442:tmk_core/common/action.c ****                         unregister_mods(action.layer_tap.code & 0x0f);
 443:tmk_core/common/action.c ****                     }
 444:tmk_core/common/action.c ****                     break;
 445:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 446:tmk_core/common/action.c ****                     /* tap toggle */
 447:tmk_core/common/action.c ****                     if (event.pressed) {
 448:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 449:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 450:tmk_core/common/action.c ****                         }
 451:tmk_core/common/action.c ****                     } else {
 452:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 453:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 454:tmk_core/common/action.c ****                         }
 455:tmk_core/common/action.c ****                     }
 456:tmk_core/common/action.c ****                     break;
 457:tmk_core/common/action.c ****                 case OP_ON_OFF:
 458:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) :
 459:tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 460:tmk_core/common/action.c ****                     break;
 461:tmk_core/common/action.c ****                 case OP_OFF_ON:
 462:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) :
 463:tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 464:tmk_core/common/action.c ****                     break;
 465:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 466:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) :
 467:tmk_core/common/action.c ****                                     layer_clear();
 468:tmk_core/common/action.c ****                     break;
 469:tmk_core/common/action.c ****             #ifndef NO_ACTION_ONESHOT
 470:tmk_core/common/action.c ****                 case OP_ONESHOT:
 471:tmk_core/common/action.c ****                     // Oneshot modifier
 472:tmk_core/common/action.c ****                 #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 473:tmk_core/common/action.c ****                     do_release_oneshot = false;
 474:tmk_core/common/action.c ****                     if (event.pressed) {
 475:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 476:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 477:tmk_core/common/action.c ****                             reset_oneshot_layer();
 478:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 479:tmk_core/common/action.c ****                             break;
 480:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 481:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 482:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 483:tmk_core/common/action.c ****                         }
 484:tmk_core/common/action.c ****                     } else {
 485:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 486:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 487:tmk_core/common/action.c ****                             reset_oneshot_layer();
 488:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 489:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 490:tmk_core/common/action.c ****                         } else {
 491:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 492:tmk_core/common/action.c ****                         }
 493:tmk_core/common/action.c ****                     }
 494:tmk_core/common/action.c ****                 #else
 495:tmk_core/common/action.c ****                     if (event.pressed) {
 496:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 497:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 498:tmk_core/common/action.c ****                     } else {
 499:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 500:tmk_core/common/action.c ****                         if (tap_count > 1) {
 501:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 502:tmk_core/common/action.c ****                         }
 503:tmk_core/common/action.c ****                     }
 504:tmk_core/common/action.c ****                 #endif
 505:tmk_core/common/action.c ****                     break;
 506:tmk_core/common/action.c ****             #endif
 507:tmk_core/common/action.c ****                 default:
 508:tmk_core/common/action.c ****                     /* tap key */
 509:tmk_core/common/action.c ****                     if (event.pressed) {
 510:tmk_core/common/action.c ****                         if (tap_count > 0) {
 511:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 512:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 513:tmk_core/common/action.c ****                         } else {
 514:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 515:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 516:tmk_core/common/action.c ****                         }
 517:tmk_core/common/action.c ****                     } else {
 518:tmk_core/common/action.c ****                         if (tap_count > 0) {
 519:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 520:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 521:tmk_core/common/action.c ****                                 wait_ms(80);
 522:tmk_core/common/action.c ****                             }
 523:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 524:tmk_core/common/action.c ****                         } else {
 525:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 526:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 527:tmk_core/common/action.c ****                         }
 528:tmk_core/common/action.c ****                     }
 529:tmk_core/common/action.c ****                     break;
 530:tmk_core/common/action.c ****             }
 531:tmk_core/common/action.c ****             break;
 532:tmk_core/common/action.c ****     #endif
 533:tmk_core/common/action.c **** #endif
 534:tmk_core/common/action.c ****         /* Extentions */
 535:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 536:tmk_core/common/action.c ****         case ACT_MACRO:
 537:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 538:tmk_core/common/action.c ****             break;
 539:tmk_core/common/action.c **** #endif
 540:tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
 541:tmk_core/common/action.c ****         case ACT_BACKLIGHT:
 542:tmk_core/common/action.c ****             if (!event.pressed) {
 543:tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 544:tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 545:tmk_core/common/action.c ****                         backlight_increase();
 546:tmk_core/common/action.c ****                         break;
 547:tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 548:tmk_core/common/action.c ****                         backlight_decrease();
 549:tmk_core/common/action.c ****                         break;
 550:tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 551:tmk_core/common/action.c ****                         backlight_toggle();
 552:tmk_core/common/action.c ****                         break;
 553:tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 554:tmk_core/common/action.c ****                         backlight_step();
 555:tmk_core/common/action.c ****                         break;
 556:tmk_core/common/action.c ****                     case BACKLIGHT_ON:
 557:tmk_core/common/action.c ****                         backlight_level(BACKLIGHT_LEVELS);
 558:tmk_core/common/action.c ****                         break;
 559:tmk_core/common/action.c ****                     case BACKLIGHT_OFF:
 560:tmk_core/common/action.c ****                         backlight_level(0);
 561:tmk_core/common/action.c ****                         break;
 562:tmk_core/common/action.c ****                 }
 563:tmk_core/common/action.c ****             }
 564:tmk_core/common/action.c ****             break;
 565:tmk_core/common/action.c **** #endif
 566:tmk_core/common/action.c ****         case ACT_COMMAND:
 567:tmk_core/common/action.c ****             break;
 568:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 569:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 570:tmk_core/common/action.c ****             switch (action.swap.code) {
 571:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 572:tmk_core/common/action.c ****                     if (event.pressed) {
 573:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 574:tmk_core/common/action.c ****                     }
 575:tmk_core/common/action.c ****                     break;
 576:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 577:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 578:tmk_core/common/action.c ****                     break;
 579:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 580:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 581:tmk_core/common/action.c ****                     break;
 582:tmk_core/common/action.c ****                 case OP_SH_ON:
 583:tmk_core/common/action.c ****                     if (!event.pressed) {
 584:tmk_core/common/action.c ****                         swap_hands = true;
 585:tmk_core/common/action.c ****                     }
 586:tmk_core/common/action.c ****                     break;
 587:tmk_core/common/action.c ****                 case OP_SH_OFF:
 588:tmk_core/common/action.c ****                     if (!event.pressed) {
 589:tmk_core/common/action.c ****                         swap_hands = false;
 590:tmk_core/common/action.c ****                     }
 591:tmk_core/common/action.c ****                     break;
 592:tmk_core/common/action.c ****     #ifndef NO_ACTION_TAPPING
 593:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 594:tmk_core/common/action.c ****                     /* tap toggle */
 595:tmk_core/common/action.c **** 
 596:tmk_core/common/action.c ****                     if (event.pressed) {
 597:tmk_core/common/action.c ****                         if (swap_held) {
 598:tmk_core/common/action.c ****                             swap_held = false;
 599:tmk_core/common/action.c ****                         } else {
 600:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 601:tmk_core/common/action.c ****                         }
 602:tmk_core/common/action.c ****                     } else {
 603:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 604:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 605:tmk_core/common/action.c ****                         }
 606:tmk_core/common/action.c ****                     }
 607:tmk_core/common/action.c ****                     break;
 608:tmk_core/common/action.c ****                 default:
 609:tmk_core/common/action.c ****                     /* tap key */
 610:tmk_core/common/action.c ****                     if (tap_count > 0) {
 611:tmk_core/common/action.c ****                         if (swap_held) {
 612:tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 613:tmk_core/common/action.c ****                             swap_held = false;
 614:tmk_core/common/action.c ****                         }
 615:tmk_core/common/action.c ****                         if (event.pressed) {
 616:tmk_core/common/action.c ****                             register_code(action.swap.code);
 617:tmk_core/common/action.c ****                         } else {
 618:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 619:tmk_core/common/action.c ****                             *record = (keyrecord_t){}; // hack: reset tap mode
 620:tmk_core/common/action.c ****                         }
 621:tmk_core/common/action.c ****                     } else {
 622:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 623:tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 624:tmk_core/common/action.c ****                             swap_held = false;
 625:tmk_core/common/action.c ****                         }
 626:tmk_core/common/action.c ****                     }
 627:tmk_core/common/action.c ****     #endif
 628:tmk_core/common/action.c ****             }
 629:tmk_core/common/action.c **** #endif
 630:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 631:tmk_core/common/action.c ****         case ACT_FUNCTION:
 632:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 633:tmk_core/common/action.c ****             break;
 634:tmk_core/common/action.c **** #endif
 635:tmk_core/common/action.c ****         default:
 636:tmk_core/common/action.c ****             break;
 637:tmk_core/common/action.c ****     }
 638:tmk_core/common/action.c **** 
 639:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 640:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 641:tmk_core/common/action.c ****     switch (action.kind.id) {
 642:tmk_core/common/action.c ****         case ACT_LAYER:
 643:tmk_core/common/action.c ****         #ifndef NO_ACTION_TAPPING
 644:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 645:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 646:tmk_core/common/action.c ****         #endif
 647:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 648:tmk_core/common/action.c ****             break;
 649:tmk_core/common/action.c ****         default:
 650:tmk_core/common/action.c ****             break;
 651:tmk_core/common/action.c ****     }
 652:tmk_core/common/action.c **** #endif
 653:tmk_core/common/action.c **** 
 654:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 655:tmk_core/common/action.c ****   #ifdef RETRO_TAPPING
 656:tmk_core/common/action.c ****   if (!is_tap_key(record->event.key)) {
 657:tmk_core/common/action.c ****     retro_tapping_counter = 0;
 658:tmk_core/common/action.c ****   } else {
 659:tmk_core/common/action.c ****     if (event.pressed) {
 660:tmk_core/common/action.c ****         if (tap_count > 0) {
 661:tmk_core/common/action.c ****           retro_tapping_counter = 0;
 662:tmk_core/common/action.c ****         } else {
 663:tmk_core/common/action.c **** 
 664:tmk_core/common/action.c ****         }
 665:tmk_core/common/action.c ****     } else {
 666:tmk_core/common/action.c ****       if (tap_count > 0) {
 667:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 668:tmk_core/common/action.c ****       } else {
 669:tmk_core/common/action.c ****         if (retro_tapping_counter == 2) {
 670:tmk_core/common/action.c ****           register_code(action.layer_tap.code);
 671:tmk_core/common/action.c ****           unregister_code(action.layer_tap.code);
 672:tmk_core/common/action.c ****         }
 673:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 674:tmk_core/common/action.c ****       }
 675:tmk_core/common/action.c ****     }
 676:tmk_core/common/action.c ****   }
 677:tmk_core/common/action.c ****   #endif
 678:tmk_core/common/action.c **** #endif
 679:tmk_core/common/action.c **** 
 680:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 681:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 682:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 683:tmk_core/common/action.c ****      */
 684:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED )   ) {
 685:tmk_core/common/action.c ****         record->event.pressed = false;
 686:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 687:tmk_core/common/action.c ****         process_record(record);
 688:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 689:tmk_core/common/action.c ****     }
 690:tmk_core/common/action.c **** #endif
 691:tmk_core/common/action.c **** }
 692:tmk_core/common/action.c **** 
 693:tmk_core/common/action.c **** 
 694:tmk_core/common/action.c **** 
 695:tmk_core/common/action.c **** 
 696:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 697:tmk_core/common/action.c ****  *
 698:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 699:tmk_core/common/action.c ****  */
 700:tmk_core/common/action.c **** void register_code(uint8_t code)
 701:tmk_core/common/action.c **** {
 137               		.loc 1 701 0
 138               		.cfi_startproc
 139               	.LVL9:
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 0 */
 143               	.L__stack_usage = 0
 702:tmk_core/common/action.c ****     if (code == KC_NO) {
 144               		.loc 1 702 0
 145 0000 8823      		tst r24
 146 0002 01F4      		brne .+2
 147 0004 00C0      		rjmp .L4
 148 0006 682F      		mov r22,r24
 703:tmk_core/common/action.c ****         return;
 704:tmk_core/common/action.c ****     }
 705:tmk_core/common/action.c **** 
 706:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 707:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 149               		.loc 1 707 0
 150 0008 8238      		cpi r24,lo8(-126)
 151 000a 01F4      		brne .L7
 708:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 709:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 710:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK)) return;
 152               		.loc 1 710 0
 153 000c 0E94 0000 		call host_keyboard_leds
 154               	.LVL10:
 155 0010 81FD      		sbrc r24,1
 156 0012 00C0      		rjmp .L4
 157               	.LVL11:
 158               	.LBB44:
 159               	.LBB45:
 160               		.file 2 "tmk_core/common/action_util.h"
   1:tmk_core/common/action_util.h **** /*
   2:tmk_core/common/action_util.h **** Copyright 2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action_util.h **** 
   4:tmk_core/common/action_util.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action_util.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action_util.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action_util.h **** (at your option) any later version.
   8:tmk_core/common/action_util.h **** 
   9:tmk_core/common/action_util.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action_util.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action_util.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action_util.h **** GNU General Public License for more details.
  13:tmk_core/common/action_util.h **** 
  14:tmk_core/common/action_util.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action_util.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action_util.h **** */
  17:tmk_core/common/action_util.h **** #ifndef ACTION_UTIL_H
  18:tmk_core/common/action_util.h **** #define ACTION_UTIL_H
  19:tmk_core/common/action_util.h **** 
  20:tmk_core/common/action_util.h **** #include <stdint.h>
  21:tmk_core/common/action_util.h **** #include "report.h"
  22:tmk_core/common/action_util.h **** 
  23:tmk_core/common/action_util.h **** #ifdef __cplusplus
  24:tmk_core/common/action_util.h **** extern "C" {
  25:tmk_core/common/action_util.h **** #endif
  26:tmk_core/common/action_util.h **** 
  27:tmk_core/common/action_util.h **** extern report_keyboard_t *keyboard_report;
  28:tmk_core/common/action_util.h **** 
  29:tmk_core/common/action_util.h **** void send_keyboard_report(void);
  30:tmk_core/common/action_util.h **** 
  31:tmk_core/common/action_util.h **** /* key */
  32:tmk_core/common/action_util.h **** inline void add_key(uint8_t key) {
  33:tmk_core/common/action_util.h ****   add_key_to_report(keyboard_report, key);
 161               		.loc 2 33 0
 162 0014 69E3      		ldi r22,lo8(57)
 163 0016 8091 0000 		lds r24,keyboard_report
 164 001a 9091 0000 		lds r25,keyboard_report+1
 165 001e 0E94 0000 		call add_key_to_report
 166               	.LVL12:
 167               	.LBE45:
 168               	.LBE44:
 711:tmk_core/common/action.c **** #endif
 712:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 713:tmk_core/common/action.c ****         send_keyboard_report();
 169               		.loc 1 713 0
 170 0022 0E94 0000 		call send_keyboard_report
 171               	.LVL13:
 172               	.LBB46:
 173               	.LBB47:
 174               		.file 3 "c:\\msys64\\home\\cris almanza\\qmk_utils\\avr8-gnu-toolchain\\avr\\include\\util\\delay.
   1:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id$ */
  34:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 175               		.loc 3 187 0
 176 0026 2FEF      		ldi r18,lo8(319999)
 177 0028 81EE      		ldi r24,hi8(319999)
 178 002a 94E0      		ldi r25,hlo8(319999)
 179 002c 2150      	1:	subi r18,1
 180 002e 8040      		sbci r24,0
 181 0030 9040      		sbci r25,0
 182 0032 01F4      		brne 1b
 183 0034 00C0      		rjmp .
 184 0036 0000      		nop
 185               	.LVL14:
 186               	.LBE47:
 187               	.LBE46:
 188               	.LBB48:
 189               	.LBB49:
  34:tmk_core/common/action_util.h **** }
  35:tmk_core/common/action_util.h **** 
  36:tmk_core/common/action_util.h **** inline void del_key(uint8_t key) {
  37:tmk_core/common/action_util.h ****   del_key_from_report(keyboard_report, key);
 190               		.loc 2 37 0
 191 0038 69E3      		ldi r22,lo8(57)
 192 003a 00C0      		rjmp .L39
 193               	.LVL15:
 194               	.L7:
 195               	.LBE49:
 196               	.LBE48:
 714:tmk_core/common/action.c ****         wait_ms(100);
 715:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 716:tmk_core/common/action.c ****         send_keyboard_report();
 717:tmk_core/common/action.c ****     }
 718:tmk_core/common/action.c **** 
 719:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 197               		.loc 1 719 0
 198 003c 8338      		cpi r24,lo8(-125)
 199 003e 01F4      		brne .L9
 720:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 721:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_NUM_LOCK)) return;
 200               		.loc 1 721 0
 201 0040 0E94 0000 		call host_keyboard_leds
 202               	.LVL16:
 203 0044 80FD      		sbrc r24,0
 204 0046 00C0      		rjmp .L4
 205               	.LVL17:
 206               	.LBB50:
 207               	.LBB51:
  33:tmk_core/common/action_util.h **** }
 208               		.loc 2 33 0
 209 0048 63E5      		ldi r22,lo8(83)
 210 004a 8091 0000 		lds r24,keyboard_report
 211 004e 9091 0000 		lds r25,keyboard_report+1
 212 0052 0E94 0000 		call add_key_to_report
 213               	.LVL18:
 214               	.LBE51:
 215               	.LBE50:
 722:tmk_core/common/action.c **** #endif
 723:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 724:tmk_core/common/action.c ****         send_keyboard_report();
 216               		.loc 1 724 0
 217 0056 0E94 0000 		call send_keyboard_report
 218               	.LVL19:
 219               	.LBB52:
 220               	.LBB53:
 221               		.loc 3 187 0
 222 005a 2FEF      		ldi r18,lo8(319999)
 223 005c 81EE      		ldi r24,hi8(319999)
 224 005e 94E0      		ldi r25,hlo8(319999)
 225 0060 2150      	1:	subi r18,1
 226 0062 8040      		sbci r24,0
 227 0064 9040      		sbci r25,0
 228 0066 01F4      		brne 1b
 229 0068 00C0      		rjmp .
 230 006a 0000      		nop
 231               	.LVL20:
 232               	.LBE53:
 233               	.LBE52:
 234               	.LBB54:
 235               	.LBB55:
 236               		.loc 2 37 0
 237 006c 63E5      		ldi r22,lo8(83)
 238               	.LVL21:
 239               	.L39:
 240 006e 8091 0000 		lds r24,keyboard_report
 241 0072 9091 0000 		lds r25,keyboard_report+1
 242 0076 0E94 0000 		call del_key_from_report
 243               	.LVL22:
 244               	.L40:
 245               	.LBE55:
 246               	.LBE54:
 725:tmk_core/common/action.c ****         wait_ms(100);
 726:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 727:tmk_core/common/action.c ****         send_keyboard_report();
 247               		.loc 1 727 0
 248 007a 0C94 0000 		jmp send_keyboard_report
 249               	.LVL23:
 250               	.L9:
 728:tmk_core/common/action.c ****     }
 729:tmk_core/common/action.c **** 
 730:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 251               		.loc 1 730 0
 252 007e 8438      		cpi r24,lo8(-124)
 253 0080 01F4      		brne .L10
 731:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 732:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK)) return;
 254               		.loc 1 732 0
 255 0082 0E94 0000 		call host_keyboard_leds
 256               	.LVL24:
 257 0086 82FD      		sbrc r24,2
 258 0088 00C0      		rjmp .L4
 259               	.LVL25:
 260               	.LBB56:
 261               	.LBB57:
  33:tmk_core/common/action_util.h **** }
 262               		.loc 2 33 0
 263 008a 67E4      		ldi r22,lo8(71)
 264 008c 8091 0000 		lds r24,keyboard_report
 265 0090 9091 0000 		lds r25,keyboard_report+1
 266 0094 0E94 0000 		call add_key_to_report
 267               	.LVL26:
 268               	.LBE57:
 269               	.LBE56:
 733:tmk_core/common/action.c **** #endif
 734:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 735:tmk_core/common/action.c ****         send_keyboard_report();
 270               		.loc 1 735 0
 271 0098 0E94 0000 		call send_keyboard_report
 272               	.LVL27:
 273               	.LBB58:
 274               	.LBB59:
 275               		.loc 3 187 0
 276 009c 2FEF      		ldi r18,lo8(319999)
 277 009e 81EE      		ldi r24,hi8(319999)
 278 00a0 94E0      		ldi r25,hlo8(319999)
 279 00a2 2150      	1:	subi r18,1
 280 00a4 8040      		sbci r24,0
 281 00a6 9040      		sbci r25,0
 282 00a8 01F4      		brne 1b
 283 00aa 00C0      		rjmp .
 284 00ac 0000      		nop
 285               	.LVL28:
 286               	.LBE59:
 287               	.LBE58:
 288               	.LBB60:
 289               	.LBB61:
 290               		.loc 2 37 0
 291 00ae 67E4      		ldi r22,lo8(71)
 292 00b0 00C0      		rjmp .L39
 293               	.LVL29:
 294               	.L10:
 295               	.LBE61:
 296               	.LBE60:
 736:tmk_core/common/action.c ****         wait_ms(100);
 737:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 738:tmk_core/common/action.c ****         send_keyboard_report();
 739:tmk_core/common/action.c ****     }
 740:tmk_core/common/action.c **** #endif
 741:tmk_core/common/action.c **** 
 742:tmk_core/common/action.c ****     else if IS_KEY(code) {
 297               		.loc 1 742 0
 298 00b2 8CEF      		ldi r24,lo8(-4)
 299 00b4 860F      		add r24,r22
 300 00b6 813A      		cpi r24,lo8(-95)
 301 00b8 00F4      		brsh .L11
 302               	.LVL30:
 303               	.LBB62:
 304               	.LBB63:
  33:tmk_core/common/action_util.h **** }
 305               		.loc 2 33 0
 306 00ba 8091 0000 		lds r24,keyboard_report
 307 00be 9091 0000 		lds r25,keyboard_report+1
 308 00c2 0E94 0000 		call add_key_to_report
 309               	.LVL31:
 310 00c6 00C0      		rjmp .L40
 311               	.LVL32:
 312               	.L11:
 313               	.LBE63:
 314               	.LBE62:
 743:tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 744:tmk_core/common/action.c ****         if (command_proc(code)) return;
 745:tmk_core/common/action.c **** 
 746:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 747:tmk_core/common/action.c **** /* TODO: remove
 748:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 749:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 750:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 751:tmk_core/common/action.c **** 
 752:tmk_core/common/action.c ****             add_key(code);
 753:tmk_core/common/action.c ****             send_keyboard_report();
 754:tmk_core/common/action.c **** 
 755:tmk_core/common/action.c ****             set_mods(tmp_mods);
 756:tmk_core/common/action.c ****             send_keyboard_report();
 757:tmk_core/common/action.c ****             oneshot_cancel();
 758:tmk_core/common/action.c ****         } else
 759:tmk_core/common/action.c **** */
 760:tmk_core/common/action.c **** #endif
 761:tmk_core/common/action.c ****         {
 762:tmk_core/common/action.c ****             add_key(code);
 763:tmk_core/common/action.c ****             send_keyboard_report();
 764:tmk_core/common/action.c ****         }
 765:tmk_core/common/action.c ****     }
 766:tmk_core/common/action.c ****     else if IS_MOD(code) {
 315               		.loc 1 766 0
 316 00c8 80E2      		ldi r24,lo8(32)
 317 00ca 860F      		add r24,r22
 318 00cc 8830      		cpi r24,lo8(8)
 319 00ce 00F4      		brsh .L12
 767:tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 320               		.loc 1 767 0
 321 00d0 6770      		andi r22,lo8(7)
 322               	.LVL33:
 323 00d2 81E0      		ldi r24,lo8(1)
 324 00d4 00C0      		rjmp 2f
 325               		1:
 326 00d6 880F      		lsl r24
 327               		2:
 328 00d8 6A95      		dec r22
 329 00da 02F4      		brpl 1b
 330 00dc 0E94 0000 		call add_mods
 331               	.LVL34:
 332 00e0 00C0      		rjmp .L40
 333               	.LVL35:
 334               	.L12:
 768:tmk_core/common/action.c ****         send_keyboard_report();
 769:tmk_core/common/action.c ****     }
 770:tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 335               		.loc 1 770 0
 336 00e2 8BE5      		ldi r24,lo8(91)
 337 00e4 860F      		add r24,r22
 338 00e6 8330      		cpi r24,lo8(3)
 339 00e8 00F4      		brsh .L13
 771:tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 340               		.loc 1 771 0
 341 00ea 653A      		cpi r22,lo8(-91)
 342 00ec 01F0      		breq .L16
 343               		.loc 1 771 0 is_stmt 0 discriminator 1
 344 00ee 663A      		cpi r22,lo8(-90)
 345 00f0 01F0      		breq .L17
 346               		.loc 1 771 0
 347 00f2 83E8      		ldi r24,lo8(-125)
 348 00f4 90E0      		ldi r25,0
 349 00f6 00C0      		rjmp .L14
 350               	.L16:
 351 00f8 81E8      		ldi r24,lo8(-127)
 352 00fa 90E0      		ldi r25,0
 353 00fc 00C0      		rjmp .L14
 354               	.L17:
 355 00fe 82E8      		ldi r24,lo8(-126)
 356 0100 90E0      		ldi r25,0
 357               	.L14:
 358               		.loc 1 771 0 discriminator 12
 359 0102 0C94 0000 		jmp host_system_send
 360               	.LVL36:
 361               	.L13:
 772:tmk_core/common/action.c ****     }
 773:tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 362               		.loc 1 773 0 is_stmt 1
 363 0106 88E5      		ldi r24,lo8(88)
 364 0108 860F      		add r24,r22
 365 010a 8531      		cpi r24,lo8(21)
 366 010c 00F0      		brlo .+2
 367 010e 00C0      		rjmp .L4
 774:tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 368               		.loc 1 774 0
 369 0110 683A      		cpi r22,lo8(-88)
 370 0112 01F0      		breq .L18
 371               		.loc 1 774 0 is_stmt 0 discriminator 1
 372 0114 693A      		cpi r22,lo8(-87)
 373 0116 01F0      		breq .L19
 374               		.loc 1 774 0 discriminator 3
 375 0118 6A3A      		cpi r22,lo8(-86)
 376 011a 01F0      		breq .L20
 377               		.loc 1 774 0 discriminator 5
 378 011c 6B3A      		cpi r22,lo8(-85)
 379 011e 01F0      		breq .L21
 380               		.loc 1 774 0 discriminator 7
 381 0120 6C3A      		cpi r22,lo8(-84)
 382 0122 01F0      		breq .L22
 383               		.loc 1 774 0 discriminator 9
 384 0124 6B3B      		cpi r22,lo8(-69)
 385 0126 01F0      		breq .L23
 386               		.loc 1 774 0 discriminator 11
 387 0128 6C3B      		cpi r22,lo8(-68)
 388 012a 01F0      		breq .L24
 389               		.loc 1 774 0 discriminator 13
 390 012c 6D3A      		cpi r22,lo8(-83)
 391 012e 01F0      		breq .L25
 392               		.loc 1 774 0 discriminator 15
 393 0130 603B      		cpi r22,lo8(-80)
 394 0132 01F0      		breq .L26
 395               		.loc 1 774 0 discriminator 17
 396 0134 6E3A      		cpi r22,lo8(-82)
 397 0136 01F0      		breq .L27
 398               		.loc 1 774 0 discriminator 19
 399 0138 6F3A      		cpi r22,lo8(-81)
 400 013a 01F0      		breq .L28
 401               		.loc 1 774 0 discriminator 21
 402 013c 613B      		cpi r22,lo8(-79)
 403 013e 01F0      		breq .L29
 404               		.loc 1 774 0 discriminator 23
 405 0140 623B      		cpi r22,lo8(-78)
 406 0142 01F0      		breq .L30
 407               		.loc 1 774 0 discriminator 25
 408 0144 633B      		cpi r22,lo8(-77)
 409 0146 01F0      		breq .L31
 410               		.loc 1 774 0 discriminator 27
 411 0148 643B      		cpi r22,lo8(-76)
 412 014a 01F0      		breq .L32
 413               		.loc 1 774 0 discriminator 29
 414 014c 653B      		cpi r22,lo8(-75)
 415 014e 01F0      		breq .L33
 416               		.loc 1 774 0 discriminator 31
 417 0150 663B      		cpi r22,lo8(-74)
 418 0152 01F0      		breq .L34
 419               		.loc 1 774 0 discriminator 33
 420 0154 673B      		cpi r22,lo8(-73)
 421 0156 01F0      		breq .L35
 422               		.loc 1 774 0 discriminator 35
 423 0158 683B      		cpi r22,lo8(-72)
 424 015a 01F0      		breq .L36
 425               		.loc 1 774 0 discriminator 37
 426 015c 693B      		cpi r22,lo8(-71)
 427 015e 01F0      		breq .L37
 428               		.loc 1 774 0 discriminator 39
 429 0160 6A3B      		cpi r22,lo8(-70)
 430 0162 01F4      		brne .+2
 431 0164 00C0      		rjmp .L38
 432               		.loc 1 774 0
 433 0166 80E0      		ldi r24,0
 434 0168 90E0      		ldi r25,0
 435 016a 00C0      		rjmp .L15
 436               	.L18:
 437 016c 82EE      		ldi r24,lo8(-30)
 438 016e 90E0      		ldi r25,0
 439 0170 00C0      		rjmp .L15
 440               	.L19:
 441 0172 89EE      		ldi r24,lo8(-23)
 442 0174 90E0      		ldi r25,0
 443 0176 00C0      		rjmp .L15
 444               	.L20:
 445 0178 8AEE      		ldi r24,lo8(-22)
 446 017a 90E0      		ldi r25,0
 447 017c 00C0      		rjmp .L15
 448               	.L21:
 449 017e 85EB      		ldi r24,lo8(-75)
 450 0180 90E0      		ldi r25,0
 451 0182 00C0      		rjmp .L15
 452               	.L22:
 453 0184 86EB      		ldi r24,lo8(-74)
 454 0186 90E0      		ldi r25,0
 455 0188 00C0      		rjmp .L15
 456               	.L23:
 457 018a 83EB      		ldi r24,lo8(-77)
 458 018c 90E0      		ldi r25,0
 459 018e 00C0      		rjmp .L15
 460               	.L24:
 461 0190 84EB      		ldi r24,lo8(-76)
 462 0192 90E0      		ldi r25,0
 463 0194 00C0      		rjmp .L15
 464               	.L25:
 465 0196 87EB      		ldi r24,lo8(-73)
 466 0198 90E0      		ldi r25,0
 467 019a 00C0      		rjmp .L15
 468               	.L26:
 469 019c 8CEC      		ldi r24,lo8(-52)
 470 019e 90E0      		ldi r25,0
 471 01a0 00C0      		rjmp .L15
 472               	.L27:
 473 01a2 8DEC      		ldi r24,lo8(-51)
 474 01a4 90E0      		ldi r25,0
 475 01a6 00C0      		rjmp .L15
 476               	.L28:
 477 01a8 83E8      		ldi r24,lo8(-125)
 478 01aa 91E0      		ldi r25,lo8(1)
 479 01ac 00C0      		rjmp .L15
 480               	.L29:
 481 01ae 8AE8      		ldi r24,lo8(-118)
 482 01b0 91E0      		ldi r25,lo8(1)
 483 01b2 00C0      		rjmp .L15
 484               	.L30:
 485 01b4 82E9      		ldi r24,lo8(-110)
 486 01b6 91E0      		ldi r25,lo8(1)
 487 01b8 00C0      		rjmp .L15
 488               	.L31:
 489 01ba 84E9      		ldi r24,lo8(-108)
 490 01bc 91E0      		ldi r25,lo8(1)
 491 01be 00C0      		rjmp .L15
 492               	.L32:
 493 01c0 81E2      		ldi r24,lo8(33)
 494 01c2 92E0      		ldi r25,lo8(2)
 495 01c4 00C0      		rjmp .L15
 496               	.L33:
 497 01c6 83E2      		ldi r24,lo8(35)
 498 01c8 92E0      		ldi r25,lo8(2)
 499 01ca 00C0      		rjmp .L15
 500               	.L34:
 501 01cc 84E2      		ldi r24,lo8(36)
 502 01ce 92E0      		ldi r25,lo8(2)
 503 01d0 00C0      		rjmp .L15
 504               	.L35:
 505 01d2 85E2      		ldi r24,lo8(37)
 506 01d4 92E0      		ldi r25,lo8(2)
 507 01d6 00C0      		rjmp .L15
 508               	.L36:
 509 01d8 86E2      		ldi r24,lo8(38)
 510 01da 92E0      		ldi r25,lo8(2)
 511 01dc 00C0      		rjmp .L15
 512               	.L37:
 513 01de 87E2      		ldi r24,lo8(39)
 514 01e0 92E0      		ldi r25,lo8(2)
 515 01e2 00C0      		rjmp .L15
 516               	.L38:
 517 01e4 8AE2      		ldi r24,lo8(42)
 518 01e6 92E0      		ldi r25,lo8(2)
 519               	.L15:
 520               		.loc 1 774 0 discriminator 84
 521 01e8 0C94 0000 		jmp host_consumer_send
 522               	.LVL37:
 523               	.L4:
 524 01ec 0895      		ret
 525               		.cfi_endproc
 526               	.LFE19:
 528               		.section	.text.unregister_code,"ax",@progbits
 529               	.global	unregister_code
 531               	unregister_code:
 532               	.LFB20:
 775:tmk_core/common/action.c ****     }
 776:tmk_core/common/action.c **** }
 777:tmk_core/common/action.c **** 
 778:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 779:tmk_core/common/action.c ****  *
 780:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 781:tmk_core/common/action.c ****  */
 782:tmk_core/common/action.c **** void unregister_code(uint8_t code)
 783:tmk_core/common/action.c **** {
 533               		.loc 1 783 0 is_stmt 1
 534               		.cfi_startproc
 535               	.LVL38:
 536               	/* prologue: function */
 537               	/* frame size = 0 */
 538               	/* stack size = 0 */
 539               	.L__stack_usage = 0
 784:tmk_core/common/action.c ****     if (code == KC_NO) {
 540               		.loc 1 784 0
 541 0000 8823      		tst r24
 542 0002 01F4      		brne .+2
 543 0004 00C0      		rjmp .L42
 544 0006 682F      		mov r22,r24
 785:tmk_core/common/action.c ****         return;
 786:tmk_core/common/action.c ****     }
 787:tmk_core/common/action.c **** 
 788:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 789:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 545               		.loc 1 789 0
 546 0008 8238      		cpi r24,lo8(-126)
 547 000a 01F4      		brne .L45
 790:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 791:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 792:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK))) return;
 548               		.loc 1 792 0
 549 000c 0E94 0000 		call host_keyboard_leds
 550               	.LVL39:
 551 0010 81FF      		sbrs r24,1
 552 0012 00C0      		rjmp .L42
 553               	.LVL40:
 554               	.LBB64:
 555               	.LBB65:
  33:tmk_core/common/action_util.h **** }
 556               		.loc 2 33 0
 557 0014 69E3      		ldi r22,lo8(57)
 558 0016 8091 0000 		lds r24,keyboard_report
 559 001a 9091 0000 		lds r25,keyboard_report+1
 560 001e 0E94 0000 		call add_key_to_report
 561               	.LVL41:
 562               	.LBE65:
 563               	.LBE64:
 793:tmk_core/common/action.c **** #endif
 794:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 795:tmk_core/common/action.c ****         send_keyboard_report();
 564               		.loc 1 795 0
 565 0022 0E94 0000 		call send_keyboard_report
 566               	.LVL42:
 567               	.LBB66:
 568               	.LBB67:
 569               		.loc 2 37 0
 570 0026 69E3      		ldi r22,lo8(57)
 571 0028 00C0      		rjmp .L61
 572               	.LVL43:
 573               	.L45:
 574               	.LBE67:
 575               	.LBE66:
 796:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 797:tmk_core/common/action.c ****         send_keyboard_report();
 798:tmk_core/common/action.c ****     }
 799:tmk_core/common/action.c **** 
 800:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 576               		.loc 1 800 0
 577 002a 8338      		cpi r24,lo8(-125)
 578 002c 01F4      		brne .L47
 801:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 802:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_NUM_LOCK))) return;
 579               		.loc 1 802 0
 580 002e 0E94 0000 		call host_keyboard_leds
 581               	.LVL44:
 582 0032 80FF      		sbrs r24,0
 583 0034 00C0      		rjmp .L42
 584               	.LVL45:
 585               	.LBB68:
 586               	.LBB69:
  33:tmk_core/common/action_util.h **** }
 587               		.loc 2 33 0
 588 0036 63E5      		ldi r22,lo8(83)
 589 0038 8091 0000 		lds r24,keyboard_report
 590 003c 9091 0000 		lds r25,keyboard_report+1
 591 0040 0E94 0000 		call add_key_to_report
 592               	.LVL46:
 593               	.LBE69:
 594               	.LBE68:
 803:tmk_core/common/action.c **** #endif
 804:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 805:tmk_core/common/action.c ****         send_keyboard_report();
 595               		.loc 1 805 0
 596 0044 0E94 0000 		call send_keyboard_report
 597               	.LVL47:
 598               	.LBB70:
 599               	.LBB71:
 600               		.loc 2 37 0
 601 0048 63E5      		ldi r22,lo8(83)
 602               	.LVL48:
 603               	.L61:
 604 004a 8091 0000 		lds r24,keyboard_report
 605 004e 9091 0000 		lds r25,keyboard_report+1
 606 0052 0E94 0000 		call del_key_from_report
 607               	.LVL49:
 608               	.L62:
 609               	.LBE71:
 610               	.LBE70:
 806:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 807:tmk_core/common/action.c ****         send_keyboard_report();
 611               		.loc 1 807 0
 612 0056 0C94 0000 		jmp send_keyboard_report
 613               	.LVL50:
 614               	.L47:
 808:tmk_core/common/action.c ****     }
 809:tmk_core/common/action.c **** 
 810:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 615               		.loc 1 810 0
 616 005a 8438      		cpi r24,lo8(-124)
 617 005c 01F4      		brne .L48
 811:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 812:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK))) return;
 618               		.loc 1 812 0
 619 005e 0E94 0000 		call host_keyboard_leds
 620               	.LVL51:
 621 0062 82FF      		sbrs r24,2
 622 0064 00C0      		rjmp .L42
 623               	.LVL52:
 624               	.LBB72:
 625               	.LBB73:
  33:tmk_core/common/action_util.h **** }
 626               		.loc 2 33 0
 627 0066 67E4      		ldi r22,lo8(71)
 628 0068 8091 0000 		lds r24,keyboard_report
 629 006c 9091 0000 		lds r25,keyboard_report+1
 630 0070 0E94 0000 		call add_key_to_report
 631               	.LVL53:
 632               	.LBE73:
 633               	.LBE72:
 813:tmk_core/common/action.c **** #endif
 814:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 815:tmk_core/common/action.c ****         send_keyboard_report();
 634               		.loc 1 815 0
 635 0074 0E94 0000 		call send_keyboard_report
 636               	.LVL54:
 637               	.LBB74:
 638               	.LBB75:
 639               		.loc 2 37 0
 640 0078 67E4      		ldi r22,lo8(71)
 641 007a 00C0      		rjmp .L61
 642               	.LVL55:
 643               	.L48:
 644               	.LBE75:
 645               	.LBE74:
 816:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 817:tmk_core/common/action.c ****         send_keyboard_report();
 818:tmk_core/common/action.c ****     }
 819:tmk_core/common/action.c **** #endif
 820:tmk_core/common/action.c **** 
 821:tmk_core/common/action.c ****     else if IS_KEY(code) {
 646               		.loc 1 821 0
 647 007c 8CEF      		ldi r24,lo8(-4)
 648 007e 860F      		add r24,r22
 649 0080 813A      		cpi r24,lo8(-95)
 650 0082 00F0      		brlo .L61
 822:tmk_core/common/action.c ****         del_key(code);
 823:tmk_core/common/action.c ****         send_keyboard_report();
 824:tmk_core/common/action.c ****     }
 825:tmk_core/common/action.c ****     else if IS_MOD(code) {
 651               		.loc 1 825 0
 652 0084 80E2      		ldi r24,lo8(32)
 653 0086 860F      		add r24,r22
 654 0088 8830      		cpi r24,lo8(8)
 655 008a 00F4      		brsh .L50
 826:tmk_core/common/action.c ****         del_mods(MOD_BIT(code));
 656               		.loc 1 826 0
 657 008c 6770      		andi r22,lo8(7)
 658               	.LVL56:
 659 008e 81E0      		ldi r24,lo8(1)
 660 0090 00C0      		rjmp 2f
 661               		1:
 662 0092 880F      		lsl r24
 663               		2:
 664 0094 6A95      		dec r22
 665 0096 02F4      		brpl 1b
 666 0098 0E94 0000 		call del_mods
 667               	.LVL57:
 668 009c 00C0      		rjmp .L62
 669               	.LVL58:
 670               	.L50:
 827:tmk_core/common/action.c ****         send_keyboard_report();
 828:tmk_core/common/action.c ****     }
 829:tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 671               		.loc 1 829 0
 672 009e 8BE5      		ldi r24,lo8(91)
 673 00a0 860F      		add r24,r22
 674 00a2 8330      		cpi r24,lo8(3)
 675 00a4 00F4      		brsh .L51
 830:tmk_core/common/action.c ****         host_system_send(0);
 676               		.loc 1 830 0
 677 00a6 80E0      		ldi r24,0
 678 00a8 90E0      		ldi r25,0
 679 00aa 0C94 0000 		jmp host_system_send
 680               	.LVL59:
 681               	.L51:
 831:tmk_core/common/action.c ****     }
 832:tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 682               		.loc 1 832 0
 683 00ae 685A      		subi r22,lo8(-(88))
 684               	.LVL60:
 685 00b0 6531      		cpi r22,lo8(21)
 686 00b2 00F4      		brsh .L42
 833:tmk_core/common/action.c ****         host_consumer_send(0);
 687               		.loc 1 833 0
 688 00b4 80E0      		ldi r24,0
 689 00b6 90E0      		ldi r25,0
 690 00b8 0C94 0000 		jmp host_consumer_send
 691               	.LVL61:
 692               	.L42:
 693 00bc 0895      		ret
 694               		.cfi_endproc
 695               	.LFE20:
 697               		.section	.text.register_mods,"ax",@progbits
 698               	.global	register_mods
 700               	register_mods:
 701               	.LFB21:
 834:tmk_core/common/action.c ****     }
 835:tmk_core/common/action.c **** }
 836:tmk_core/common/action.c **** 
 837:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 838:tmk_core/common/action.c ****  *
 839:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 840:tmk_core/common/action.c ****  */
 841:tmk_core/common/action.c **** void register_mods(uint8_t mods)
 842:tmk_core/common/action.c **** {
 702               		.loc 1 842 0
 703               		.cfi_startproc
 704               	.LVL62:
 705               	/* prologue: function */
 706               	/* frame size = 0 */
 707               	/* stack size = 0 */
 708               	.L__stack_usage = 0
 843:tmk_core/common/action.c ****     if (mods) {
 709               		.loc 1 843 0
 710 0000 8823      		tst r24
 711 0002 01F0      		breq .L63
 844:tmk_core/common/action.c ****         add_mods(mods);
 712               		.loc 1 844 0
 713 0004 0E94 0000 		call add_mods
 714               	.LVL63:
 845:tmk_core/common/action.c ****         send_keyboard_report();
 715               		.loc 1 845 0
 716 0008 0C94 0000 		jmp send_keyboard_report
 717               	.LVL64:
 718               	.L63:
 719 000c 0895      		ret
 720               		.cfi_endproc
 721               	.LFE21:
 723               		.section	.text.unregister_mods,"ax",@progbits
 724               	.global	unregister_mods
 726               	unregister_mods:
 727               	.LFB22:
 846:tmk_core/common/action.c ****     }
 847:tmk_core/common/action.c **** }
 848:tmk_core/common/action.c **** 
 849:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 850:tmk_core/common/action.c ****  *
 851:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 852:tmk_core/common/action.c ****  */
 853:tmk_core/common/action.c **** void unregister_mods(uint8_t mods)
 854:tmk_core/common/action.c **** {
 728               		.loc 1 854 0
 729               		.cfi_startproc
 730               	.LVL65:
 731               	/* prologue: function */
 732               	/* frame size = 0 */
 733               	/* stack size = 0 */
 734               	.L__stack_usage = 0
 855:tmk_core/common/action.c ****     if (mods) {
 735               		.loc 1 855 0
 736 0000 8823      		tst r24
 737 0002 01F0      		breq .L65
 856:tmk_core/common/action.c ****         del_mods(mods);
 738               		.loc 1 856 0
 739 0004 0E94 0000 		call del_mods
 740               	.LVL66:
 857:tmk_core/common/action.c ****         send_keyboard_report();
 741               		.loc 1 857 0
 742 0008 0C94 0000 		jmp send_keyboard_report
 743               	.LVL67:
 744               	.L65:
 745 000c 0895      		ret
 746               		.cfi_endproc
 747               	.LFE22:
 749               		.section	.text.process_action,"ax",@progbits
 750               	.global	process_action
 752               	process_action:
 753               	.LFB18:
 195:tmk_core/common/action.c ****     keyevent_t event = record->event;
 754               		.loc 1 195 0
 755               		.cfi_startproc
 756               	.LVL68:
 757 0000 4F92      		push r4
 758               	.LCFI4:
 759               		.cfi_def_cfa_offset 3
 760               		.cfi_offset 4, -2
 761 0002 5F92      		push r5
 762               	.LCFI5:
 763               		.cfi_def_cfa_offset 4
 764               		.cfi_offset 5, -3
 765 0004 6F92      		push r6
 766               	.LCFI6:
 767               		.cfi_def_cfa_offset 5
 768               		.cfi_offset 6, -4
 769 0006 7F92      		push r7
 770               	.LCFI7:
 771               		.cfi_def_cfa_offset 6
 772               		.cfi_offset 7, -5
 773 0008 BF92      		push r11
 774               	.LCFI8:
 775               		.cfi_def_cfa_offset 7
 776               		.cfi_offset 11, -6
 777 000a CF92      		push r12
 778               	.LCFI9:
 779               		.cfi_def_cfa_offset 8
 780               		.cfi_offset 12, -7
 781 000c DF92      		push r13
 782               	.LCFI10:
 783               		.cfi_def_cfa_offset 9
 784               		.cfi_offset 13, -8
 785 000e EF92      		push r14
 786               	.LCFI11:
 787               		.cfi_def_cfa_offset 10
 788               		.cfi_offset 14, -9
 789 0010 FF92      		push r15
 790               	.LCFI12:
 791               		.cfi_def_cfa_offset 11
 792               		.cfi_offset 15, -10
 793 0012 0F93      		push r16
 794               	.LCFI13:
 795               		.cfi_def_cfa_offset 12
 796               		.cfi_offset 16, -11
 797 0014 1F93      		push r17
 798               	.LCFI14:
 799               		.cfi_def_cfa_offset 13
 800               		.cfi_offset 17, -12
 801 0016 CF93      		push r28
 802               	.LCFI15:
 803               		.cfi_def_cfa_offset 14
 804               		.cfi_offset 28, -13
 805 0018 DF93      		push r29
 806               	.LCFI16:
 807               		.cfi_def_cfa_offset 15
 808               		.cfi_offset 29, -14
 809               	/* prologue: function */
 810               	/* frame size = 0 */
 811               	/* stack size = 13 */
 812               	.L__stack_usage = 13
 813 001a 7C01      		movw r14,r24
 814 001c D62F      		mov r29,r22
 815 001e C72F      		mov r28,r23
 816               	.LVL69:
 198:tmk_core/common/action.c **** #endif
 817               		.loc 1 198 0
 818 0020 FC01      		movw r30,r24
 819 0022 0581      		ldd r16,Z+5
 820 0024 0295      		swap r16
 821 0026 0F70      		andi r16,lo8(15)
 822               	.LVL70:
 201:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 823               		.loc 1 201 0
 824 0028 1281      		ldd r17,Z+2
 825 002a 1111      		cpse r17,__zero_reg__
 203:tmk_core/common/action.c ****     }
 826               		.loc 1 203 0
 827 002c 0E94 0000 		call clear_weak_mods
 828               	.LVL71:
 829               	.L68:
 209:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 830               		.loc 1 209 0
 831 0030 0E94 0000 		call is_oneshot_layer_active
 832               	.LVL72:
 833 0034 8823      		tst r24
 834 0036 01F0      		breq .L154
 209:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 835               		.loc 1 209 0 is_stmt 0 discriminator 1
 836 0038 1123      		tst r17
 837 003a 01F0      		breq .L154
 209:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 838               		.loc 1 209 0 discriminator 2
 839 003c 80E2      		ldi r24,lo8(32)
 840 003e 8D0F      		add r24,r29
 841 0040 8830      		cpi r24,lo8(8)
 842 0042 00F0      		brlo .L154
 210:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 843               		.loc 1 210 0 is_stmt 1
 844 0044 82E0      		ldi r24,lo8(2)
 845 0046 0E94 0000 		call clear_oneshot_layer_state
 846               	.LVL73:
 211:tmk_core/common/action.c ****     }
 847               		.loc 1 211 0
 848 004a 0E94 0000 		call is_oneshot_layer_active
 849               	.LVL74:
 850 004e 91E0      		ldi r25,lo8(1)
 851 0050 B82E      		mov r11,r24
 852 0052 B926      		eor r11,r25
 853               	.LVL75:
 854 0054 00C0      		rjmp .L69
 855               	.LVL76:
 856               	.L154:
 207:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 857               		.loc 1 207 0
 858 0056 B12C      		mov r11,__zero_reg__
 859               	.LVL77:
 860               	.L69:
 215:tmk_core/common/action.c ****         /* Key and Mods */
 861               		.loc 1 215 0
 862 0058 CC2E      		mov r12,r28
 863 005a C294      		swap r12
 864 005c 8FE0      		ldi r24,lo8(15)
 865 005e C822      		and r12,r24
 866 0060 D12C      		mov r13,__zero_reg__
 867 0062 FEE0      		ldi r31,14
 868 0064 CF16      		cp r12,r31
 869 0066 D104      		cpc r13,__zero_reg__
 870 0068 00F0      		brlo .+2
 871 006a 00C0      		rjmp .L70
 872 006c F601      		movw r30,r12
 873 006e E050      		subi r30,lo8(-(gs(.L72)))
 874 0070 F040      		sbci r31,hi8(-(gs(.L72)))
 875 0072 0C94 0000 		jmp __tablejump2__
 876               		.section	.progmem.gcc_sw_table.process_action,"a",@progbits
 877               		.p2align	1
 878               	.L72:
 879 0000 0000      		.word gs(.L71)
 880 0002 0000      		.word gs(.L71)
 881 0004 0000      		.word gs(.L73)
 882 0006 0000      		.word gs(.L73)
 883 0008 0000      		.word gs(.L74)
 884 000a 0000      		.word gs(.L70)
 885 000c 0000      		.word gs(.L70)
 886 000e 0000      		.word gs(.L70)
 887 0010 0000      		.word gs(.L75)
 888 0012 0000      		.word gs(.L70)
 889 0014 0000      		.word gs(.L76)
 890 0016 0000      		.word gs(.L76)
 891 0018 0000      		.word gs(.L70)
 892 001a 0000      		.word gs(.L77)
 893               		.section	.text.process_action
 894               	.L71:
 895               	.LBB76:
 220:tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 896               		.loc 1 220 0
 897 0076 8C2F      		mov r24,r28
 898 0078 807F      		andi r24,lo8(-16)
 899 007a CF70      		andi r28,lo8(15)
 900               	.LVL78:
 901 007c 8823      		tst r24
 902 007e 01F0      		breq .L79
 220:tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 903               		.loc 1 220 0 is_stmt 0 discriminator 2
 904 0080 C295      		swap r28
 905 0082 C07F      		andi r28,lo8(-16)
 906               	.L79:
 907               	.LVL79:
 222:tmk_core/common/action.c ****                     if (mods) {
 908               		.loc 1 222 0 is_stmt 1 discriminator 4
 909 0084 1123      		tst r17
 910 0086 01F0      		breq .L80
 223:tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 911               		.loc 1 223 0
 912 0088 CC23      		tst r28
 913 008a 01F4      		brne .+2
 914 008c 00C0      		rjmp .L182
 224:tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 915               		.loc 1 224 0
 916 008e 80E2      		ldi r24,lo8(32)
 917 0090 8D0F      		add r24,r29
 918 0092 8830      		cpi r24,lo8(8)
 919 0094 00F0      		brlo .L82
 224:tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 920               		.loc 1 224 0 is_stmt 0 discriminator 1
 921 0096 D111      		cpse r29,__zero_reg__
 922 0098 00C0      		rjmp .L83
 923               	.L82:
 228:tmk_core/common/action.c ****                         } else {
 924               		.loc 1 228 0 is_stmt 1
 925 009a 8C2F      		mov r24,r28
 926 009c 0E94 0000 		call add_mods
 927               	.LVL80:
 928 00a0 00C0      		rjmp .L84
 929               	.L83:
 230:tmk_core/common/action.c ****                         }
 930               		.loc 1 230 0
 931 00a2 8C2F      		mov r24,r28
 932 00a4 0E94 0000 		call add_weak_mods
 933               	.LVL81:
 934               	.L84:
 232:tmk_core/common/action.c ****                     }
 935               		.loc 1 232 0
 936 00a8 0E94 0000 		call send_keyboard_report
 937               	.LVL82:
 938 00ac 00C0      		rjmp .L182
 939               	.L80:
 236:tmk_core/common/action.c ****                     if (mods) {
 940               		.loc 1 236 0
 941 00ae 8D2F      		mov r24,r29
 942 00b0 0E94 0000 		call unregister_code
 943               	.LVL83:
 237:tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 944               		.loc 1 237 0
 945 00b4 CC23      		tst r28
 946 00b6 01F4      		brne .+2
 947 00b8 00C0      		rjmp .L70
 238:tmk_core/common/action.c ****                             del_mods(mods);
 948               		.loc 1 238 0
 949 00ba 80E2      		ldi r24,lo8(32)
 950 00bc 8D0F      		add r24,r29
 951 00be 8830      		cpi r24,lo8(8)
 952 00c0 00F0      		brlo .L86
 238:tmk_core/common/action.c ****                             del_mods(mods);
 953               		.loc 1 238 0 is_stmt 0 discriminator 1
 954 00c2 D111      		cpse r29,__zero_reg__
 955 00c4 00C0      		rjmp .L87
 956               	.L86:
 239:tmk_core/common/action.c ****                         } else {
 957               		.loc 1 239 0 is_stmt 1
 958 00c6 8C2F      		mov r24,r28
 959 00c8 0E94 0000 		call del_mods
 960               	.LVL84:
 961 00cc 00C0      		rjmp .L88
 962               	.L87:
 241:tmk_core/common/action.c ****                         }
 963               		.loc 1 241 0
 964 00ce 8C2F      		mov r24,r28
 965 00d0 0E94 0000 		call del_weak_mods
 966               	.LVL85:
 967               	.L88:
 243:tmk_core/common/action.c ****                     }
 968               		.loc 1 243 0
 969 00d4 0E94 0000 		call send_keyboard_report
 970               	.LVL86:
 971 00d8 00C0      		rjmp .L70
 972               	.LVL87:
 973               	.L73:
 974               	.LBE76:
 975               	.LBB77:
 252:tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 976               		.loc 1 252 0
 977 00da 8C2F      		mov r24,r28
 978 00dc 807F      		andi r24,lo8(-16)
 979 00de CF70      		andi r28,lo8(15)
 980               	.LVL88:
 981 00e0 8032      		cpi r24,lo8(32)
 982 00e2 01F0      		breq .L90
 252:tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 983               		.loc 1 252 0 is_stmt 0 discriminator 2
 984 00e4 C295      		swap r28
 985 00e6 C07F      		andi r28,lo8(-16)
 986               	.L90:
 987               	.LVL89:
 254:tmk_core/common/action.c ****     #ifndef NO_ACTION_ONESHOT
 988               		.loc 1 254 0 is_stmt 1 discriminator 4
 989 00e8 DD23      		tst r29
 990 00ea 01F0      		breq .L92
 991 00ec D130      		cpi r29,lo8(1)
 992 00ee 01F0      		breq .L93
 993 00f0 00C0      		rjmp .L192
 994               	.L92:
 258:tmk_core/common/action.c ****                             if (tap_count == 0) {
 995               		.loc 1 258 0
 996 00f2 1123      		tst r17
 997 00f4 01F0      		breq .L94
 259:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 998               		.loc 1 259 0
 999 00f6 0023      		tst r16
 1000 00f8 01F0      		breq .L96
 262:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 1001               		.loc 1 262 0
 1002 00fa 0130      		cpi r16,lo8(1)
 1003 00fc 01F4      		brne .L96
 264:tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1004               		.loc 1 264 0
 1005 00fe 0E94 0000 		call get_oneshot_mods
 1006               	.LVL90:
 1007 0102 8C2B      		or r24,r28
 1008 0104 0E94 0000 		call set_oneshot_mods
 1009               	.LVL91:
 1010 0108 00C0      		rjmp .L70
 1011               	.L96:
 273:tmk_core/common/action.c ****                             }
 1012               		.loc 1 273 0
 1013 010a 0E94 0000 		call get_oneshot_mods
 1014               	.LVL92:
 1015 010e 8C2B      		or r24,r28
 1016 0110 00C0      		rjmp .L183
 1017               	.L94:
 276:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 1018               		.loc 1 276 0
 1019 0112 0023      		tst r16
 1020 0114 01F0      		breq .L191
 279:tmk_core/common/action.c ****                                 // Retain Oneshot mods
 1021               		.loc 1 279 0
 1022 0116 0130      		cpi r16,lo8(1)
 1023 0118 01F4      		brne .+2
 1024 011a 00C0      		rjmp .L70
 1025               	.L191:
 291:tmk_core/common/action.c ****                                 unregister_mods(mods);
 1026               		.loc 1 291 0
 1027 011c 0E94 0000 		call clear_oneshot_mods
 1028               	.LVL93:
 1029 0120 00C0      		rjmp .L103
 1030               	.L93:
 298:tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 1031               		.loc 1 298 0
 1032 0122 1123      		tst r17
 1033 0124 01F0      		breq .L99
 299:tmk_core/common/action.c ****                                 register_mods(mods);
 1034               		.loc 1 299 0
 1035 0126 0630      		cpi r16,lo8(6)
 1036 0128 00F0      		brlo .+2
 1037 012a 00C0      		rjmp .L70
 1038 012c 00C0      		rjmp .L185
 1039               	.L99:
 303:tmk_core/common/action.c ****                                 unregister_mods(mods);
 1040               		.loc 1 303 0
 1041 012e 0530      		cpi r16,lo8(5)
 1042 0130 00F0      		brlo .+2
 1043 0132 00C0      		rjmp .L70
 1044 0134 00C0      		rjmp .L103
 1045               	.L192:
 309:tmk_core/common/action.c ****                             if (tap_count > 0) {
 1046               		.loc 1 309 0
 1047 0136 1123      		tst r17
 1048 0138 01F0      		breq .L100
 310:tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 1049               		.loc 1 310 0
 1050 013a 0023      		tst r16
 1051 013c 01F0      		breq .L185
 312:tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 1052               		.loc 1 312 0
 1053 013e F701      		movw r30,r14
 1054 0140 8581      		ldd r24,Z+5
 1055 0142 80FF      		sbrs r24,0
 1056 0144 00C0      		rjmp .L182
 315:tmk_core/common/action.c ****                                     register_mods(mods);
 1057               		.loc 1 315 0
 1058 0146 8F70      		andi r24,lo8(15)
 1059 0148 8583      		std Z+5,r24
 1060               	.L185:
 316:tmk_core/common/action.c ****                                 } else
 1061               		.loc 1 316 0
 1062 014a 8C2F      		mov r24,r28
 1063               	.LVL94:
 1064               	.L183:
 1065 014c 0E94 0000 		call register_mods
 1066               	.LVL95:
 1067 0150 00C0      		rjmp .L70
 1068               	.LVL96:
 1069               	.L100:
 328:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 1070               		.loc 1 328 0
 1071 0152 0111      		cpse r16,__zero_reg__
 1072 0154 00C0      		rjmp .L139
 1073               	.L103:
 333:tmk_core/common/action.c ****                             }
 1074               		.loc 1 333 0
 1075 0156 8C2F      		mov r24,r28
 1076 0158 00C0      		rjmp .L184
 1077               	.LVL97:
 1078               	.L74:
 1079               	.LBE77:
 344:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1080               		.loc 1 344 0
 1081 015a 8C2F      		mov r24,r28
 1082 015c 8695      		lsr r24
 1083 015e 8695      		lsr r24
 1084 0160 8370      		andi r24,lo8(3)
 1085 0162 90E0      		ldi r25,0
 1086 0164 0097      		sbiw r24,0
 1087 0166 01F0      		breq .L104
 1088 0168 0197      		sbiw r24,1
 1089 016a 01F0      		breq .L105
 1090 016c 00C0      		rjmp .L70
 1091               	.L104:
 346:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1092               		.loc 1 346 0
 1093 016e 1123      		tst r17
 1094 0170 01F0      		breq .L106
 347:tmk_core/common/action.c ****                     } else {
 1095               		.loc 1 347 0
 1096 0172 8D2F      		mov r24,r29
 1097 0174 9C2F      		mov r25,r28
 1098 0176 9370      		andi r25,lo8(3)
 1099 0178 00C0      		rjmp .L189
 1100               	.L106:
 349:tmk_core/common/action.c ****                     }
 1101               		.loc 1 349 0
 1102 017a 80E0      		ldi r24,0
 1103 017c 90E0      		ldi r25,0
 1104               	.L189:
 1105 017e 0E94 0000 		call host_system_send
 1106               	.LVL98:
 1107 0182 00C0      		rjmp .L147
 1108               	.L105:
 353:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1109               		.loc 1 353 0
 1110 0184 1123      		tst r17
 1111 0186 01F0      		breq .L108
 354:tmk_core/common/action.c ****                     } else {
 1112               		.loc 1 354 0
 1113 0188 8D2F      		mov r24,r29
 1114 018a 9C2F      		mov r25,r28
 1115 018c 9370      		andi r25,lo8(3)
 1116 018e 00C0      		rjmp .L190
 1117               	.L108:
 356:tmk_core/common/action.c ****                     }
 1118               		.loc 1 356 0
 1119 0190 80E0      		ldi r24,0
 1120 0192 90E0      		ldi r25,0
 1121               	.L190:
 1122 0194 0E94 0000 		call host_consumer_send
 1123               	.LVL99:
 1124 0198 00C0      		rjmp .L147
 1125               	.L75:
 402:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1126               		.loc 1 402 0
 1127 019a 8C2F      		mov r24,r28
 1128 019c 8370      		andi r24,lo8(3)
 1129 019e 01F0      		breq .+2
 1130 01a0 00C0      		rjmp .L109
 404:tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 1131               		.loc 1 404 0
 1132 01a2 1111      		cpse r17,__zero_reg__
 1133 01a4 00C0      		rjmp .L148
 1134               	.LVL100:
 1135               	.LBB78:
 405:tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1136               		.loc 1 405 0
 1137 01a6 8D2F      		mov r24,r29
 1138 01a8 8295      		swap r24
 1139 01aa 8695      		lsr r24
 1140 01ac 8770      		andi r24,lo8(7)
 1141 01ae 880F      		lsl r24
 1142 01b0 880F      		lsl r24
 406:tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1143               		.loc 1 406 0
 1144 01b2 9D2F      		mov r25,r29
 1145 01b4 9F70      		andi r25,lo8(15)
 1146 01b6 492E      		mov r4,r25
 1147 01b8 512C      		mov r5,__zero_reg__
 1148 01ba 612C      		mov r6,__zero_reg__
 1149 01bc 712C      		mov r7,__zero_reg__
 1150 01be 082E      		mov r0,r24
 1151 01c0 00C0      		rjmp 2f
 1152               		1:
 1153 01c2 440C      		lsl r4
 1154 01c4 551C      		rol r5
 1155 01c6 661C      		rol r6
 1156 01c8 771C      		rol r7
 1157               		2:
 1158 01ca 0A94      		dec r0
 1159 01cc 02F4      		brpl 1b
 1160               	.LVL101:
 407:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1161               		.loc 1 407 0
 1162 01ce D4FF      		sbrs r29,4
 1163 01d0 00C0      		rjmp .L155
 407:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1164               		.loc 1 407 0 is_stmt 0 discriminator 1
 1165 01d2 4FE0      		ldi r20,lo8(15)
 1166 01d4 50E0      		ldi r21,0
 1167 01d6 60E0      		ldi r22,0
 1168 01d8 70E0      		ldi r23,0
 1169 01da 8A01      		movw r16,r20
 1170 01dc 9B01      		movw r18,r22
 1171               	.LVL102:
 1172 01de 00C0      		rjmp 2f
 1173               		1:
 1174 01e0 000F      		lsl r16
 1175 01e2 111F      		rol r17
 1176 01e4 221F      		rol r18
 1177 01e6 331F      		rol r19
 1178               		2:
 1179 01e8 8A95      		dec r24
 1180 01ea 02F4      		brpl 1b
 1181 01ec C901      		movw r24,r18
 1182 01ee B801      		movw r22,r16
 1183 01f0 6095      		com r22
 1184 01f2 7095      		com r23
 1185 01f4 8095      		com r24
 1186 01f6 9095      		com r25
 1187 01f8 00C0      		rjmp .L111
 1188               	.LVL103:
 1189               	.L155:
 407:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1190               		.loc 1 407 0
 1191 01fa 60E0      		ldi r22,0
 1192 01fc 70E0      		ldi r23,0
 1193 01fe CB01      		movw r24,r22
 1194               	.LVL104:
 1195               	.L111:
 408:tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1196               		.loc 1 408 0 is_stmt 1 discriminator 4
 1197 0200 C695      		lsr r28
 1198 0202 C695      		lsr r28
 1199               	.LVL105:
 1200 0204 C370      		andi r28,lo8(3)
 1201 0206 D0E0      		ldi r29,0
 1202 0208 C230      		cpi r28,2
 1203 020a D105      		cpc r29,__zero_reg__
 1204 020c 01F0      		breq .L113
 1205 020e C330      		cpi r28,3
 1206 0210 D105      		cpc r29,__zero_reg__
 1207 0212 01F0      		breq .L114
 1208 0214 6429      		or r22,r4
 1209 0216 7529      		or r23,r5
 1210 0218 8629      		or r24,r6
 1211 021a 9729      		or r25,r7
 1212               	.LVL106:
 1213 021c 2197      		sbiw r28,1
 1214 021e 01F0      		breq .L187
 409:tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 1215               		.loc 1 409 0 discriminator 4
 1216 0220 0E94 0000 		call default_layer_and
 1217               	.LVL107:
 1218 0224 00C0      		rjmp .L148
 1219               	.LVL108:
 1220               	.L113:
 411:tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 1221               		.loc 1 411 0
 1222 0226 6429      		or r22,r4
 1223 0228 7529      		or r23,r5
 1224 022a 8629      		or r24,r6
 1225 022c 9729      		or r25,r7
 1226               	.LVL109:
 1227 022e 0E94 0000 		call default_layer_xor
 1228               	.LVL110:
 1229 0232 00C0      		rjmp .L148
 1230               	.LVL111:
 1231               	.L114:
 412:tmk_core/common/action.c ****                     }
 1232               		.loc 1 412 0
 1233 0234 0E94 0000 		call default_layer_and
 1234               	.LVL112:
 1235 0238 C301      		movw r24,r6
 1236 023a B201      		movw r22,r4
 1237               	.L187:
 1238 023c 0E94 0000 		call default_layer_or
 1239               	.LVL113:
 1240 0240 00C0      		rjmp .L148
 1241               	.LVL114:
 1242               	.L109:
 1243               	.LBE78:
 417:tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1244               		.loc 1 417 0
 1245 0242 1123      		tst r17
 1246 0244 01F0      		breq .L116
 417:tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1247               		.loc 1 417 0 is_stmt 0 discriminator 1
 1248 0246 8C2F      		mov r24,r28
 1249 0248 8170      		andi r24,lo8(1)
 1250 024a 00C0      		rjmp .L117
 1251               	.L116:
 417:tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1252               		.loc 1 417 0 discriminator 2
 1253 024c 8695      		lsr r24
 1254               	.L117:
 417:tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1255               		.loc 1 417 0 discriminator 4
 1256 024e 8823      		tst r24
 1257 0250 01F4      		brne .+2
 1258 0252 00C0      		rjmp .L148
 1259               	.LVL115:
 1260               	.LBB79:
 419:tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1261               		.loc 1 419 0 is_stmt 1
 1262 0254 8D2F      		mov r24,r29
 1263 0256 8295      		swap r24
 1264 0258 8695      		lsr r24
 1265 025a 8770      		andi r24,lo8(7)
 1266 025c 880F      		lsl r24
 1267 025e 880F      		lsl r24
 420:tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1268               		.loc 1 420 0
 1269 0260 9D2F      		mov r25,r29
 1270 0262 9F70      		andi r25,lo8(15)
 1271 0264 492E      		mov r4,r25
 1272 0266 512C      		mov r5,__zero_reg__
 1273 0268 612C      		mov r6,__zero_reg__
 1274 026a 712C      		mov r7,__zero_reg__
 1275 026c 082E      		mov r0,r24
 1276 026e 00C0      		rjmp 2f
 1277               		1:
 1278 0270 440C      		lsl r4
 1279 0272 551C      		rol r5
 1280 0274 661C      		rol r6
 1281 0276 771C      		rol r7
 1282               		2:
 1283 0278 0A94      		dec r0
 1284 027a 02F4      		brpl 1b
 1285               	.LVL116:
 421:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1286               		.loc 1 421 0
 1287 027c D4FF      		sbrs r29,4
 1288 027e 00C0      		rjmp .L156
 421:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1289               		.loc 1 421 0 is_stmt 0 discriminator 1
 1290 0280 4FE0      		ldi r20,lo8(15)
 1291 0282 50E0      		ldi r21,0
 1292 0284 60E0      		ldi r22,0
 1293 0286 70E0      		ldi r23,0
 1294 0288 8A01      		movw r16,r20
 1295 028a 9B01      		movw r18,r22
 1296               	.LVL117:
 1297 028c 00C0      		rjmp 2f
 1298               		1:
 1299 028e 000F      		lsl r16
 1300 0290 111F      		rol r17
 1301 0292 221F      		rol r18
 1302 0294 331F      		rol r19
 1303               		2:
 1304 0296 8A95      		dec r24
 1305 0298 02F4      		brpl 1b
 1306 029a C901      		movw r24,r18
 1307 029c B801      		movw r22,r16
 1308 029e 6095      		com r22
 1309 02a0 7095      		com r23
 1310 02a2 8095      		com r24
 1311 02a4 9095      		com r25
 1312 02a6 00C0      		rjmp .L118
 1313               	.LVL118:
 1314               	.L156:
 421:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1315               		.loc 1 421 0
 1316 02a8 60E0      		ldi r22,0
 1317 02aa 70E0      		ldi r23,0
 1318 02ac CB01      		movw r24,r22
 1319               	.LVL119:
 1320               	.L118:
 422:tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1321               		.loc 1 422 0 is_stmt 1 discriminator 4
 1322 02ae C695      		lsr r28
 1323 02b0 C695      		lsr r28
 1324               	.LVL120:
 1325 02b2 C370      		andi r28,lo8(3)
 1326 02b4 2C2F      		mov r18,r28
 1327 02b6 30E0      		ldi r19,0
 1328 02b8 2230      		cpi r18,2
 1329 02ba 3105      		cpc r19,__zero_reg__
 1330 02bc 01F0      		breq .L120
 1331 02be 2330      		cpi r18,3
 1332 02c0 3105      		cpc r19,__zero_reg__
 1333 02c2 01F0      		breq .L121
 1334 02c4 6429      		or r22,r4
 1335 02c6 7529      		or r23,r5
 1336 02c8 8629      		or r24,r6
 1337 02ca 9729      		or r25,r7
 1338               	.LVL121:
 1339 02cc 2130      		cpi r18,1
 1340 02ce 3105      		cpc r19,__zero_reg__
 1341 02d0 01F0      		breq .L186
 423:tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 1342               		.loc 1 423 0 discriminator 4
 1343 02d2 0E94 0000 		call layer_and
 1344               	.LVL122:
 1345 02d6 00C0      		rjmp .L148
 1346               	.LVL123:
 1347               	.L120:
 425:tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 1348               		.loc 1 425 0
 1349 02d8 6429      		or r22,r4
 1350 02da 7529      		or r23,r5
 1351 02dc 8629      		or r24,r6
 1352 02de 9729      		or r25,r7
 1353               	.LVL124:
 1354 02e0 0E94 0000 		call layer_xor
 1355               	.LVL125:
 1356 02e4 00C0      		rjmp .L148
 1357               	.LVL126:
 1358               	.L121:
 426:tmk_core/common/action.c ****                     }
 1359               		.loc 1 426 0
 1360 02e6 0E94 0000 		call layer_and
 1361               	.LVL127:
 1362 02ea C301      		movw r24,r6
 1363 02ec B201      		movw r22,r4
 1364               	.L186:
 1365 02ee 0E94 0000 		call layer_or
 1366               	.LVL128:
 1367 02f2 00C0      		rjmp .L148
 1368               	.LVL129:
 1369               	.L76:
 1370               	.LBE79:
 434:tmk_core/common/action.c ****                 case 0xe0 ... 0xef:
 1371               		.loc 1 434 0
 1372 02f4 8D2F      		mov r24,r29
 1373 02f6 90E0      		ldi r25,0
 1374 02f8 FC01      		movw r30,r24
 1375 02fa E05E      		subi r30,-32
 1376 02fc F109      		sbc r31,__zero_reg__
 1377 02fe E531      		cpi r30,21
 1378 0300 F105      		cpc r31,__zero_reg__
 1379 0302 00F0      		brlo .+2
 1380 0304 00C0      		rjmp .L123
 1381 0306 E050      		subi r30,lo8(-(gs(.L125)))
 1382 0308 F040      		sbci r31,hi8(-(gs(.L125)))
 1383 030a 0C94 0000 		jmp __tablejump2__
 1384               		.section	.progmem.gcc_sw_table.process_action
 1385               		.p2align	1
 1386               	.L125:
 1387 001c 0000      		.word gs(.L124)
 1388 001e 0000      		.word gs(.L124)
 1389 0020 0000      		.word gs(.L124)
 1390 0022 0000      		.word gs(.L124)
 1391 0024 0000      		.word gs(.L124)
 1392 0026 0000      		.word gs(.L124)
 1393 0028 0000      		.word gs(.L124)
 1394 002a 0000      		.word gs(.L124)
 1395 002c 0000      		.word gs(.L124)
 1396 002e 0000      		.word gs(.L124)
 1397 0030 0000      		.word gs(.L124)
 1398 0032 0000      		.word gs(.L124)
 1399 0034 0000      		.word gs(.L124)
 1400 0036 0000      		.word gs(.L124)
 1401 0038 0000      		.word gs(.L124)
 1402 003a 0000      		.word gs(.L124)
 1403 003c 0000      		.word gs(.L126)
 1404 003e 0000      		.word gs(.L127)
 1405 0040 0000      		.word gs(.L128)
 1406 0042 0000      		.word gs(.L129)
 1407 0044 0000      		.word gs(.L130)
 1408               		.section	.text.process_action
 1409               	.L124:
 1410 030e DF70      		andi r29,lo8(15)
 1411               	.LVL130:
 1412 0310 8C2F      		mov r24,r28
 1413 0312 8F71      		andi r24,lo8(31)
 437:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1414               		.loc 1 437 0
 1415 0314 1123      		tst r17
 1416 0316 01F0      		breq .L131
 438:tmk_core/common/action.c ****                         register_mods(action.layer_tap.code & 0x0f);
 1417               		.loc 1 438 0
 1418 0318 0E94 0000 		call layer_on
 1419               	.LVL131:
 439:tmk_core/common/action.c ****                     } else {
 1420               		.loc 1 439 0
 1421 031c 8D2F      		mov r24,r29
 1422 031e 00C0      		rjmp .L183
 1423               	.L131:
 441:tmk_core/common/action.c ****                         unregister_mods(action.layer_tap.code & 0x0f);
 1424               		.loc 1 441 0
 1425 0320 0E94 0000 		call layer_off
 1426               	.LVL132:
 442:tmk_core/common/action.c ****                     }
 1427               		.loc 1 442 0
 1428 0324 8D2F      		mov r24,r29
 1429               	.LVL133:
 1430               	.L184:
 1431 0326 0E94 0000 		call unregister_mods
 1432               	.LVL134:
 1433 032a 00C0      		rjmp .L70
 1434               	.L126:
 447:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1435               		.loc 1 447 0
 1436 032c 1123      		tst r17
 1437 032e 01F0      		breq .L132
 448:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1438               		.loc 1 448 0
 1439 0330 0530      		cpi r16,lo8(5)
 1440 0332 00F0      		brlo .+2
 1441 0334 00C0      		rjmp .L70
 1442               	.L133:
 449:tmk_core/common/action.c ****                         }
 1443               		.loc 1 449 0
 1444 0336 8C2F      		mov r24,r28
 1445 0338 8F71      		andi r24,lo8(31)
 1446 033a 0E94 0000 		call layer_invert
 1447               	.LVL135:
 1448 033e 00C0      		rjmp .L70
 1449               	.L132:
 452:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1450               		.loc 1 452 0
 1451 0340 0630      		cpi r16,lo8(6)
 1452 0342 00F0      		brlo .+2
 1453 0344 00C0      		rjmp .L70
 1454 0346 00C0      		rjmp .L133
 1455               	.L127:
 458:tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 1456               		.loc 1 458 0
 1457 0348 1123      		tst r17
 1458 034a 01F0      		breq .L134
 1459               	.L135:
 458:tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 1460               		.loc 1 458 0 is_stmt 0 discriminator 1
 1461 034c 8C2F      		mov r24,r28
 1462 034e 8F71      		andi r24,lo8(31)
 1463 0350 0E94 0000 		call layer_on
 1464               	.LVL136:
 1465 0354 00C0      		rjmp .L70
 1466               	.L128:
 462:tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 1467               		.loc 1 462 0 is_stmt 1
 1468 0356 1123      		tst r17
 1469 0358 01F0      		breq .L135
 1470               	.L134:
 459:tmk_core/common/action.c ****                     break;
 1471               		.loc 1 459 0
 1472 035a 8C2F      		mov r24,r28
 1473 035c 8F71      		andi r24,lo8(31)
 1474 035e 0E94 0000 		call layer_off
 1475               	.LVL137:
 1476 0362 00C0      		rjmp .L70
 1477               	.L129:
 466:tmk_core/common/action.c ****                                     layer_clear();
 1478               		.loc 1 466 0
 1479 0364 1123      		tst r17
 1480 0366 01F0      		breq .L136
 466:tmk_core/common/action.c ****                                     layer_clear();
 1481               		.loc 1 466 0 is_stmt 0 discriminator 1
 1482 0368 8C2F      		mov r24,r28
 1483 036a 8F71      		andi r24,lo8(31)
 1484 036c 0E94 0000 		call layer_move
 1485               	.LVL138:
 1486 0370 00C0      		rjmp .L70
 1487               	.L136:
 467:tmk_core/common/action.c ****                     break;
 1488               		.loc 1 467 0 is_stmt 1
 1489 0372 0E94 0000 		call layer_clear
 1490               	.LVL139:
 1491 0376 00C0      		rjmp .L70
 1492               	.L130:
 495:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1493               		.loc 1 495 0
 1494 0378 1123      		tst r17
 1495 037a 01F0      		breq .L137
 496:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1496               		.loc 1 496 0
 1497 037c CF71      		andi r28,lo8(31)
 1498               	.LVL140:
 1499 037e 8C2F      		mov r24,r28
 1500 0380 0E94 0000 		call layer_on
 1501               	.LVL141:
 497:tmk_core/common/action.c ****                     } else {
 1502               		.loc 1 497 0
 1503 0384 63E0      		ldi r22,lo8(3)
 1504 0386 8C2F      		mov r24,r28
 1505 0388 0E94 0000 		call set_oneshot_layer
 1506               	.LVL142:
 1507 038c 00C0      		rjmp .L70
 1508               	.LVL143:
 1509               	.L137:
 499:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1510               		.loc 1 499 0
 1511 038e 81E0      		ldi r24,lo8(1)
 1512 0390 0E94 0000 		call clear_oneshot_layer_state
 1513               	.LVL144:
 500:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1514               		.loc 1 500 0
 1515 0394 0230      		cpi r16,lo8(2)
 1516 0396 00F4      		brsh .+2
 1517 0398 00C0      		rjmp .L70
 501:tmk_core/common/action.c ****                         }
 1518               		.loc 1 501 0
 1519 039a 82E0      		ldi r24,lo8(2)
 1520 039c 0E94 0000 		call clear_oneshot_layer_state
 1521               	.LVL145:
 1522 03a0 00C0      		rjmp .L70
 1523               	.L123:
 509:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1524               		.loc 1 509 0
 1525 03a2 1123      		tst r17
 1526 03a4 01F0      		breq .L138
 510:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1527               		.loc 1 510 0
 1528 03a6 0023      		tst r16
 1529 03a8 01F0      		breq .L135
 1530               	.L182:
 512:tmk_core/common/action.c ****                         } else {
 1531               		.loc 1 512 0
 1532 03aa 8D2F      		mov r24,r29
 1533 03ac 0E94 0000 		call register_code
 1534               	.LVL146:
 1535 03b0 00C0      		rjmp .L70
 1536               	.L138:
 518:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1537               		.loc 1 518 0
 1538 03b2 0023      		tst r16
 1539 03b4 01F0      		breq .L134
 520:tmk_core/common/action.c ****                                 wait_ms(80);
 1540               		.loc 1 520 0
 1541 03b6 D933      		cpi r29,lo8(57)
 1542 03b8 01F4      		brne .L139
 1543               	.LVL147:
 1544               	.LBB80:
 1545               	.LBB81:
 1546               		.loc 3 187 0
 1547 03ba 1FEF      		ldi r17,lo8(255999)
 1548 03bc 27EE      		ldi r18,hi8(255999)
 1549 03be 33E0      		ldi r19,hlo8(255999)
 1550 03c0 1150      	1:	subi r17,1
 1551 03c2 2040      		sbci r18,0
 1552 03c4 3040      		sbci r19,0
 1553 03c6 01F4      		brne 1b
 1554               	.LVL148:
 1555 03c8 00C0      		rjmp .
 1556 03ca 0000      		nop
 1557               	.LVL149:
 1558               	.L139:
 1559               	.LBE81:
 1560               	.LBE80:
 523:tmk_core/common/action.c ****                         } else {
 1561               		.loc 1 523 0
 1562 03cc 8D2F      		mov r24,r29
 1563 03ce 0E94 0000 		call unregister_code
 1564               	.LVL150:
 1565 03d2 00C0      		rjmp .L70
 1566               	.LVL151:
 1567               	.L77:
 542:tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 1568               		.loc 1 542 0
 1569 03d4 1111      		cpse r17,__zero_reg__
 1570 03d6 00C0      		rjmp .L147
 543:tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 1571               		.loc 1 543 0
 1572 03d8 CF70      		andi r28,lo8(15)
 1573               	.LVL152:
 1574 03da 2C2F      		mov r18,r28
 1575 03dc 30E0      		ldi r19,0
 1576 03de 2230      		cpi r18,2
 1577 03e0 3105      		cpc r19,__zero_reg__
 1578 03e2 01F0      		breq .L140
 1579 03e4 04F4      		brge .L141
 1580 03e6 2115      		cp r18,__zero_reg__
 1581 03e8 3105      		cpc r19,__zero_reg__
 1582 03ea 01F0      		breq .L142
 1583 03ec 2130      		cpi r18,1
 1584 03ee 3105      		cpc r19,__zero_reg__
 1585 03f0 01F4      		brne .L70
 548:tmk_core/common/action.c ****                         break;
 1586               		.loc 1 548 0
 1587 03f2 0E94 0000 		call backlight_decrease
 1588               	.LVL153:
 549:tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 1589               		.loc 1 549 0
 1590 03f6 00C0      		rjmp .L147
 1591               	.L141:
 543:tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 1592               		.loc 1 543 0
 1593 03f8 2430      		cpi r18,4
 1594 03fa 3105      		cpc r19,__zero_reg__
 1595 03fc 01F0      		breq .L144
 1596 03fe 04F0      		brlt .L145
 1597 0400 2530      		cpi r18,5
 1598 0402 3105      		cpc r19,__zero_reg__
 1599 0404 01F4      		brne .L70
 560:tmk_core/common/action.c ****                         break;
 1600               		.loc 1 560 0
 1601 0406 80E0      		ldi r24,0
 1602 0408 00C0      		rjmp .L188
 1603               	.L142:
 545:tmk_core/common/action.c ****                         break;
 1604               		.loc 1 545 0
 1605 040a 0E94 0000 		call backlight_increase
 1606               	.LVL154:
 546:tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 1607               		.loc 1 546 0
 1608 040e 00C0      		rjmp .L147
 1609               	.L140:
 551:tmk_core/common/action.c ****                         break;
 1610               		.loc 1 551 0
 1611 0410 0E94 0000 		call backlight_toggle
 1612               	.LVL155:
 552:tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 1613               		.loc 1 552 0
 1614 0414 00C0      		rjmp .L147
 1615               	.L145:
 554:tmk_core/common/action.c ****                         break;
 1616               		.loc 1 554 0
 1617 0416 0E94 0000 		call backlight_step
 1618               	.LVL156:
 555:tmk_core/common/action.c ****                     case BACKLIGHT_ON:
 1619               		.loc 1 555 0
 1620 041a 00C0      		rjmp .L147
 1621               	.L144:
 557:tmk_core/common/action.c ****                         break;
 1622               		.loc 1 557 0
 1623 041c 84E0      		ldi r24,lo8(4)
 1624               	.L188:
 560:tmk_core/common/action.c ****                         break;
 1625               		.loc 1 560 0
 1626 041e 0E94 0000 		call backlight_level
 1627               	.LVL157:
 561:tmk_core/common/action.c ****                 }
 1628               		.loc 1 561 0
 1629 0422 00C0      		rjmp .L147
 1630               	.LVL158:
 1631               	.L70:
 641:tmk_core/common/action.c ****         case ACT_LAYER:
 1632               		.loc 1 641 0
 1633 0424 88E0      		ldi r24,8
 1634 0426 C816      		cp r12,r24
 1635 0428 D104      		cpc r13,__zero_reg__
 1636 042a 01F0      		breq .L148
 1637 042c 04F0      		brlt .L147
 1638 042e EAE0      		ldi r30,10
 1639 0430 CE1A      		sub r12,r30
 1640 0432 D108      		sbc r13,__zero_reg__
 1641 0434 F2E0      		ldi r31,2
 1642 0436 CF16      		cp r12,r31
 1643 0438 D104      		cpc r13,__zero_reg__
 1644 043a 00F4      		brsh .L147
 1645               	.LVL159:
 1646               	.L148:
 647:tmk_core/common/action.c ****             break;
 1647               		.loc 1 647 0
 1648 043c 0E94 0000 		call host_keyboard_leds
 1649               	.LVL160:
 1650 0440 0E94 0000 		call led_set
 1651               	.LVL161:
 1652               	.L147:
 684:tmk_core/common/action.c ****         record->event.pressed = false;
 1653               		.loc 1 684 0
 1654 0444 BB20      		tst r11
 1655 0446 01F0      		breq .L67
 684:tmk_core/common/action.c ****         record->event.pressed = false;
 1656               		.loc 1 684 0 is_stmt 0 discriminator 1
 1657 0448 0E94 0000 		call get_oneshot_layer_state
 1658               	.LVL162:
 1659 044c 80FD      		sbrc r24,0
 1660 044e 00C0      		rjmp .L67
 685:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1661               		.loc 1 685 0 is_stmt 1
 1662 0450 F701      		movw r30,r14
 1663 0452 1282      		std Z+2,__zero_reg__
 686:tmk_core/common/action.c ****         process_record(record);
 1664               		.loc 1 686 0
 1665 0454 0E94 0000 		call get_oneshot_layer
 1666               	.LVL163:
 1667 0458 0E94 0000 		call layer_on
 1668               	.LVL164:
 687:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 1669               		.loc 1 687 0
 1670 045c C701      		movw r24,r14
 1671 045e 0E94 0000 		call process_record
 1672               	.LVL165:
 688:tmk_core/common/action.c ****     }
 1673               		.loc 1 688 0
 1674 0462 0E94 0000 		call get_oneshot_layer
 1675               	.LVL166:
 1676               	/* epilogue start */
 691:tmk_core/common/action.c **** 
 1677               		.loc 1 691 0
 1678 0466 DF91      		pop r29
 1679               	.LVL167:
 1680 0468 CF91      		pop r28
 1681 046a 1F91      		pop r17
 1682 046c 0F91      		pop r16
 1683 046e FF90      		pop r15
 1684 0470 EF90      		pop r14
 1685               	.LVL168:
 1686 0472 DF90      		pop r13
 1687 0474 CF90      		pop r12
 1688 0476 BF90      		pop r11
 1689               	.LVL169:
 1690 0478 7F90      		pop r7
 1691 047a 6F90      		pop r6
 1692 047c 5F90      		pop r5
 1693 047e 4F90      		pop r4
 688:tmk_core/common/action.c ****     }
 1694               		.loc 1 688 0
 1695 0480 0C94 0000 		jmp layer_off
 1696               	.LVL170:
 1697               	.L67:
 1698               	/* epilogue start */
 691:tmk_core/common/action.c **** 
 1699               		.loc 1 691 0
 1700 0484 DF91      		pop r29
 1701               	.LVL171:
 1702 0486 CF91      		pop r28
 1703 0488 1F91      		pop r17
 1704 048a 0F91      		pop r16
 1705 048c FF90      		pop r15
 1706 048e EF90      		pop r14
 1707               	.LVL172:
 1708 0490 DF90      		pop r13
 1709 0492 CF90      		pop r12
 1710 0494 BF90      		pop r11
 1711               	.LVL173:
 1712 0496 7F90      		pop r7
 1713 0498 6F90      		pop r6
 1714 049a 5F90      		pop r5
 1715 049c 4F90      		pop r4
 1716 049e 0895      		ret
 1717               		.cfi_endproc
 1718               	.LFE18:
 1720               		.section	.text.process_record,"ax",@progbits
 1721               	.global	process_record
 1723               	process_record:
 1724               	.LFB17:
 173:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 1725               		.loc 1 173 0
 1726               		.cfi_startproc
 1727               	.LVL174:
 1728 0000 0F93      		push r16
 1729               	.LCFI17:
 1730               		.cfi_def_cfa_offset 3
 1731               		.cfi_offset 16, -2
 1732 0002 1F93      		push r17
 1733               	.LCFI18:
 1734               		.cfi_def_cfa_offset 4
 1735               		.cfi_offset 17, -3
 1736 0004 CF93      		push r28
 1737               	.LCFI19:
 1738               		.cfi_def_cfa_offset 5
 1739               		.cfi_offset 28, -4
 1740 0006 DF93      		push r29
 1741               	.LCFI20:
 1742               		.cfi_def_cfa_offset 6
 1743               		.cfi_offset 29, -5
 1744               	/* prologue: function */
 1745               	/* frame size = 0 */
 1746               	/* stack size = 4 */
 1747               	.L__stack_usage = 4
 1748 0008 EC01      		movw r28,r24
 1749 000a 8881      		ld r24,Y
 1750               	.LVL175:
 1751 000c 9981      		ldd r25,Y+1
 1752               	.LBB84:
 1753               	.LBB85:
 1754               		.file 4 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** 
  25:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  26:tmk_core/common/keyboard.h **** extern "C" {
  27:tmk_core/common/keyboard.h **** #endif
  28:tmk_core/common/keyboard.h **** 
  29:tmk_core/common/keyboard.h **** /* key matrix position */
  30:tmk_core/common/keyboard.h **** typedef struct {
  31:tmk_core/common/keyboard.h ****     uint8_t col;
  32:tmk_core/common/keyboard.h ****     uint8_t row;
  33:tmk_core/common/keyboard.h **** } keypos_t;
  34:tmk_core/common/keyboard.h **** 
  35:tmk_core/common/keyboard.h **** /* key event */
  36:tmk_core/common/keyboard.h **** typedef struct {
  37:tmk_core/common/keyboard.h ****     keypos_t key;
  38:tmk_core/common/keyboard.h ****     bool     pressed;
  39:tmk_core/common/keyboard.h ****     uint16_t time;
  40:tmk_core/common/keyboard.h **** } keyevent_t;
  41:tmk_core/common/keyboard.h **** 
  42:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  43:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb)       ((keya).row == (keyb).row && (keya).col == (keyb).col)
  44:tmk_core/common/keyboard.h **** 
  45:tmk_core/common/keyboard.h **** /* Rules for No Event:
  46:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  47:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  48:tmk_core/common/keyboard.h ****  */
  49:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1755               		.loc 4 49 0
 1756 000e 2B81      		ldd r18,Y+3
 1757 0010 3C81      		ldd r19,Y+4
 1758 0012 232B      		or r18,r19
 1759 0014 01F0      		breq .L193
 1760 0016 9F3F      		cpi r25,lo8(-1)
 1761 0018 01F4      		brne .L195
 1762 001a 8F3F      		cpi r24,lo8(-1)
 1763 001c 01F0      		breq .L193
 1764               	.L195:
 1765               	.LBE85:
 1766               	.LBE84:
 176:tmk_core/common/action.c ****         return;
 1767               		.loc 1 176 0
 1768 001e CE01      		movw r24,r28
 1769 0020 0E94 0000 		call process_record_quantum
 1770               	.LVL176:
 1771 0024 8823      		tst r24
 1772 0026 01F0      		breq .L193
 179:tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 1773               		.loc 1 179 0
 1774 0028 6881      		ld r22,Y
 1775 002a 7981      		ldd r23,Y+1
 1776 002c 8A81      		ldd r24,Y+2
 1777 002e 0E94 0000 		call store_or_get_action
 1778               	.LVL177:
 1779 0032 8C01      		movw r16,r24
 1780               	.LVL178:
 182:tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 1781               		.loc 1 182 0
 1782 0034 0E94 0000 		call layer_debug
 1783               	.LVL179:
 183:tmk_core/common/action.c **** #endif
 1784               		.loc 1 183 0
 1785 0038 0E94 0000 		call default_layer_debug
 1786               	.LVL180:
 187:tmk_core/common/action.c **** }
 1787               		.loc 1 187 0
 1788 003c B801      		movw r22,r16
 1789 003e CE01      		movw r24,r28
 1790 0040 0E94 0000 		call process_action
 1791               	.LVL181:
 1792               	.L193:
 1793               	/* epilogue start */
 188:tmk_core/common/action.c **** 
 1794               		.loc 1 188 0
 1795 0044 DF91      		pop r29
 1796 0046 CF91      		pop r28
 1797               	.LVL182:
 1798 0048 1F91      		pop r17
 1799 004a 0F91      		pop r16
 1800               	.LVL183:
 1801 004c 0895      		ret
 1802               		.cfi_endproc
 1803               	.LFE17:
 1805               		.section	.text.process_record_nocache,"ax",@progbits
 1806               	.global	process_record_nocache
 1808               	process_record_nocache:
 1809               	.LFB14:
 127:tmk_core/common/action.c ****     disable_action_cache = true;
 1810               		.loc 1 127 0
 1811               		.cfi_startproc
 1812               	.LVL184:
 1813               	/* prologue: function */
 1814               	/* frame size = 0 */
 1815               	/* stack size = 0 */
 1816               	.L__stack_usage = 0
 128:tmk_core/common/action.c ****     process_record(record);
 1817               		.loc 1 128 0
 1818 0000 21E0      		ldi r18,lo8(1)
 1819 0002 2093 0000 		sts disable_action_cache,r18
 129:tmk_core/common/action.c ****     disable_action_cache = false;
 1820               		.loc 1 129 0
 1821 0006 0E94 0000 		call process_record
 1822               	.LVL185:
 130:tmk_core/common/action.c **** }
 1823               		.loc 1 130 0
 1824 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 1825 000e 0895      		ret
 1826               		.cfi_endproc
 1827               	.LFE14:
 1829               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 1830               	.global	clear_keyboard_but_mods
 1832               	clear_keyboard_but_mods:
 1833               	.LFB24:
 858:tmk_core/common/action.c ****     }
 859:tmk_core/common/action.c **** }
 860:tmk_core/common/action.c **** 
 861:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 862:tmk_core/common/action.c ****  *
 863:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 864:tmk_core/common/action.c ****  */
 865:tmk_core/common/action.c **** void clear_keyboard(void)
 866:tmk_core/common/action.c **** {
 867:tmk_core/common/action.c ****     clear_mods();
 868:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 869:tmk_core/common/action.c **** }
 870:tmk_core/common/action.c **** 
 871:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 872:tmk_core/common/action.c ****  *
 873:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 874:tmk_core/common/action.c ****  */
 875:tmk_core/common/action.c **** void clear_keyboard_but_mods(void)
 876:tmk_core/common/action.c **** {
 1834               		.loc 1 876 0
 1835               		.cfi_startproc
 1836               	/* prologue: function */
 1837               	/* frame size = 0 */
 1838               	/* stack size = 0 */
 1839               	.L__stack_usage = 0
 877:tmk_core/common/action.c ****     clear_weak_mods();
 1840               		.loc 1 877 0
 1841 0000 0E94 0000 		call clear_weak_mods
 1842               	.LVL186:
 878:tmk_core/common/action.c ****     clear_macro_mods();
 1843               		.loc 1 878 0
 1844 0004 0E94 0000 		call clear_macro_mods
 1845               	.LVL187:
 1846               	.LBB86:
 1847               	.LBB87:
  38:tmk_core/common/action_util.h **** }
  39:tmk_core/common/action_util.h **** 
  40:tmk_core/common/action_util.h **** inline void clear_keys(void) {
  41:tmk_core/common/action_util.h ****   clear_keys_from_report(keyboard_report);
 1848               		.loc 2 41 0
 1849 0008 8091 0000 		lds r24,keyboard_report
 1850 000c 9091 0000 		lds r25,keyboard_report+1
 1851 0010 0E94 0000 		call clear_keys_from_report
 1852               	.LVL188:
 1853               	.LBE87:
 1854               	.LBE86:
 879:tmk_core/common/action.c ****     clear_keys();
 880:tmk_core/common/action.c ****     send_keyboard_report();
 1855               		.loc 1 880 0
 1856 0014 0E94 0000 		call send_keyboard_report
 1857               	.LVL189:
 881:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 882:tmk_core/common/action.c ****     mousekey_clear();
 883:tmk_core/common/action.c ****     mousekey_send();
 884:tmk_core/common/action.c **** #endif
 885:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 886:tmk_core/common/action.c ****     host_system_send(0);
 1858               		.loc 1 886 0
 1859 0018 80E0      		ldi r24,0
 1860 001a 90E0      		ldi r25,0
 1861 001c 0E94 0000 		call host_system_send
 1862               	.LVL190:
 887:tmk_core/common/action.c ****     host_consumer_send(0);
 1863               		.loc 1 887 0
 1864 0020 80E0      		ldi r24,0
 1865 0022 90E0      		ldi r25,0
 1866 0024 0C94 0000 		jmp host_consumer_send
 1867               	.LVL191:
 1868               		.cfi_endproc
 1869               	.LFE24:
 1871               		.section	.text.clear_keyboard,"ax",@progbits
 1872               	.global	clear_keyboard
 1874               	clear_keyboard:
 1875               	.LFB23:
 866:tmk_core/common/action.c ****     clear_mods();
 1876               		.loc 1 866 0
 1877               		.cfi_startproc
 1878               	/* prologue: function */
 1879               	/* frame size = 0 */
 1880               	/* stack size = 0 */
 1881               	.L__stack_usage = 0
 867:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 1882               		.loc 1 867 0
 1883 0000 0E94 0000 		call clear_mods
 1884               	.LVL192:
 868:tmk_core/common/action.c **** }
 1885               		.loc 1 868 0
 1886 0004 0C94 0000 		jmp clear_keyboard_but_mods
 1887               	.LVL193:
 1888               		.cfi_endproc
 1889               	.LFE23:
 1891               		.section	.text.is_tap_key,"ax",@progbits
 1892               	.global	is_tap_key
 1894               	is_tap_key:
 1895               	.LFB25:
 888:tmk_core/common/action.c **** #endif
 889:tmk_core/common/action.c **** }
 890:tmk_core/common/action.c **** 
 891:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 892:tmk_core/common/action.c ****  *
 893:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 894:tmk_core/common/action.c ****  */
 895:tmk_core/common/action.c **** bool is_tap_key(keypos_t key)
 896:tmk_core/common/action.c **** {
 1896               		.loc 1 896 0
 1897               		.cfi_startproc
 1898               	.LVL194:
 1899               	/* prologue: function */
 1900               	/* frame size = 0 */
 1901               	/* stack size = 0 */
 1902               	.L__stack_usage = 0
 897:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 1903               		.loc 1 897 0
 1904 0000 0E94 0000 		call layer_switch_get_action
 1905               	.LVL195:
 898:tmk_core/common/action.c **** 
 899:tmk_core/common/action.c ****     switch (action.kind.id) {
 1906               		.loc 1 899 0
 1907 0004 E92F      		mov r30,r25
 1908 0006 E295      		swap r30
 1909 0008 EF70      		andi r30,lo8(15)
 1910 000a F0E0      		ldi r31,0
 1911 000c 3297      		sbiw r30,2
 1912 000e EE30      		cpi r30,14
 1913 0010 F105      		cpc r31,__zero_reg__
 1914 0012 00F4      		brsh .L216
 1915 0014 E050      		subi r30,lo8(-(gs(.L210)))
 1916 0016 F040      		sbci r31,hi8(-(gs(.L210)))
 1917 0018 0C94 0000 		jmp __tablejump2__
 1918               		.section	.progmem.gcc_sw_table.is_tap_key,"a",@progbits
 1919               		.p2align	1
 1920               	.L210:
 1921 0000 0000      		.word gs(.L209)
 1922 0002 0000      		.word gs(.L209)
 1923 0004 0000      		.word gs(.L216)
 1924 0006 0000      		.word gs(.L216)
 1925 0008 0000      		.word gs(.L211)
 1926 000a 0000      		.word gs(.L216)
 1927 000c 0000      		.word gs(.L216)
 1928 000e 0000      		.word gs(.L216)
 1929 0010 0000      		.word gs(.L209)
 1930 0012 0000      		.word gs(.L209)
 1931 0014 0000      		.word gs(.L212)
 1932 0016 0000      		.word gs(.L216)
 1933 0018 0000      		.word gs(.L216)
 1934 001a 0000      		.word gs(.L212)
 1935               		.section	.text.is_tap_key
 1936               	.L209:
 900:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 901:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 902:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 903:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 904:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1937               		.loc 1 904 0
 1938 001c 803F      		cpi r24,lo8(-16)
 1939 001e 01F0      		breq .L218
 1940 0020 00F4      		brsh .L214
 1941 0022 803E      		cpi r24,lo8(-32)
 1942 0024 00F4      		brsh .L216
 1943 0026 00C0      		rjmp .L218
 1944               	.L214:
 1945 0028 843F      		cpi r24,lo8(-12)
 1946 002a 01F4      		brne .L216
 1947 002c 00C0      		rjmp .L218
 1948               	.L211:
 905:tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 906:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 907:tmk_core/common/action.c ****                 case OP_ONESHOT:
 908:tmk_core/common/action.c ****                     return true;
 909:tmk_core/common/action.c ****             }
 910:tmk_core/common/action.c ****             return false;
 911:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 912:tmk_core/common/action.c ****             switch (action.swap.code) {
 1949               		.loc 1 912 0
 1950 002e 803E      		cpi r24,lo8(-32)
 1951 0030 00F0      		brlo .L218
 1952 0032 813F      		cpi r24,lo8(-15)
 1953 0034 01F4      		brne .L216
 1954 0036 00C0      		rjmp .L218
 1955               	.L212:
 913:tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 914:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 915:tmk_core/common/action.c ****                     return true;
 916:tmk_core/common/action.c ****             }
 917:tmk_core/common/action.c ****             return false;
 918:tmk_core/common/action.c ****         case ACT_MACRO:
 919:tmk_core/common/action.c ****         case ACT_FUNCTION:
 920:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) { return true; }
 1956               		.loc 1 920 0
 1957 0038 93FB      		bst r25,3
 1958 003a 8827      		clr r24
 1959 003c 80F9      		bld r24,0
 1960               	.LVL196:
 1961 003e 0895      		ret
 1962               	.LVL197:
 1963               	.L216:
 921:tmk_core/common/action.c ****             return false;
 922:tmk_core/common/action.c ****     }
 923:tmk_core/common/action.c ****     return false;
 1964               		.loc 1 923 0
 1965 0040 80E0      		ldi r24,0
 1966               	.LVL198:
 1967 0042 0895      		ret
 1968               	.LVL199:
 1969               	.L218:
 915:tmk_core/common/action.c ****             }
 1970               		.loc 1 915 0
 1971 0044 81E0      		ldi r24,lo8(1)
 1972               	.LVL200:
 924:tmk_core/common/action.c **** }
 1973               		.loc 1 924 0
 1974 0046 0895      		ret
 1975               		.cfi_endproc
 1976               	.LFE25:
 1978               		.section	.text.debug_event,"ax",@progbits
 1979               	.global	debug_event
 1981               	debug_event:
 1982               	.LFB26:
 925:tmk_core/common/action.c **** 
 926:tmk_core/common/action.c **** 
 927:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 928:tmk_core/common/action.c ****  *
 929:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 930:tmk_core/common/action.c ****  */
 931:tmk_core/common/action.c **** void debug_event(keyevent_t event)
 932:tmk_core/common/action.c **** {
 1983               		.loc 1 932 0
 1984               		.cfi_startproc
 1985 0000 CF93      		push r28
 1986               	.LCFI21:
 1987               		.cfi_def_cfa_offset 3
 1988               		.cfi_offset 28, -2
 1989 0002 DF93      		push r29
 1990               	.LCFI22:
 1991               		.cfi_def_cfa_offset 4
 1992               		.cfi_offset 29, -3
 1993 0004 00D0      		rcall .
 1994 0006 00D0      		rcall .
 1995 0008 1F92      		push __zero_reg__
 1996               	.LCFI23:
 1997               		.cfi_def_cfa_offset 9
 1998 000a CDB7      		in r28,__SP_L__
 1999 000c DEB7      		in r29,__SP_H__
 2000               	.LCFI24:
 2001               		.cfi_def_cfa_register 28
 2002               	/* prologue: function */
 2003               	/* frame size = 5 */
 2004               	/* stack size = 7 */
 2005               	.L__stack_usage = 7
 2006               	/* epilogue start */
 933:tmk_core/common/action.c ****     dprintf("%04X%c(%u)", (event.key.row<<8 | event.key.col), (event.pressed ? 'd' : 'u'), event.ti
 934:tmk_core/common/action.c **** }
 2007               		.loc 1 934 0
 2008 000e 0F90      		pop __tmp_reg__
 2009 0010 0F90      		pop __tmp_reg__
 2010 0012 0F90      		pop __tmp_reg__
 2011 0014 0F90      		pop __tmp_reg__
 2012 0016 0F90      		pop __tmp_reg__
 2013 0018 DF91      		pop r29
 2014 001a CF91      		pop r28
 2015 001c 0895      		ret
 2016               		.cfi_endproc
 2017               	.LFE26:
 2019               		.section	.text.debug_record,"ax",@progbits
 2020               	.global	debug_record
 2022               	debug_record:
 2023               	.LFB27:
 935:tmk_core/common/action.c **** 
 936:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 937:tmk_core/common/action.c ****  *
 938:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 939:tmk_core/common/action.c ****  */
 940:tmk_core/common/action.c **** void debug_record(keyrecord_t record)
 941:tmk_core/common/action.c **** {
 2024               		.loc 1 941 0
 2025               		.cfi_startproc
 2026 0000 CF93      		push r28
 2027               	.LCFI25:
 2028               		.cfi_def_cfa_offset 3
 2029               		.cfi_offset 28, -2
 2030 0002 DF93      		push r29
 2031               	.LCFI26:
 2032               		.cfi_def_cfa_offset 4
 2033               		.cfi_offset 29, -3
 2034 0004 00D0      		rcall .
 2035 0006 00D0      		rcall .
 2036 0008 00D0      		rcall .
 2037               	.LCFI27:
 2038               		.cfi_def_cfa_offset 10
 2039 000a CDB7      		in r28,__SP_L__
 2040 000c DEB7      		in r29,__SP_H__
 2041               	.LCFI28:
 2042               		.cfi_def_cfa_register 28
 2043               	/* prologue: function */
 2044               	/* frame size = 6 */
 2045               	/* stack size = 8 */
 2046               	.L__stack_usage = 8
 2047               	/* epilogue start */
 942:tmk_core/common/action.c ****     debug_event(record.event);
 943:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 944:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 945:tmk_core/common/action.c **** #endif
 946:tmk_core/common/action.c **** }
 2048               		.loc 1 946 0
 2049 000e 2696      		adiw r28,6
 2050 0010 0FB6      		in __tmp_reg__,__SREG__
 2051 0012 F894      		cli
 2052 0014 DEBF      		out __SP_H__,r29
 2053 0016 0FBE      		out __SREG__,__tmp_reg__
 2054 0018 CDBF      		out __SP_L__,r28
 2055 001a DF91      		pop r29
 2056 001c CF91      		pop r28
 2057 001e 0895      		ret
 2058               		.cfi_endproc
 2059               	.LFE27:
 2061               		.section	.text.debug_action,"ax",@progbits
 2062               	.global	debug_action
 2064               	debug_action:
 2065               	.LFB28:
 947:tmk_core/common/action.c **** 
 948:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 949:tmk_core/common/action.c ****  *
 950:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 951:tmk_core/common/action.c ****  */
 952:tmk_core/common/action.c **** void debug_action(action_t action)
 953:tmk_core/common/action.c **** {
 2066               		.loc 1 953 0
 2067               		.cfi_startproc
 2068               	.LVL201:
 2069               	/* prologue: function */
 2070               	/* frame size = 0 */
 2071               	/* stack size = 0 */
 2072               	.L__stack_usage = 0
 2073 0000 0895      		ret
 2074               		.cfi_endproc
 2075               	.LFE28:
 2077               	.global	disable_action_cache
 2078               		.section	.bss.disable_action_cache,"aw",@nobits
 2081               	disable_action_cache:
 2082 0000 00        		.zero	1
 2083               		.comm	tp_buttons,2,1
 2084               		.text
 2085               	.Letext0:
 2086               		.file 5 "c:\\msys64\\home\\cris almanza\\qmk_utils\\avr8-gnu-toolchain\\avr\\include\\stdint.h"
 2087               		.file 6 "tmk_core/common/keycode.h"
 2088               		.file 7 "tmk_core/common/report.h"
 2089               		.file 8 "tmk_core/common/action_code.h"
 2090               		.file 9 "tmk_core/common/action.h"
 2091               		.file 10 "tmk_core/common/action_tapping.h"
 2092               		.file 11 "tmk_core/common/host.h"
 2093               		.file 12 "tmk_core/common/action_layer.h"
 2094               		.file 13 "tmk_core/common/backlight.h"
 2095               		.file 14 "tmk_core/common/led.h"
DEFINED SYMBOLS
                            *ABS*:00000000 action.c
C:\msys64\tmp\ccMNvC9N.s:2      *ABS*:0000003e __SP_H__
C:\msys64\tmp\ccMNvC9N.s:3      *ABS*:0000003d __SP_L__
C:\msys64\tmp\ccMNvC9N.s:4      *ABS*:0000003f __SREG__
C:\msys64\tmp\ccMNvC9N.s:5      *ABS*:00000000 __tmp_reg__
C:\msys64\tmp\ccMNvC9N.s:6      *ABS*:00000001 __zero_reg__
C:\msys64\tmp\ccMNvC9N.s:13     .text.action_exec:00000000 action_exec
C:\msys64\tmp\ccMNvC9N.s:93     .text.process_record_quantum:00000000 process_record_quantum
C:\msys64\tmp\ccMNvC9N.s:112    .text.process_record_tap_hint:00000000 process_record_tap_hint
C:\msys64\tmp\ccMNvC9N.s:135    .text.register_code:00000000 register_code
C:\msys64\tmp\ccMNvC9N.s:531    .text.unregister_code:00000000 unregister_code
C:\msys64\tmp\ccMNvC9N.s:700    .text.register_mods:00000000 register_mods
C:\msys64\tmp\ccMNvC9N.s:726    .text.unregister_mods:00000000 unregister_mods
C:\msys64\tmp\ccMNvC9N.s:752    .text.process_action:00000000 process_action
C:\msys64\tmp\ccMNvC9N.s:1723   .text.process_record:00000000 process_record
C:\msys64\tmp\ccMNvC9N.s:1808   .text.process_record_nocache:00000000 process_record_nocache
C:\msys64\tmp\ccMNvC9N.s:2081   .bss.disable_action_cache:00000000 disable_action_cache
C:\msys64\tmp\ccMNvC9N.s:1832   .text.clear_keyboard_but_mods:00000000 clear_keyboard_but_mods
C:\msys64\tmp\ccMNvC9N.s:1874   .text.clear_keyboard:00000000 clear_keyboard
C:\msys64\tmp\ccMNvC9N.s:1894   .text.is_tap_key:00000000 is_tap_key
C:\msys64\tmp\ccMNvC9N.s:1981   .text.debug_event:00000000 debug_event
C:\msys64\tmp\ccMNvC9N.s:2022   .text.debug_record:00000000 debug_record
C:\msys64\tmp\ccMNvC9N.s:2064   .text.debug_action:00000000 debug_action
                            *COM*:00000002 tp_buttons

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
host_keyboard_leds
keyboard_report
add_key_to_report
send_keyboard_report
del_key_from_report
add_mods
host_system_send
host_consumer_send
del_mods
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_xor
default_layer_or
layer_and
layer_xor
layer_or
layer_on
layer_off
layer_invert
layer_move
layer_clear
set_oneshot_layer
backlight_decrease
backlight_increase
backlight_toggle
backlight_step
backlight_level
led_set
get_oneshot_layer_state
get_oneshot_layer
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
clear_keys_from_report
clear_mods
__do_clear_bss
