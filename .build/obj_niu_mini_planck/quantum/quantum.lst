   1               		.file	"quantum.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.do_code16,"ax",@progbits
  12               	do_code16:
  13               	.LFB17:
  14               		.file 1 "quantum/quantum.c"
   1:quantum/quantum.c **** /* Copyright 2016-2017 Jack Humbert
   2:quantum/quantum.c ****  *
   3:quantum/quantum.c ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/quantum.c ****  * it under the terms of the GNU General Public License as published by
   5:quantum/quantum.c ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/quantum.c ****  * (at your option) any later version.
   7:quantum/quantum.c ****  *
   8:quantum/quantum.c ****  * This program is distributed in the hope that it will be useful,
   9:quantum/quantum.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/quantum.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/quantum.c ****  * GNU General Public License for more details.
  12:quantum/quantum.c ****  *
  13:quantum/quantum.c ****  * You should have received a copy of the GNU General Public License
  14:quantum/quantum.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/quantum.c ****  */
  16:quantum/quantum.c **** 
  17:quantum/quantum.c **** #include "quantum.h"
  18:quantum/quantum.c **** #ifdef PROTOCOL_LUFA
  19:quantum/quantum.c **** #include "outputselect.h"
  20:quantum/quantum.c **** #endif
  21:quantum/quantum.c **** 
  22:quantum/quantum.c **** #ifndef TAPPING_TERM
  23:quantum/quantum.c **** #define TAPPING_TERM 200
  24:quantum/quantum.c **** #endif
  25:quantum/quantum.c **** 
  26:quantum/quantum.c **** #ifndef BREATHING_PERIOD
  27:quantum/quantum.c **** #define BREATHING_PERIOD 6
  28:quantum/quantum.c **** #endif
  29:quantum/quantum.c **** 
  30:quantum/quantum.c **** #include "backlight.h"
  31:quantum/quantum.c **** extern backlight_config_t backlight_config;
  32:quantum/quantum.c **** 
  33:quantum/quantum.c **** #ifdef FAUXCLICKY_ENABLE
  34:quantum/quantum.c **** #include "fauxclicky.h"
  35:quantum/quantum.c **** #endif
  36:quantum/quantum.c **** 
  37:quantum/quantum.c **** #ifdef API_ENABLE
  38:quantum/quantum.c **** #include "api.h"
  39:quantum/quantum.c **** #endif
  40:quantum/quantum.c **** 
  41:quantum/quantum.c **** #ifdef MIDI_ENABLE
  42:quantum/quantum.c **** #include "process_midi.h"
  43:quantum/quantum.c **** #endif
  44:quantum/quantum.c **** 
  45:quantum/quantum.c **** #ifdef AUDIO_ENABLE
  46:quantum/quantum.c ****   #ifndef GOODBYE_SONG
  47:quantum/quantum.c ****     #define GOODBYE_SONG SONG(GOODBYE_SOUND)
  48:quantum/quantum.c ****   #endif
  49:quantum/quantum.c ****   #ifndef AG_NORM_SONG
  50:quantum/quantum.c ****     #define AG_NORM_SONG SONG(AG_NORM_SOUND)
  51:quantum/quantum.c ****   #endif
  52:quantum/quantum.c ****   #ifndef AG_SWAP_SONG
  53:quantum/quantum.c ****     #define AG_SWAP_SONG SONG(AG_SWAP_SOUND)
  54:quantum/quantum.c ****   #endif
  55:quantum/quantum.c ****   float goodbye_song[][2] = GOODBYE_SONG;
  56:quantum/quantum.c ****   float ag_norm_song[][2] = AG_NORM_SONG;
  57:quantum/quantum.c ****   float ag_swap_song[][2] = AG_SWAP_SONG;
  58:quantum/quantum.c ****   #ifdef DEFAULT_LAYER_SONGS
  59:quantum/quantum.c ****     float default_layer_songs[][16][2] = DEFAULT_LAYER_SONGS;
  60:quantum/quantum.c ****   #endif
  61:quantum/quantum.c **** #endif
  62:quantum/quantum.c **** 
  63:quantum/quantum.c **** static void do_code16 (uint16_t code, void (*f) (uint8_t)) {
  15               		.loc 1 63 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 0F93      		push r16
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 16, -2
  22 0002 1F93      		push r17
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 17, -3
  26 0004 CF93      		push r28
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 28, -4
  30 0006 DF93      		push r29
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 29, -5
  34               	/* prologue: function */
  35               	/* frame size = 0 */
  36               	/* stack size = 4 */
  37               	.L__stack_usage = 4
  64:quantum/quantum.c ****   switch (code) {
  38               		.loc 1 64 0
  39 0008 9C01      		movw r18,r24
  40 000a 3A95      		dec r19
  41 000c 2115      		cp r18,__zero_reg__
  42 000e 3F41      		sbci r19,31
  43 0010 00F4      		brsh .L1
  44 0012 EB01      		movw r28,r22
  45 0014 8C01      		movw r16,r24
  65:quantum/quantum.c ****   case QK_MODS ... QK_MODS_MAX:
  66:quantum/quantum.c ****     break;
  67:quantum/quantum.c ****   default:
  68:quantum/quantum.c ****     return;
  69:quantum/quantum.c ****   }
  70:quantum/quantum.c **** 
  71:quantum/quantum.c ****   if (code & QK_LCTL)
  46               		.loc 1 71 0
  47 0016 90FF      		sbrs r25,0
  48 0018 00C0      		rjmp .L4
  72:quantum/quantum.c ****     f(KC_LCTL);
  49               		.loc 1 72 0
  50 001a 80EE      		ldi r24,lo8(-32)
  51               	.LVL1:
  52 001c FB01      		movw r30,r22
  53 001e 0995      		icall
  54               	.LVL2:
  55               	.L4:
  73:quantum/quantum.c ****   if (code & QK_LSFT)
  56               		.loc 1 73 0
  57 0020 11FF      		sbrs r17,1
  58 0022 00C0      		rjmp .L5
  74:quantum/quantum.c ****     f(KC_LSFT);
  59               		.loc 1 74 0
  60 0024 81EE      		ldi r24,lo8(-31)
  61 0026 FE01      		movw r30,r28
  62 0028 0995      		icall
  63               	.LVL3:
  64               	.L5:
  75:quantum/quantum.c ****   if (code & QK_LALT)
  65               		.loc 1 75 0
  66 002a 12FF      		sbrs r17,2
  67 002c 00C0      		rjmp .L6
  76:quantum/quantum.c ****     f(KC_LALT);
  68               		.loc 1 76 0
  69 002e 82EE      		ldi r24,lo8(-30)
  70 0030 FE01      		movw r30,r28
  71 0032 0995      		icall
  72               	.LVL4:
  73               	.L6:
  77:quantum/quantum.c ****   if (code & QK_LGUI)
  74               		.loc 1 77 0
  75 0034 13FF      		sbrs r17,3
  76 0036 00C0      		rjmp .L7
  78:quantum/quantum.c ****     f(KC_LGUI);
  77               		.loc 1 78 0
  78 0038 83EE      		ldi r24,lo8(-29)
  79 003a FE01      		movw r30,r28
  80 003c 0995      		icall
  81               	.LVL5:
  82               	.L7:
  79:quantum/quantum.c **** 
  80:quantum/quantum.c ****   if (code < QK_RMODS_MIN) return;
  83               		.loc 1 80 0
  84 003e 0115      		cp r16,__zero_reg__
  85 0040 1041      		sbci r17,16
  86 0042 00F0      		brlo .L1
  81:quantum/quantum.c **** 
  82:quantum/quantum.c ****   if (code & QK_RCTL)
  83:quantum/quantum.c ****     f(KC_RCTL);
  87               		.loc 1 83 0
  88 0044 84EE      		ldi r24,lo8(-28)
  89 0046 FE01      		movw r30,r28
  90 0048 0995      		icall
  91               	.LVL6:
  84:quantum/quantum.c ****   if (code & QK_RSFT)
  85:quantum/quantum.c ****     f(KC_RSFT);
  92               		.loc 1 85 0
  93 004a 85EE      		ldi r24,lo8(-27)
  94 004c FE01      		movw r30,r28
  95 004e 0995      		icall
  96               	.LVL7:
  86:quantum/quantum.c ****   if (code & QK_RALT)
  87:quantum/quantum.c ****     f(KC_RALT);
  97               		.loc 1 87 0
  98 0050 86EE      		ldi r24,lo8(-26)
  99 0052 FE01      		movw r30,r28
 100 0054 0995      		icall
 101               	.LVL8:
  88:quantum/quantum.c ****   if (code & QK_RGUI)
  89:quantum/quantum.c ****     f(KC_RGUI);
 102               		.loc 1 89 0
 103 0056 87EE      		ldi r24,lo8(-25)
 104 0058 FE01      		movw r30,r28
 105               	/* epilogue start */
  90:quantum/quantum.c **** }
 106               		.loc 1 90 0
 107 005a DF91      		pop r29
 108 005c CF91      		pop r28
 109               	.LVL9:
 110 005e 1F91      		pop r17
 111 0060 0F91      		pop r16
 112               	.LVL10:
  89:quantum/quantum.c **** }
 113               		.loc 1 89 0
 114 0062 0994      		ijmp
 115               	.LVL11:
 116               	.L1:
 117               	/* epilogue start */
 118               		.loc 1 90 0
 119 0064 DF91      		pop r29
 120 0066 CF91      		pop r28
 121 0068 1F91      		pop r17
 122 006a 0F91      		pop r16
 123 006c 0895      		ret
 124               		.cfi_endproc
 125               	.LFE17:
 127               		.section	.text.qk_register_weak_mods,"ax",@progbits
 129               	qk_register_weak_mods:
 130               	.LFB18:
  91:quantum/quantum.c **** 
  92:quantum/quantum.c **** static inline void qk_register_weak_mods(uint8_t kc) {
 131               		.loc 1 92 0
 132               		.cfi_startproc
 133               	.LVL12:
 134               	/* prologue: function */
 135               	/* frame size = 0 */
 136               	/* stack size = 0 */
 137               	.L__stack_usage = 0
  93:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 138               		.loc 1 93 0
 139 0000 8770      		andi r24,lo8(7)
 140               	.LVL13:
 141 0002 91E0      		ldi r25,lo8(1)
 142 0004 00C0      		rjmp 2f
 143               		1:
 144 0006 990F      		lsl r25
 145               		2:
 146 0008 8A95      		dec r24
 147 000a 02F4      		brpl 1b
 148 000c 892F      		mov r24,r25
 149 000e 0E94 0000 		call add_weak_mods
 150               	.LVL14:
  94:quantum/quantum.c ****     send_keyboard_report();
 151               		.loc 1 94 0
 152 0012 0C94 0000 		jmp send_keyboard_report
 153               	.LVL15:
 154               		.cfi_endproc
 155               	.LFE18:
 157               		.section	.text.qk_register_mods,"ax",@progbits
 159               	qk_register_mods:
 160               	.LFB20:
  95:quantum/quantum.c **** }
  96:quantum/quantum.c **** 
  97:quantum/quantum.c **** static inline void qk_unregister_weak_mods(uint8_t kc) {
  98:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
  99:quantum/quantum.c ****     send_keyboard_report();
 100:quantum/quantum.c **** }
 101:quantum/quantum.c **** 
 102:quantum/quantum.c **** static inline void qk_register_mods(uint8_t kc) {
 161               		.loc 1 102 0
 162               		.cfi_startproc
 163               	.LVL16:
 164               	/* prologue: function */
 165               	/* frame size = 0 */
 166               	/* stack size = 0 */
 167               	.L__stack_usage = 0
 103:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 168               		.loc 1 103 0
 169 0000 8770      		andi r24,lo8(7)
 170               	.LVL17:
 171 0002 91E0      		ldi r25,lo8(1)
 172 0004 00C0      		rjmp 2f
 173               		1:
 174 0006 990F      		lsl r25
 175               		2:
 176 0008 8A95      		dec r24
 177 000a 02F4      		brpl 1b
 178 000c 892F      		mov r24,r25
 179 000e 0E94 0000 		call add_weak_mods
 180               	.LVL18:
 104:quantum/quantum.c ****     send_keyboard_report();
 181               		.loc 1 104 0
 182 0012 0C94 0000 		jmp send_keyboard_report
 183               	.LVL19:
 184               		.cfi_endproc
 185               	.LFE20:
 187               		.section	.text.qk_unregister_weak_mods,"ax",@progbits
 189               	qk_unregister_weak_mods:
 190               	.LFB19:
  97:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 191               		.loc 1 97 0
 192               		.cfi_startproc
 193               	.LVL20:
 194               	/* prologue: function */
 195               	/* frame size = 0 */
 196               	/* stack size = 0 */
 197               	.L__stack_usage = 0
  98:quantum/quantum.c ****     send_keyboard_report();
 198               		.loc 1 98 0
 199 0000 8770      		andi r24,lo8(7)
 200               	.LVL21:
 201 0002 91E0      		ldi r25,lo8(1)
 202 0004 00C0      		rjmp 2f
 203               		1:
 204 0006 990F      		lsl r25
 205               		2:
 206 0008 8A95      		dec r24
 207 000a 02F4      		brpl 1b
 208 000c 892F      		mov r24,r25
 209 000e 0E94 0000 		call del_weak_mods
 210               	.LVL22:
  99:quantum/quantum.c **** }
 211               		.loc 1 99 0
 212 0012 0C94 0000 		jmp send_keyboard_report
 213               	.LVL23:
 214               		.cfi_endproc
 215               	.LFE19:
 217               		.section	.text.qk_unregister_mods,"ax",@progbits
 219               	qk_unregister_mods:
 220               	.LFB21:
 105:quantum/quantum.c **** }
 106:quantum/quantum.c **** 
 107:quantum/quantum.c **** static inline void qk_unregister_mods(uint8_t kc) {
 221               		.loc 1 107 0
 222               		.cfi_startproc
 223               	.LVL24:
 224               	/* prologue: function */
 225               	/* frame size = 0 */
 226               	/* stack size = 0 */
 227               	.L__stack_usage = 0
 108:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 228               		.loc 1 108 0
 229 0000 8770      		andi r24,lo8(7)
 230               	.LVL25:
 231 0002 91E0      		ldi r25,lo8(1)
 232 0004 00C0      		rjmp 2f
 233               		1:
 234 0006 990F      		lsl r25
 235               		2:
 236 0008 8A95      		dec r24
 237 000a 02F4      		brpl 1b
 238 000c 892F      		mov r24,r25
 239 000e 0E94 0000 		call del_weak_mods
 240               	.LVL26:
 109:quantum/quantum.c ****     send_keyboard_report();
 241               		.loc 1 109 0
 242 0012 0C94 0000 		jmp send_keyboard_report
 243               	.LVL27:
 244               		.cfi_endproc
 245               	.LFE21:
 247               		.section	.text.register_code16,"ax",@progbits
 248               	.global	register_code16
 250               	register_code16:
 251               	.LFB22:
 110:quantum/quantum.c **** }
 111:quantum/quantum.c **** 
 112:quantum/quantum.c **** void register_code16 (uint16_t code) {
 252               		.loc 1 112 0
 253               		.cfi_startproc
 254               	.LVL28:
 255 0000 CF93      		push r28
 256               	.LCFI4:
 257               		.cfi_def_cfa_offset 3
 258               		.cfi_offset 28, -2
 259 0002 DF93      		push r29
 260               	.LCFI5:
 261               		.cfi_def_cfa_offset 4
 262               		.cfi_offset 29, -3
 263               	/* prologue: function */
 264               	/* frame size = 0 */
 265               	/* stack size = 2 */
 266               	.L__stack_usage = 2
 267 0004 EC01      		movw r28,r24
 113:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 268               		.loc 1 113 0
 269 0006 805E      		subi r24,-32
 270 0008 9109      		sbc r25,__zero_reg__
 271               	.LVL29:
 272 000a 0897      		sbiw r24,8
 273 000c 00F0      		brlo .L28
 274               		.loc 1 113 0 is_stmt 0 discriminator 1
 275 000e 2097      		sbiw r28,0
 276 0010 01F4      		brne .L29
 277               	.L28:
 114:quantum/quantum.c ****       do_code16 (code, qk_register_mods);
 278               		.loc 1 114 0 is_stmt 1
 279 0012 60E0      		ldi r22,lo8(gs(qk_register_mods))
 280 0014 70E0      		ldi r23,hi8(gs(qk_register_mods))
 281 0016 00C0      		rjmp .L31
 282               	.L29:
 115:quantum/quantum.c ****   } else {
 116:quantum/quantum.c ****       do_code16 (code, qk_register_weak_mods);
 283               		.loc 1 116 0
 284 0018 60E0      		ldi r22,lo8(gs(qk_register_weak_mods))
 285 001a 70E0      		ldi r23,hi8(gs(qk_register_weak_mods))
 286               	.L31:
 287 001c CE01      		movw r24,r28
 288 001e 0E94 0000 		call do_code16
 289               	.LVL30:
 117:quantum/quantum.c ****   }
 118:quantum/quantum.c ****   register_code (code);
 290               		.loc 1 118 0
 291 0022 8C2F      		mov r24,r28
 292               	/* epilogue start */
 119:quantum/quantum.c **** }
 293               		.loc 1 119 0
 294 0024 DF91      		pop r29
 295 0026 CF91      		pop r28
 296               	.LVL31:
 118:quantum/quantum.c **** }
 297               		.loc 1 118 0
 298 0028 0C94 0000 		jmp register_code
 299               	.LVL32:
 300               		.cfi_endproc
 301               	.LFE22:
 303               		.section	.text.unregister_code16,"ax",@progbits
 304               	.global	unregister_code16
 306               	unregister_code16:
 307               	.LFB23:
 120:quantum/quantum.c **** 
 121:quantum/quantum.c **** void unregister_code16 (uint16_t code) {
 308               		.loc 1 121 0
 309               		.cfi_startproc
 310               	.LVL33:
 311 0000 CF93      		push r28
 312               	.LCFI6:
 313               		.cfi_def_cfa_offset 3
 314               		.cfi_offset 28, -2
 315 0002 DF93      		push r29
 316               	.LCFI7:
 317               		.cfi_def_cfa_offset 4
 318               		.cfi_offset 29, -3
 319               	/* prologue: function */
 320               	/* frame size = 0 */
 321               	/* stack size = 2 */
 322               	.L__stack_usage = 2
 323 0004 EC01      		movw r28,r24
 122:quantum/quantum.c ****   unregister_code (code);
 324               		.loc 1 122 0
 325 0006 0E94 0000 		call unregister_code
 326               	.LVL34:
 123:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 327               		.loc 1 123 0
 328 000a CE01      		movw r24,r28
 329 000c 805E      		subi r24,-32
 330 000e 9109      		sbc r25,__zero_reg__
 331 0010 0897      		sbiw r24,8
 332 0012 00F0      		brlo .L33
 333               		.loc 1 123 0 is_stmt 0 discriminator 1
 334 0014 2097      		sbiw r28,0
 335 0016 01F4      		brne .L34
 336               	.L33:
 124:quantum/quantum.c ****       do_code16 (code, qk_unregister_mods);
 337               		.loc 1 124 0 is_stmt 1
 338 0018 60E0      		ldi r22,lo8(gs(qk_unregister_mods))
 339 001a 70E0      		ldi r23,hi8(gs(qk_unregister_mods))
 340 001c 00C0      		rjmp .L35
 341               	.L34:
 125:quantum/quantum.c ****   } else {
 126:quantum/quantum.c ****       do_code16 (code, qk_unregister_weak_mods);
 342               		.loc 1 126 0
 343 001e 60E0      		ldi r22,lo8(gs(qk_unregister_weak_mods))
 344 0020 70E0      		ldi r23,hi8(gs(qk_unregister_weak_mods))
 345               	.L35:
 346 0022 CE01      		movw r24,r28
 347               	/* epilogue start */
 127:quantum/quantum.c ****   }
 128:quantum/quantum.c **** }
 348               		.loc 1 128 0
 349 0024 DF91      		pop r29
 350 0026 CF91      		pop r28
 351               	.LVL35:
 126:quantum/quantum.c ****   }
 352               		.loc 1 126 0
 353 0028 0C94 0000 		jmp do_code16
 354               	.LVL36:
 355               		.cfi_endproc
 356               	.LFE23:
 358               		.section	.text.process_action_kb,"ax",@progbits
 359               		.weak	process_action_kb
 361               	process_action_kb:
 362               	.LFB24:
 129:quantum/quantum.c **** 
 130:quantum/quantum.c **** __attribute__ ((weak))
 131:quantum/quantum.c **** bool process_action_kb(keyrecord_t *record) {
 363               		.loc 1 131 0
 364               		.cfi_startproc
 365               	.LVL37:
 366               	/* prologue: function */
 367               	/* frame size = 0 */
 368               	/* stack size = 0 */
 369               	.L__stack_usage = 0
 132:quantum/quantum.c ****   return true;
 133:quantum/quantum.c **** }
 370               		.loc 1 133 0
 371 0000 81E0      		ldi r24,lo8(1)
 372               	.LVL38:
 373 0002 0895      		ret
 374               		.cfi_endproc
 375               	.LFE24:
 377               		.section	.text.process_record_user,"ax",@progbits
 378               		.weak	process_record_user
 380               	process_record_user:
 381               	.LFB26:
 134:quantum/quantum.c **** 
 135:quantum/quantum.c **** __attribute__ ((weak))
 136:quantum/quantum.c **** bool process_record_kb(uint16_t keycode, keyrecord_t *record) {
 137:quantum/quantum.c ****   return process_record_user(keycode, record);
 138:quantum/quantum.c **** }
 139:quantum/quantum.c **** 
 140:quantum/quantum.c **** __attribute__ ((weak))
 141:quantum/quantum.c **** bool process_record_user(uint16_t keycode, keyrecord_t *record) {
 382               		.loc 1 141 0
 383               		.cfi_startproc
 384               	.LVL39:
 385               	/* prologue: function */
 386               	/* frame size = 0 */
 387               	/* stack size = 0 */
 388               	.L__stack_usage = 0
 142:quantum/quantum.c ****   return true;
 143:quantum/quantum.c **** }
 389               		.loc 1 143 0
 390 0000 81E0      		ldi r24,lo8(1)
 391               	.LVL40:
 392 0002 0895      		ret
 393               		.cfi_endproc
 394               	.LFE26:
 396               		.section	.text.process_record_kb,"ax",@progbits
 397               		.weak	process_record_kb
 399               	process_record_kb:
 400               	.LFB25:
 136:quantum/quantum.c ****   return process_record_user(keycode, record);
 401               		.loc 1 136 0
 402               		.cfi_startproc
 403               	.LVL41:
 404               	/* prologue: function */
 405               	/* frame size = 0 */
 406               	/* stack size = 0 */
 407               	.L__stack_usage = 0
 137:quantum/quantum.c **** }
 408               		.loc 1 137 0
 409 0000 0C94 0000 		jmp process_record_user
 410               	.LVL42:
 411               		.cfi_endproc
 412               	.LFE25:
 414               		.section	.text.send_char,"ax",@progbits
 415               	.global	send_char
 417               	send_char:
 418               	.LFB33:
 144:quantum/quantum.c **** 
 145:quantum/quantum.c **** void reset_keyboard(void) {
 146:quantum/quantum.c ****   clear_keyboard();
 147:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 148:quantum/quantum.c ****   process_midi_all_notes_off();
 149:quantum/quantum.c **** #endif
 150:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && !defined(NO_MUSIC_MODE)
 151:quantum/quantum.c ****   music_all_notes_off();
 152:quantum/quantum.c ****   uint16_t timer_start = timer_read();
 153:quantum/quantum.c ****   PLAY_SONG(goodbye_song);
 154:quantum/quantum.c ****   shutdown_user();
 155:quantum/quantum.c ****   while(timer_elapsed(timer_start) < 250)
 156:quantum/quantum.c ****     wait_ms(1);
 157:quantum/quantum.c ****   stop_all_notes();
 158:quantum/quantum.c **** #else
 159:quantum/quantum.c ****   wait_ms(250);
 160:quantum/quantum.c **** #endif
 161:quantum/quantum.c **** // this is also done later in bootloader.c - not sure if it's neccesary here
 162:quantum/quantum.c **** #ifdef BOOTLOADER_CATERINA
 163:quantum/quantum.c ****   *(uint16_t *)0x0800 = 0x7777; // these two are a-star-specific
 164:quantum/quantum.c **** #endif
 165:quantum/quantum.c ****   bootloader_jump();
 166:quantum/quantum.c **** }
 167:quantum/quantum.c **** 
 168:quantum/quantum.c **** // Shift / paren setup
 169:quantum/quantum.c **** 
 170:quantum/quantum.c **** #ifndef LSPO_KEY
 171:quantum/quantum.c ****   #define LSPO_KEY KC_9
 172:quantum/quantum.c **** #endif
 173:quantum/quantum.c **** #ifndef RSPC_KEY
 174:quantum/quantum.c ****   #define RSPC_KEY KC_0
 175:quantum/quantum.c **** #endif
 176:quantum/quantum.c **** 
 177:quantum/quantum.c **** // Shift / Enter setup
 178:quantum/quantum.c **** #ifndef SFTENT_KEY
 179:quantum/quantum.c ****   #define SFTENT_KEY KC_ENT
 180:quantum/quantum.c **** #endif
 181:quantum/quantum.c **** 
 182:quantum/quantum.c **** static bool shift_interrupted[2] = {0, 0};
 183:quantum/quantum.c **** static uint16_t scs_timer[2] = {0, 0};
 184:quantum/quantum.c **** 
 185:quantum/quantum.c **** /* true if the last press of GRAVE_ESC was shifted (i.e. GUI or SHIFT were pressed), false otherwis
 186:quantum/quantum.c ****  * Used to ensure that the correct keycode is released if the key is released.
 187:quantum/quantum.c ****  */
 188:quantum/quantum.c **** static bool grave_esc_was_shifted = false;
 189:quantum/quantum.c **** 
 190:quantum/quantum.c **** bool process_record_quantum(keyrecord_t *record) {
 191:quantum/quantum.c **** 
 192:quantum/quantum.c ****   /* This gets the keycode from the key pressed */
 193:quantum/quantum.c ****   keypos_t key = record->event.key;
 194:quantum/quantum.c ****   uint16_t keycode;
 195:quantum/quantum.c **** 
 196:quantum/quantum.c ****   #if !defined(NO_ACTION_LAYER) && defined(PREVENT_STUCK_MODIFIERS)
 197:quantum/quantum.c ****     /* TODO: Use store_or_get_action() or a similar function. */
 198:quantum/quantum.c ****     if (!disable_action_cache) {
 199:quantum/quantum.c ****       uint8_t layer;
 200:quantum/quantum.c **** 
 201:quantum/quantum.c ****       if (record->event.pressed) {
 202:quantum/quantum.c ****         layer = layer_switch_get_layer(key);
 203:quantum/quantum.c ****         update_source_layers_cache(key, layer);
 204:quantum/quantum.c ****       } else {
 205:quantum/quantum.c ****         layer = read_source_layers_cache(key);
 206:quantum/quantum.c ****       }
 207:quantum/quantum.c ****       keycode = keymap_key_to_keycode(layer, key);
 208:quantum/quantum.c ****     } else
 209:quantum/quantum.c ****   #endif
 210:quantum/quantum.c ****     keycode = keymap_key_to_keycode(layer_switch_get_layer(key), key);
 211:quantum/quantum.c **** 
 212:quantum/quantum.c ****     // This is how you use actions here
 213:quantum/quantum.c ****     // if (keycode == KC_LEAD) {
 214:quantum/quantum.c ****     //   action_t action;
 215:quantum/quantum.c ****     //   action.code = ACTION_DEFAULT_LAYER_SET(0);
 216:quantum/quantum.c ****     //   process_action(record, action);
 217:quantum/quantum.c ****     //   return false;
 218:quantum/quantum.c ****     // }
 219:quantum/quantum.c **** 
 220:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 221:quantum/quantum.c ****     preprocess_tap_dance(keycode, record);
 222:quantum/quantum.c ****   #endif
 223:quantum/quantum.c **** 
 224:quantum/quantum.c ****   if (!(
 225:quantum/quantum.c ****   #if defined(KEY_LOCK_ENABLE)
 226:quantum/quantum.c ****     // Must run first to be able to mask key_up events.
 227:quantum/quantum.c ****     process_key_lock(&keycode, record) &&
 228:quantum/quantum.c ****   #endif
 229:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(AUDIO_CLICKY)
 230:quantum/quantum.c ****       process_clicky(keycode, record) &&
 231:quantum/quantum.c ****   #endif //AUDIO_CLICKY
 232:quantum/quantum.c ****     process_record_kb(keycode, record) &&
 233:quantum/quantum.c ****   #if defined(RGB_MATRIX_ENABLE) && defined(RGB_MATRIX_KEYPRESSES)
 234:quantum/quantum.c ****     process_rgb_matrix(keycode, record) &&
 235:quantum/quantum.c ****   #endif
 236:quantum/quantum.c ****   #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 237:quantum/quantum.c ****     process_midi(keycode, record) &&
 238:quantum/quantum.c ****   #endif
 239:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 240:quantum/quantum.c ****     process_audio(keycode, record) &&
 241:quantum/quantum.c ****   #endif
 242:quantum/quantum.c ****   #ifdef STENO_ENABLE
 243:quantum/quantum.c ****     process_steno(keycode, record) &&
 244:quantum/quantum.c ****   #endif
 245:quantum/quantum.c ****   #if ( defined(AUDIO_ENABLE) || (defined(MIDI_ENABLE) && defined(MIDI_BASIC))) && !defined(NO_MUSI
 246:quantum/quantum.c ****     process_music(keycode, record) &&
 247:quantum/quantum.c ****   #endif
 248:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 249:quantum/quantum.c ****     process_tap_dance(keycode, record) &&
 250:quantum/quantum.c ****   #endif
 251:quantum/quantum.c ****   #ifndef DISABLE_LEADER
 252:quantum/quantum.c ****     process_leader(keycode, record) &&
 253:quantum/quantum.c ****   #endif
 254:quantum/quantum.c ****   #ifndef DISABLE_CHORDING
 255:quantum/quantum.c ****     process_chording(keycode, record) &&
 256:quantum/quantum.c ****   #endif
 257:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 258:quantum/quantum.c ****     process_combo(keycode, record) &&
 259:quantum/quantum.c ****   #endif
 260:quantum/quantum.c ****   #ifdef UNICODE_ENABLE
 261:quantum/quantum.c ****     process_unicode(keycode, record) &&
 262:quantum/quantum.c ****   #endif
 263:quantum/quantum.c ****   #ifdef UCIS_ENABLE
 264:quantum/quantum.c ****     process_ucis(keycode, record) &&
 265:quantum/quantum.c ****   #endif
 266:quantum/quantum.c ****   #ifdef PRINTING_ENABLE
 267:quantum/quantum.c ****     process_printer(keycode, record) &&
 268:quantum/quantum.c ****   #endif
 269:quantum/quantum.c ****   #ifdef AUTO_SHIFT_ENABLE
 270:quantum/quantum.c ****     process_auto_shift(keycode, record) &&
 271:quantum/quantum.c ****   #endif
 272:quantum/quantum.c ****   #ifdef UNICODEMAP_ENABLE
 273:quantum/quantum.c ****     process_unicode_map(keycode, record) &&
 274:quantum/quantum.c ****   #endif
 275:quantum/quantum.c ****   #ifdef TERMINAL_ENABLE
 276:quantum/quantum.c ****     process_terminal(keycode, record) &&
 277:quantum/quantum.c ****   #endif
 278:quantum/quantum.c ****       true)) {
 279:quantum/quantum.c ****     return false;
 280:quantum/quantum.c ****   }
 281:quantum/quantum.c **** 
 282:quantum/quantum.c ****   // Shift / paren setup
 283:quantum/quantum.c **** 
 284:quantum/quantum.c ****   switch(keycode) {
 285:quantum/quantum.c ****     case RESET:
 286:quantum/quantum.c ****       if (record->event.pressed) {
 287:quantum/quantum.c ****         reset_keyboard();
 288:quantum/quantum.c ****       }
 289:quantum/quantum.c ****     return false;
 290:quantum/quantum.c ****     case DEBUG:
 291:quantum/quantum.c ****       if (record->event.pressed) {
 292:quantum/quantum.c ****           debug_enable = true;
 293:quantum/quantum.c ****           print("DEBUG: enabled.\n");
 294:quantum/quantum.c ****       }
 295:quantum/quantum.c ****     return false;
 296:quantum/quantum.c ****   #ifdef FAUXCLICKY_ENABLE
 297:quantum/quantum.c ****   case FC_TOG:
 298:quantum/quantum.c ****     if (record->event.pressed) {
 299:quantum/quantum.c ****       FAUXCLICKY_TOGGLE;
 300:quantum/quantum.c ****     }
 301:quantum/quantum.c ****     return false;
 302:quantum/quantum.c ****   case FC_ON:
 303:quantum/quantum.c ****     if (record->event.pressed) {
 304:quantum/quantum.c ****       FAUXCLICKY_ON;
 305:quantum/quantum.c ****     }
 306:quantum/quantum.c ****     return false;
 307:quantum/quantum.c ****   case FC_OFF:
 308:quantum/quantum.c ****     if (record->event.pressed) {
 309:quantum/quantum.c ****       FAUXCLICKY_OFF;
 310:quantum/quantum.c ****     }
 311:quantum/quantum.c ****     return false;
 312:quantum/quantum.c ****   #endif
 313:quantum/quantum.c ****   #if defined(RGBLIGHT_ENABLE) || defined(RGB_MATRIX_ENABLE)
 314:quantum/quantum.c ****   case RGB_TOG:
 315:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 316:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 317:quantum/quantum.c ****     if (record->event.pressed) {
 318:quantum/quantum.c ****     #else
 319:quantum/quantum.c ****     if (!record->event.pressed) {
 320:quantum/quantum.c ****     #endif
 321:quantum/quantum.c ****       rgblight_toggle();
 322:quantum/quantum.c ****       #ifdef SPLIT_KEYBOARD
 323:quantum/quantum.c ****           RGB_DIRTY = true;
 324:quantum/quantum.c ****       #endif
 325:quantum/quantum.c ****     }
 326:quantum/quantum.c ****     return false;
 327:quantum/quantum.c ****   case RGB_MODE_FORWARD:
 328:quantum/quantum.c ****     if (record->event.pressed) {
 329:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 330:quantum/quantum.c ****       if(shifted) {
 331:quantum/quantum.c ****         rgblight_step_reverse();
 332:quantum/quantum.c ****       }
 333:quantum/quantum.c ****       else {
 334:quantum/quantum.c ****         rgblight_step();
 335:quantum/quantum.c ****       }
 336:quantum/quantum.c ****       #ifdef SPLIT_KEYBOARD
 337:quantum/quantum.c ****           RGB_DIRTY = true;
 338:quantum/quantum.c ****       #endif
 339:quantum/quantum.c ****     }
 340:quantum/quantum.c ****     return false;
 341:quantum/quantum.c ****   case RGB_MODE_REVERSE:
 342:quantum/quantum.c ****     if (record->event.pressed) {
 343:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 344:quantum/quantum.c ****       if(shifted) {
 345:quantum/quantum.c ****         rgblight_step();
 346:quantum/quantum.c ****       }
 347:quantum/quantum.c ****       else {
 348:quantum/quantum.c ****         rgblight_step_reverse();
 349:quantum/quantum.c ****       }
 350:quantum/quantum.c ****       #ifdef SPLIT_KEYBOARD
 351:quantum/quantum.c ****           RGB_DIRTY = true;
 352:quantum/quantum.c ****       #endif
 353:quantum/quantum.c ****     }
 354:quantum/quantum.c ****     return false;
 355:quantum/quantum.c ****   case RGB_HUI:
 356:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 357:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 358:quantum/quantum.c ****     if (record->event.pressed) {
 359:quantum/quantum.c ****     #else
 360:quantum/quantum.c ****     if (!record->event.pressed) {
 361:quantum/quantum.c ****     #endif
 362:quantum/quantum.c ****       rgblight_increase_hue();
 363:quantum/quantum.c ****       #ifdef SPLIT_KEYBOARD
 364:quantum/quantum.c ****           RGB_DIRTY = true;
 365:quantum/quantum.c ****       #endif
 366:quantum/quantum.c ****     }
 367:quantum/quantum.c ****     return false;
 368:quantum/quantum.c ****   case RGB_HUD:
 369:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 370:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 371:quantum/quantum.c ****     if (record->event.pressed) {
 372:quantum/quantum.c ****     #else
 373:quantum/quantum.c ****     if (!record->event.pressed) {
 374:quantum/quantum.c ****     #endif
 375:quantum/quantum.c ****       rgblight_decrease_hue();
 376:quantum/quantum.c ****       #ifdef SPLIT_KEYBOARD
 377:quantum/quantum.c ****           RGB_DIRTY = true;
 378:quantum/quantum.c ****       #endif
 379:quantum/quantum.c ****     }
 380:quantum/quantum.c ****     return false;
 381:quantum/quantum.c ****   case RGB_SAI:
 382:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 383:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 384:quantum/quantum.c ****     if (record->event.pressed) {
 385:quantum/quantum.c ****     #else
 386:quantum/quantum.c ****     if (!record->event.pressed) {
 387:quantum/quantum.c ****     #endif
 388:quantum/quantum.c ****       rgblight_increase_sat();
 389:quantum/quantum.c ****       #ifdef SPLIT_KEYBOARD
 390:quantum/quantum.c ****           RGB_DIRTY = true;
 391:quantum/quantum.c ****       #endif
 392:quantum/quantum.c ****     }
 393:quantum/quantum.c ****     return false;
 394:quantum/quantum.c ****   case RGB_SAD:
 395:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 396:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 397:quantum/quantum.c ****     if (record->event.pressed) {
 398:quantum/quantum.c ****     #else
 399:quantum/quantum.c ****     if (!record->event.pressed) {
 400:quantum/quantum.c ****     #endif
 401:quantum/quantum.c ****       rgblight_decrease_sat();
 402:quantum/quantum.c ****       #ifdef SPLIT_KEYBOARD
 403:quantum/quantum.c ****           RGB_DIRTY = true;
 404:quantum/quantum.c ****       #endif
 405:quantum/quantum.c ****     }
 406:quantum/quantum.c ****     return false;
 407:quantum/quantum.c ****   case RGB_VAI:
 408:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 409:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 410:quantum/quantum.c ****     if (record->event.pressed) {
 411:quantum/quantum.c ****     #else
 412:quantum/quantum.c ****     if (!record->event.pressed) {
 413:quantum/quantum.c ****     #endif
 414:quantum/quantum.c ****       rgblight_increase_val();
 415:quantum/quantum.c ****       #ifdef SPLIT_KEYBOARD
 416:quantum/quantum.c ****           RGB_DIRTY = true;
 417:quantum/quantum.c ****       #endif
 418:quantum/quantum.c ****     }
 419:quantum/quantum.c ****     return false;
 420:quantum/quantum.c ****   case RGB_VAD:
 421:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 422:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 423:quantum/quantum.c ****     if (record->event.pressed) {
 424:quantum/quantum.c ****     #else
 425:quantum/quantum.c ****     if (!record->event.pressed) {
 426:quantum/quantum.c ****     #endif
 427:quantum/quantum.c ****       rgblight_decrease_val();
 428:quantum/quantum.c ****       #ifdef SPLIT_KEYBOARD
 429:quantum/quantum.c ****           RGB_DIRTY = true;
 430:quantum/quantum.c ****       #endif
 431:quantum/quantum.c ****     }
 432:quantum/quantum.c ****     return false;
 433:quantum/quantum.c ****   case RGB_SPI:
 434:quantum/quantum.c ****     if (record->event.pressed) {
 435:quantum/quantum.c ****       rgblight_increase_speed();
 436:quantum/quantum.c ****     }
 437:quantum/quantum.c ****     return false;
 438:quantum/quantum.c ****   case RGB_SPD:
 439:quantum/quantum.c ****     if (record->event.pressed) {
 440:quantum/quantum.c ****       rgblight_decrease_speed();
 441:quantum/quantum.c ****     }
 442:quantum/quantum.c ****     return false;
 443:quantum/quantum.c ****   case RGB_MODE_PLAIN:
 444:quantum/quantum.c ****     if (record->event.pressed) {
 445:quantum/quantum.c ****       rgblight_mode(1);
 446:quantum/quantum.c ****       #ifdef SPLIT_KEYBOARD
 447:quantum/quantum.c ****           RGB_DIRTY = true;
 448:quantum/quantum.c ****       #endif
 449:quantum/quantum.c ****     }
 450:quantum/quantum.c ****     return false;
 451:quantum/quantum.c ****   case RGB_MODE_BREATHE:
 452:quantum/quantum.c ****     if (record->event.pressed) {
 453:quantum/quantum.c ****       if ((2 <= rgblight_get_mode()) && (rgblight_get_mode() < 5)) {
 454:quantum/quantum.c ****         rgblight_step();
 455:quantum/quantum.c ****       } else {
 456:quantum/quantum.c ****         rgblight_mode(2);
 457:quantum/quantum.c ****       }
 458:quantum/quantum.c ****     }
 459:quantum/quantum.c ****     return false;
 460:quantum/quantum.c ****   case RGB_MODE_RAINBOW:
 461:quantum/quantum.c ****     if (record->event.pressed) {
 462:quantum/quantum.c ****       if ((6 <= rgblight_get_mode()) && (rgblight_get_mode() < 8)) {
 463:quantum/quantum.c ****         rgblight_step();
 464:quantum/quantum.c ****       } else {
 465:quantum/quantum.c ****         rgblight_mode(6);
 466:quantum/quantum.c ****       }
 467:quantum/quantum.c ****     }
 468:quantum/quantum.c ****     return false;
 469:quantum/quantum.c ****   case RGB_MODE_SWIRL:
 470:quantum/quantum.c ****     if (record->event.pressed) {
 471:quantum/quantum.c ****       if ((9 <= rgblight_get_mode()) && (rgblight_get_mode() < 14)) {
 472:quantum/quantum.c ****         rgblight_step();
 473:quantum/quantum.c ****       } else {
 474:quantum/quantum.c ****         rgblight_mode(9);
 475:quantum/quantum.c ****       }
 476:quantum/quantum.c ****     }
 477:quantum/quantum.c ****     return false;
 478:quantum/quantum.c ****   case RGB_MODE_SNAKE:
 479:quantum/quantum.c ****     if (record->event.pressed) {
 480:quantum/quantum.c ****       if ((15 <= rgblight_get_mode()) && (rgblight_get_mode() < 20)) {
 481:quantum/quantum.c ****         rgblight_step();
 482:quantum/quantum.c ****       } else {
 483:quantum/quantum.c ****         rgblight_mode(15);
 484:quantum/quantum.c ****       }
 485:quantum/quantum.c ****     }
 486:quantum/quantum.c ****     return false;
 487:quantum/quantum.c ****   case RGB_MODE_KNIGHT:
 488:quantum/quantum.c ****     if (record->event.pressed) {
 489:quantum/quantum.c ****       if ((21 <= rgblight_get_mode()) && (rgblight_get_mode() < 23)) {
 490:quantum/quantum.c ****         rgblight_step();
 491:quantum/quantum.c ****       } else {
 492:quantum/quantum.c ****         rgblight_mode(21);
 493:quantum/quantum.c ****       }
 494:quantum/quantum.c ****     }
 495:quantum/quantum.c ****     return false;
 496:quantum/quantum.c ****   case RGB_MODE_XMAS:
 497:quantum/quantum.c ****     if (record->event.pressed) {
 498:quantum/quantum.c ****       rgblight_mode(24);
 499:quantum/quantum.c ****     }
 500:quantum/quantum.c ****     return false;
 501:quantum/quantum.c ****   case RGB_MODE_GRADIENT:
 502:quantum/quantum.c ****     if (record->event.pressed) {
 503:quantum/quantum.c ****       if ((25 <= rgblight_get_mode()) && (rgblight_get_mode() < 34)) {
 504:quantum/quantum.c ****         rgblight_step();
 505:quantum/quantum.c ****       } else {
 506:quantum/quantum.c ****         rgblight_mode(25);
 507:quantum/quantum.c ****       }
 508:quantum/quantum.c ****     }
 509:quantum/quantum.c ****     return false;
 510:quantum/quantum.c ****   case RGB_MODE_RGBTEST:
 511:quantum/quantum.c ****     if (record->event.pressed) {
 512:quantum/quantum.c ****       rgblight_mode(35);
 513:quantum/quantum.c ****     }
 514:quantum/quantum.c ****     return false;
 515:quantum/quantum.c ****   #endif // defined(RGBLIGHT_ENABLE) || defined(RGB_MATRIX_ENABLE)
 516:quantum/quantum.c ****     #ifdef PROTOCOL_LUFA
 517:quantum/quantum.c ****     case OUT_AUTO:
 518:quantum/quantum.c ****       if (record->event.pressed) {
 519:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 520:quantum/quantum.c ****       }
 521:quantum/quantum.c ****       return false;
 522:quantum/quantum.c ****     case OUT_USB:
 523:quantum/quantum.c ****       if (record->event.pressed) {
 524:quantum/quantum.c ****         set_output(OUTPUT_USB);
 525:quantum/quantum.c ****       }
 526:quantum/quantum.c ****       return false;
 527:quantum/quantum.c ****     #ifdef BLUETOOTH_ENABLE
 528:quantum/quantum.c ****     case OUT_BT:
 529:quantum/quantum.c ****       if (record->event.pressed) {
 530:quantum/quantum.c ****         set_output(OUTPUT_BLUETOOTH);
 531:quantum/quantum.c ****       }
 532:quantum/quantum.c ****       return false;
 533:quantum/quantum.c ****     #endif
 534:quantum/quantum.c ****     #endif
 535:quantum/quantum.c ****     case MAGIC_SWAP_CONTROL_CAPSLOCK ... MAGIC_TOGGLE_NKRO:
 536:quantum/quantum.c ****       if (record->event.pressed) {
 537:quantum/quantum.c ****         // MAGIC actions (BOOTMAGIC without the boot)
 538:quantum/quantum.c ****         if (!eeconfig_is_enabled()) {
 539:quantum/quantum.c ****             eeconfig_init();
 540:quantum/quantum.c ****         }
 541:quantum/quantum.c ****         /* keymap config */
 542:quantum/quantum.c ****         keymap_config.raw = eeconfig_read_keymap();
 543:quantum/quantum.c ****         switch (keycode)
 544:quantum/quantum.c ****         {
 545:quantum/quantum.c ****           case MAGIC_SWAP_CONTROL_CAPSLOCK:
 546:quantum/quantum.c ****             keymap_config.swap_control_capslock = true;
 547:quantum/quantum.c ****             break;
 548:quantum/quantum.c ****           case MAGIC_CAPSLOCK_TO_CONTROL:
 549:quantum/quantum.c ****             keymap_config.capslock_to_control = true;
 550:quantum/quantum.c ****             break;
 551:quantum/quantum.c ****           case MAGIC_SWAP_LALT_LGUI:
 552:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 553:quantum/quantum.c ****             break;
 554:quantum/quantum.c ****           case MAGIC_SWAP_RALT_RGUI:
 555:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 556:quantum/quantum.c ****             break;
 557:quantum/quantum.c ****           case MAGIC_NO_GUI:
 558:quantum/quantum.c ****             keymap_config.no_gui = true;
 559:quantum/quantum.c ****             break;
 560:quantum/quantum.c ****           case MAGIC_SWAP_GRAVE_ESC:
 561:quantum/quantum.c ****             keymap_config.swap_grave_esc = true;
 562:quantum/quantum.c ****             break;
 563:quantum/quantum.c ****           case MAGIC_SWAP_BACKSLASH_BACKSPACE:
 564:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = true;
 565:quantum/quantum.c ****             break;
 566:quantum/quantum.c ****           case MAGIC_HOST_NKRO:
 567:quantum/quantum.c ****             keymap_config.nkro = true;
 568:quantum/quantum.c ****             break;
 569:quantum/quantum.c ****           case MAGIC_SWAP_ALT_GUI:
 570:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 571:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 572:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 573:quantum/quantum.c ****               PLAY_SONG(ag_swap_song);
 574:quantum/quantum.c ****             #endif
 575:quantum/quantum.c ****             break;
 576:quantum/quantum.c ****           case MAGIC_UNSWAP_CONTROL_CAPSLOCK:
 577:quantum/quantum.c ****             keymap_config.swap_control_capslock = false;
 578:quantum/quantum.c ****             break;
 579:quantum/quantum.c ****           case MAGIC_UNCAPSLOCK_TO_CONTROL:
 580:quantum/quantum.c ****             keymap_config.capslock_to_control = false;
 581:quantum/quantum.c ****             break;
 582:quantum/quantum.c ****           case MAGIC_UNSWAP_LALT_LGUI:
 583:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 584:quantum/quantum.c ****             break;
 585:quantum/quantum.c ****           case MAGIC_UNSWAP_RALT_RGUI:
 586:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 587:quantum/quantum.c ****             break;
 588:quantum/quantum.c ****           case MAGIC_UNNO_GUI:
 589:quantum/quantum.c ****             keymap_config.no_gui = false;
 590:quantum/quantum.c ****             break;
 591:quantum/quantum.c ****           case MAGIC_UNSWAP_GRAVE_ESC:
 592:quantum/quantum.c ****             keymap_config.swap_grave_esc = false;
 593:quantum/quantum.c ****             break;
 594:quantum/quantum.c ****           case MAGIC_UNSWAP_BACKSLASH_BACKSPACE:
 595:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = false;
 596:quantum/quantum.c ****             break;
 597:quantum/quantum.c ****           case MAGIC_UNHOST_NKRO:
 598:quantum/quantum.c ****             keymap_config.nkro = false;
 599:quantum/quantum.c ****             break;
 600:quantum/quantum.c ****           case MAGIC_UNSWAP_ALT_GUI:
 601:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 602:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 603:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 604:quantum/quantum.c ****               PLAY_SONG(ag_norm_song);
 605:quantum/quantum.c ****             #endif
 606:quantum/quantum.c ****             break;
 607:quantum/quantum.c ****           case MAGIC_TOGGLE_NKRO:
 608:quantum/quantum.c ****             keymap_config.nkro = !keymap_config.nkro;
 609:quantum/quantum.c ****             break;
 610:quantum/quantum.c ****           default:
 611:quantum/quantum.c ****             break;
 612:quantum/quantum.c ****         }
 613:quantum/quantum.c ****         eeconfig_update_keymap(keymap_config.raw);
 614:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 615:quantum/quantum.c **** 
 616:quantum/quantum.c ****         return false;
 617:quantum/quantum.c ****       }
 618:quantum/quantum.c ****       break;
 619:quantum/quantum.c ****     case KC_LSPO: {
 620:quantum/quantum.c ****       if (record->event.pressed) {
 621:quantum/quantum.c ****         shift_interrupted[0] = false;
 622:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 623:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 624:quantum/quantum.c ****       }
 625:quantum/quantum.c ****       else {
 626:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 627:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_RSFT)) {
 628:quantum/quantum.c ****             shift_interrupted[0] = true;
 629:quantum/quantum.c ****             shift_interrupted[1] = true;
 630:quantum/quantum.c ****           }
 631:quantum/quantum.c ****         #endif
 632:quantum/quantum.c ****         if (!shift_interrupted[0] && timer_elapsed(scs_timer[0]) < TAPPING_TERM) {
 633:quantum/quantum.c ****           register_code(LSPO_KEY);
 634:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 635:quantum/quantum.c ****         }
 636:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_LSFT));
 637:quantum/quantum.c ****       }
 638:quantum/quantum.c ****       return false;
 639:quantum/quantum.c ****     }
 640:quantum/quantum.c **** 
 641:quantum/quantum.c ****     case KC_RSPC: {
 642:quantum/quantum.c ****       if (record->event.pressed) {
 643:quantum/quantum.c ****         shift_interrupted[1] = false;
 644:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 645:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 646:quantum/quantum.c ****       }
 647:quantum/quantum.c ****       else {
 648:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 649:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_LSFT)) {
 650:quantum/quantum.c ****             shift_interrupted[0] = true;
 651:quantum/quantum.c ****             shift_interrupted[1] = true;
 652:quantum/quantum.c ****           }
 653:quantum/quantum.c ****         #endif
 654:quantum/quantum.c ****         if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 655:quantum/quantum.c ****           register_code(RSPC_KEY);
 656:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 657:quantum/quantum.c ****         }
 658:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 659:quantum/quantum.c ****       }
 660:quantum/quantum.c ****       return false;
 661:quantum/quantum.c ****     }
 662:quantum/quantum.c **** 
 663:quantum/quantum.c ****     case KC_SFTENT: {
 664:quantum/quantum.c ****       if (record->event.pressed) {
 665:quantum/quantum.c ****         shift_interrupted[1] = false;
 666:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 667:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 668:quantum/quantum.c ****       }
 669:quantum/quantum.c ****       else if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 670:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 671:quantum/quantum.c ****         register_code(SFTENT_KEY);
 672:quantum/quantum.c ****         unregister_code(SFTENT_KEY);
 673:quantum/quantum.c ****       }
 674:quantum/quantum.c ****       else {
 675:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 676:quantum/quantum.c ****       }
 677:quantum/quantum.c ****       return false;
 678:quantum/quantum.c ****     }
 679:quantum/quantum.c **** 
 680:quantum/quantum.c ****     case GRAVE_ESC: {
 681:quantum/quantum.c ****       uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT)
 682:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 683:quantum/quantum.c **** 
 684:quantum/quantum.c **** #ifdef GRAVE_ESC_ALT_OVERRIDE
 685:quantum/quantum.c ****       // if ALT is pressed, ESC is always sent
 686:quantum/quantum.c ****       // this is handy for the cmd+opt+esc shortcut on macOS, among other things.
 687:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LALT) | MOD_BIT(KC_RALT))) {
 688:quantum/quantum.c ****         shifted = 0;
 689:quantum/quantum.c ****       }
 690:quantum/quantum.c **** #endif
 691:quantum/quantum.c **** 
 692:quantum/quantum.c **** #ifdef GRAVE_ESC_CTRL_OVERRIDE
 693:quantum/quantum.c ****       // if CTRL is pressed, ESC is always sent
 694:quantum/quantum.c ****       // this is handy for the ctrl+shift+esc shortcut on windows, among other things.
 695:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LCTL) | MOD_BIT(KC_RCTL))) {
 696:quantum/quantum.c ****         shifted = 0;
 697:quantum/quantum.c ****       }
 698:quantum/quantum.c **** #endif
 699:quantum/quantum.c **** 
 700:quantum/quantum.c **** #ifdef GRAVE_ESC_GUI_OVERRIDE
 701:quantum/quantum.c ****       // if GUI is pressed, ESC is always sent
 702:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LGUI) | MOD_BIT(KC_RGUI))) {
 703:quantum/quantum.c ****         shifted = 0;
 704:quantum/quantum.c ****       }
 705:quantum/quantum.c **** #endif
 706:quantum/quantum.c **** 
 707:quantum/quantum.c **** #ifdef GRAVE_ESC_SHIFT_OVERRIDE
 708:quantum/quantum.c ****       // if SHIFT is pressed, ESC is always sent
 709:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT))) {
 710:quantum/quantum.c ****         shifted = 0;
 711:quantum/quantum.c ****       }
 712:quantum/quantum.c **** #endif
 713:quantum/quantum.c **** 
 714:quantum/quantum.c ****       if (record->event.pressed) {
 715:quantum/quantum.c ****         grave_esc_was_shifted = shifted;
 716:quantum/quantum.c ****         add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 717:quantum/quantum.c ****       }
 718:quantum/quantum.c ****       else {
 719:quantum/quantum.c ****         del_key(grave_esc_was_shifted ? KC_GRAVE : KC_ESCAPE);
 720:quantum/quantum.c ****       }
 721:quantum/quantum.c **** 
 722:quantum/quantum.c ****       send_keyboard_report();
 723:quantum/quantum.c ****       return false;
 724:quantum/quantum.c ****     }
 725:quantum/quantum.c **** 
 726:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_BREATHING)
 727:quantum/quantum.c ****     case BL_BRTG: {
 728:quantum/quantum.c ****       if (record->event.pressed)
 729:quantum/quantum.c ****         breathing_toggle();
 730:quantum/quantum.c ****       return false;
 731:quantum/quantum.c ****     }
 732:quantum/quantum.c **** #endif
 733:quantum/quantum.c **** 
 734:quantum/quantum.c ****     default: {
 735:quantum/quantum.c ****       shift_interrupted[0] = true;
 736:quantum/quantum.c ****       shift_interrupted[1] = true;
 737:quantum/quantum.c ****       break;
 738:quantum/quantum.c ****     }
 739:quantum/quantum.c ****   }
 740:quantum/quantum.c **** 
 741:quantum/quantum.c ****   return process_action_kb(record);
 742:quantum/quantum.c **** }
 743:quantum/quantum.c **** 
 744:quantum/quantum.c **** __attribute__ ((weak))
 745:quantum/quantum.c **** const bool ascii_to_shift_lut[0x80] PROGMEM = {
 746:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 747:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 748:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 749:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 750:quantum/quantum.c ****     0, 1, 1, 1, 1, 1, 1, 0,
 751:quantum/quantum.c ****     1, 1, 1, 1, 0, 0, 0, 0,
 752:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 753:quantum/quantum.c ****     0, 0, 1, 0, 1, 0, 1, 1,
 754:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 755:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 756:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 757:quantum/quantum.c ****     1, 1, 1, 0, 0, 0, 1, 1,
 758:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 759:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 760:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 761:quantum/quantum.c ****     0, 0, 0, 1, 1, 1, 1, 0
 762:quantum/quantum.c **** };
 763:quantum/quantum.c **** 
 764:quantum/quantum.c **** __attribute__ ((weak))
 765:quantum/quantum.c **** const uint8_t ascii_to_keycode_lut[0x80] PROGMEM = {
 766:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 767:quantum/quantum.c ****     KC_BSPC, KC_TAB, KC_ENT, 0, 0, 0, 0, 0,
 768:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 769:quantum/quantum.c ****     0, 0, 0, KC_ESC, 0, 0, 0, 0,
 770:quantum/quantum.c ****     KC_SPC, KC_1, KC_QUOT, KC_3, KC_4, KC_5, KC_7, KC_QUOT,
 771:quantum/quantum.c ****     KC_9, KC_0, KC_8, KC_EQL, KC_COMM, KC_MINS, KC_DOT, KC_SLSH,
 772:quantum/quantum.c ****     KC_0, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7,
 773:quantum/quantum.c ****     KC_8, KC_9, KC_SCLN, KC_SCLN, KC_COMM, KC_EQL, KC_DOT, KC_SLSH,
 774:quantum/quantum.c ****     KC_2, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 775:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 776:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 777:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_6, KC_MINS,
 778:quantum/quantum.c ****     KC_GRV, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 779:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 780:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 781:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_GRV, KC_DEL
 782:quantum/quantum.c **** };
 783:quantum/quantum.c **** 
 784:quantum/quantum.c **** void send_string(const char *str) {
 785:quantum/quantum.c ****   send_string_with_delay(str, 0);
 786:quantum/quantum.c **** }
 787:quantum/quantum.c **** 
 788:quantum/quantum.c **** void send_string_P(const char *str) {
 789:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 790:quantum/quantum.c **** }
 791:quantum/quantum.c **** 
 792:quantum/quantum.c **** void send_string_with_delay(const char *str, uint8_t interval) {
 793:quantum/quantum.c ****     while (1) {
 794:quantum/quantum.c ****         char ascii_code = *str;
 795:quantum/quantum.c ****         if (!ascii_code) break;
 796:quantum/quantum.c ****         if (ascii_code == 1) {
 797:quantum/quantum.c ****           // tap
 798:quantum/quantum.c ****           uint8_t keycode = *(++str);
 799:quantum/quantum.c ****           register_code(keycode);
 800:quantum/quantum.c ****           unregister_code(keycode);
 801:quantum/quantum.c ****         } else if (ascii_code == 2) {
 802:quantum/quantum.c ****           // down
 803:quantum/quantum.c ****           uint8_t keycode = *(++str);
 804:quantum/quantum.c ****           register_code(keycode);
 805:quantum/quantum.c ****         } else if (ascii_code == 3) {
 806:quantum/quantum.c ****           // up
 807:quantum/quantum.c ****           uint8_t keycode = *(++str);
 808:quantum/quantum.c ****           unregister_code(keycode);
 809:quantum/quantum.c ****         } else {
 810:quantum/quantum.c ****           send_char(ascii_code);
 811:quantum/quantum.c ****         }
 812:quantum/quantum.c ****         ++str;
 813:quantum/quantum.c ****         // interval
 814:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 815:quantum/quantum.c ****     }
 816:quantum/quantum.c **** }
 817:quantum/quantum.c **** 
 818:quantum/quantum.c **** void send_string_with_delay_P(const char *str, uint8_t interval) {
 819:quantum/quantum.c ****     while (1) {
 820:quantum/quantum.c ****         char ascii_code = pgm_read_byte(str);
 821:quantum/quantum.c ****         if (!ascii_code) break;
 822:quantum/quantum.c ****         if (ascii_code == 1) {
 823:quantum/quantum.c ****           // tap
 824:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 825:quantum/quantum.c ****           register_code(keycode);
 826:quantum/quantum.c ****           unregister_code(keycode);
 827:quantum/quantum.c ****         } else if (ascii_code == 2) {
 828:quantum/quantum.c ****           // down
 829:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 830:quantum/quantum.c ****           register_code(keycode);
 831:quantum/quantum.c ****         } else if (ascii_code == 3) {
 832:quantum/quantum.c ****           // up
 833:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 834:quantum/quantum.c ****           unregister_code(keycode);
 835:quantum/quantum.c ****         } else {
 836:quantum/quantum.c ****           send_char(ascii_code);
 837:quantum/quantum.c ****         }
 838:quantum/quantum.c ****         ++str;
 839:quantum/quantum.c ****         // interval
 840:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 841:quantum/quantum.c ****     }
 842:quantum/quantum.c **** }
 843:quantum/quantum.c **** 
 844:quantum/quantum.c **** void send_char(char ascii_code) {
 419               		.loc 1 844 0
 420               		.cfi_startproc
 421               	.LVL43:
 422 0000 CF93      		push r28
 423               	.LCFI8:
 424               		.cfi_def_cfa_offset 3
 425               		.cfi_offset 28, -2
 426               	/* prologue: function */
 427               	/* frame size = 0 */
 428               	/* stack size = 1 */
 429               	.L__stack_usage = 1
 430               	.LBB33:
 845:quantum/quantum.c ****   uint8_t keycode;
 846:quantum/quantum.c ****   keycode = pgm_read_byte(&ascii_to_keycode_lut[(uint8_t)ascii_code]);
 431               		.loc 1 846 0
 432 0002 282F      		mov r18,r24
 433 0004 30E0      		ldi r19,0
 434               	.LVL44:
 435 0006 F901      		movw r30,r18
 436 0008 E050      		subi r30,lo8(-(ascii_to_keycode_lut))
 437 000a F040      		sbci r31,hi8(-(ascii_to_keycode_lut))
 438               	.LVL45:
 439               	/* #APP */
 440               	 ;  846 "quantum/quantum.c" 1
 441 000c C491      		lpm r28, Z
 442               		
 443               	 ;  0 "" 2
 444               	.LVL46:
 445               	/* #NOAPP */
 446               	.LBE33:
 447               	.LBB34:
 847:quantum/quantum.c ****   if (pgm_read_byte(&ascii_to_shift_lut[(uint8_t)ascii_code])) {
 448               		.loc 1 847 0
 449 000e F901      		movw r30,r18
 450               	.LVL47:
 451 0010 E050      		subi r30,lo8(-(ascii_to_shift_lut))
 452 0012 F040      		sbci r31,hi8(-(ascii_to_shift_lut))
 453               	.LVL48:
 454               	/* #APP */
 455               	 ;  847 "quantum/quantum.c" 1
 456 0014 2491      		lpm r18, Z
 457               		
 458               	 ;  0 "" 2
 459               	.LVL49:
 460               	/* #NOAPP */
 461               	.LBE34:
 462 0016 2223      		tst r18
 463 0018 01F0      		breq .L40
 848:quantum/quantum.c ****       register_code(KC_LSFT);
 464               		.loc 1 848 0
 465 001a 81EE      		ldi r24,lo8(-31)
 466               	.LVL50:
 467 001c 0E94 0000 		call register_code
 468               	.LVL51:
 849:quantum/quantum.c ****       register_code(keycode);
 469               		.loc 1 849 0
 470 0020 8C2F      		mov r24,r28
 471 0022 0E94 0000 		call register_code
 472               	.LVL52:
 850:quantum/quantum.c ****       unregister_code(keycode);
 473               		.loc 1 850 0
 474 0026 8C2F      		mov r24,r28
 475 0028 0E94 0000 		call unregister_code
 476               	.LVL53:
 851:quantum/quantum.c ****       unregister_code(KC_LSFT);
 477               		.loc 1 851 0
 478 002c 81EE      		ldi r24,lo8(-31)
 479 002e 00C0      		rjmp .L41
 480               	.LVL54:
 481               	.L40:
 852:quantum/quantum.c ****   } else {
 853:quantum/quantum.c ****       register_code(keycode);
 482               		.loc 1 853 0
 483 0030 8C2F      		mov r24,r28
 484               	.LVL55:
 485 0032 0E94 0000 		call register_code
 486               	.LVL56:
 854:quantum/quantum.c ****       unregister_code(keycode);
 487               		.loc 1 854 0
 488 0036 8C2F      		mov r24,r28
 489               	.L41:
 490               	/* epilogue start */
 855:quantum/quantum.c ****   }
 856:quantum/quantum.c **** }
 491               		.loc 1 856 0
 492 0038 CF91      		pop r28
 493               	.LVL57:
 854:quantum/quantum.c ****       unregister_code(keycode);
 494               		.loc 1 854 0
 495 003a 0C94 0000 		jmp unregister_code
 496               	.LVL58:
 497               		.cfi_endproc
 498               	.LFE33:
 500               		.section	.text.send_string_with_delay,"ax",@progbits
 501               	.global	send_string_with_delay
 503               	send_string_with_delay:
 504               	.LFB31:
 792:quantum/quantum.c ****     while (1) {
 505               		.loc 1 792 0
 506               		.cfi_startproc
 507               	.LVL59:
 508 0000 FF92      		push r15
 509               	.LCFI9:
 510               		.cfi_def_cfa_offset 3
 511               		.cfi_offset 15, -2
 512 0002 0F93      		push r16
 513               	.LCFI10:
 514               		.cfi_def_cfa_offset 4
 515               		.cfi_offset 16, -3
 516 0004 1F93      		push r17
 517               	.LCFI11:
 518               		.cfi_def_cfa_offset 5
 519               		.cfi_offset 17, -4
 520 0006 CF93      		push r28
 521               	.LCFI12:
 522               		.cfi_def_cfa_offset 6
 523               		.cfi_offset 28, -5
 524 0008 DF93      		push r29
 525               	.LCFI13:
 526               		.cfi_def_cfa_offset 7
 527               		.cfi_offset 29, -6
 528               	/* prologue: function */
 529               	/* frame size = 0 */
 530               	/* stack size = 5 */
 531               	.L__stack_usage = 5
 532 000a EC01      		movw r28,r24
 533 000c F62E      		mov r15,r22
 534               	.LVL60:
 535               	.L50:
 536               	.LBB35:
 794:quantum/quantum.c ****         if (!ascii_code) break;
 537               		.loc 1 794 0
 538 000e 8881      		ld r24,Y
 539               	.LVL61:
 795:quantum/quantum.c ****         if (ascii_code == 1) {
 540               		.loc 1 795 0
 541 0010 8823      		tst r24
 542 0012 01F0      		breq .L42
 543 0014 8E01      		movw r16,r28
 544 0016 0F5F      		subi r16,-1
 545 0018 1F4F      		sbci r17,-1
 796:quantum/quantum.c ****           // tap
 546               		.loc 1 796 0
 547 001a 8130      		cpi r24,lo8(1)
 548 001c 01F4      		brne .L44
 549               	.LVL62:
 550               	.LBB36:
 798:quantum/quantum.c ****           register_code(keycode);
 551               		.loc 1 798 0
 552 001e C981      		ldd r28,Y+1
 553               	.LVL63:
 799:quantum/quantum.c ****           unregister_code(keycode);
 554               		.loc 1 799 0
 555 0020 8C2F      		mov r24,r28
 556               	.LVL64:
 557 0022 0E94 0000 		call register_code
 558               	.LVL65:
 800:quantum/quantum.c ****         } else if (ascii_code == 2) {
 559               		.loc 1 800 0
 560 0026 8C2F      		mov r24,r28
 561 0028 00C0      		rjmp .L52
 562               	.LVL66:
 563               	.L44:
 564               	.LBE36:
 801:quantum/quantum.c ****           // down
 565               		.loc 1 801 0
 566 002a 8230      		cpi r24,lo8(2)
 567 002c 01F4      		brne .L46
 568               	.LVL67:
 569               	.LBB37:
 804:quantum/quantum.c ****         } else if (ascii_code == 3) {
 570               		.loc 1 804 0
 571 002e 8981      		ldd r24,Y+1
 572               	.LVL68:
 573 0030 0E94 0000 		call register_code
 574               	.LVL69:
 575               	.L51:
 803:quantum/quantum.c ****           register_code(keycode);
 576               		.loc 1 803 0
 577 0034 E801      		movw r28,r16
 578               	.LBE37:
 579 0036 00C0      		rjmp .L45
 580               	.LVL70:
 581               	.L46:
 805:quantum/quantum.c ****           // up
 582               		.loc 1 805 0
 583 0038 8330      		cpi r24,lo8(3)
 584 003a 01F4      		brne .L47
 585               	.LVL71:
 586               	.LBB38:
 808:quantum/quantum.c ****         } else {
 587               		.loc 1 808 0
 588 003c 8981      		ldd r24,Y+1
 589               	.LVL72:
 590               	.L52:
 591 003e 0E94 0000 		call unregister_code
 592               	.LVL73:
 593 0042 00C0      		rjmp .L51
 594               	.LVL74:
 595               	.L47:
 596               	.LBE38:
 810:quantum/quantum.c ****         }
 597               		.loc 1 810 0
 598 0044 0E94 0000 		call send_char
 599               	.LVL75:
 600               	.L45:
 812:quantum/quantum.c ****         // interval
 601               		.loc 1 812 0
 602 0048 2196      		adiw r28,1
 603               	.LVL76:
 604               	.LBB39:
 814:quantum/quantum.c ****     }
 605               		.loc 1 814 0
 606 004a 8F2D      		mov r24,r15
 607               	.LVL77:
 608               	.L48:
 814:quantum/quantum.c ****     }
 609               		.loc 1 814 0 is_stmt 0 discriminator 1
 610 004c 8823      		tst r24
 611 004e 01F0      		breq .L50
 612               	.LVL78:
 613               	.LBB40:
 614               	.LBB41:
 615               		.file 2 "c:\\msys64\\home\\cris almanza\\qmk_utils\\avr8-gnu-toolchain\\avr\\include\\util\\delay.
   1:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id$ */
  34:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:c:\msys64\home\cris almanza\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 616               		.loc 2 187 0 is_stmt 1
 617 0050 EFE9      		ldi r30,lo8(3999)
 618 0052 FFE0      		ldi r31,hi8(3999)
 619 0054 3197      	1:	sbiw r30,1
 620 0056 01F4      		brne 1b
 621 0058 00C0      		rjmp .
 622 005a 0000      		nop
 623 005c 8150      		subi r24,lo8(-(-1))
 624               	.LVL79:
 625 005e 00C0      		rjmp .L48
 626               	.LVL80:
 627               	.L42:
 628               	/* epilogue start */
 629               	.LBE41:
 630               	.LBE40:
 631               	.LBE39:
 632               	.LBE35:
 816:quantum/quantum.c **** 
 633               		.loc 1 816 0
 634 0060 DF91      		pop r29
 635 0062 CF91      		pop r28
 636               	.LVL81:
 637 0064 1F91      		pop r17
 638 0066 0F91      		pop r16
 639 0068 FF90      		pop r15
 640               	.LVL82:
 641 006a 0895      		ret
 642               		.cfi_endproc
 643               	.LFE31:
 645               		.section	.text.send_string,"ax",@progbits
 646               	.global	send_string
 648               	send_string:
 649               	.LFB29:
 784:quantum/quantum.c ****   send_string_with_delay(str, 0);
 650               		.loc 1 784 0
 651               		.cfi_startproc
 652               	.LVL83:
 653               	/* prologue: function */
 654               	/* frame size = 0 */
 655               	/* stack size = 0 */
 656               	.L__stack_usage = 0
 785:quantum/quantum.c **** }
 657               		.loc 1 785 0
 658 0000 60E0      		ldi r22,0
 659 0002 0C94 0000 		jmp send_string_with_delay
 660               	.LVL84:
 661               		.cfi_endproc
 662               	.LFE29:
 664               		.section	.text.send_string_with_delay_P,"ax",@progbits
 665               	.global	send_string_with_delay_P
 667               	send_string_with_delay_P:
 668               	.LFB32:
 818:quantum/quantum.c ****     while (1) {
 669               		.loc 1 818 0
 670               		.cfi_startproc
 671               	.LVL85:
 672 0000 0F93      		push r16
 673               	.LCFI14:
 674               		.cfi_def_cfa_offset 3
 675               		.cfi_offset 16, -2
 676 0002 1F93      		push r17
 677               	.LCFI15:
 678               		.cfi_def_cfa_offset 4
 679               		.cfi_offset 17, -3
 680 0004 CF93      		push r28
 681               	.LCFI16:
 682               		.cfi_def_cfa_offset 5
 683               		.cfi_offset 28, -4
 684 0006 DF93      		push r29
 685               	.LCFI17:
 686               		.cfi_def_cfa_offset 6
 687               		.cfi_offset 29, -5
 688               	/* prologue: function */
 689               	/* frame size = 0 */
 690               	/* stack size = 4 */
 691               	.L__stack_usage = 4
 692 0008 EC01      		movw r28,r24
 693 000a 062F      		mov r16,r22
 694               	.LVL86:
 695               	.L62:
 696               	.LBB42:
 697               	.LBB43:
 820:quantum/quantum.c ****         if (!ascii_code) break;
 698               		.loc 1 820 0
 699 000c FE01      		movw r30,r28
 700               	/* #APP */
 701               	 ;  820 "quantum/quantum.c" 1
 702 000e 8491      		lpm r24, Z
 703               		
 704               	 ;  0 "" 2
 705               	.LVL87:
 706               	/* #NOAPP */
 707               	.LBE43:
 821:quantum/quantum.c ****         if (ascii_code == 1) {
 708               		.loc 1 821 0
 709 0010 8823      		tst r24
 710 0012 01F0      		breq .L54
 711 0014 9E01      		movw r18,r28
 712 0016 2F5F      		subi r18,-1
 713 0018 3F4F      		sbci r19,-1
 822:quantum/quantum.c ****           // tap
 714               		.loc 1 822 0
 715 001a 8130      		cpi r24,lo8(1)
 716 001c 01F4      		brne .L56
 717               	.LBB44:
 718               	.LBB45:
 824:quantum/quantum.c ****           register_code(keycode);
 719               		.loc 1 824 0
 720 001e E901      		movw r28,r18
 721               	.LVL88:
 722 0020 F901      		movw r30,r18
 723               	.LVL89:
 724               	/* #APP */
 725               	 ;  824 "quantum/quantum.c" 1
 726 0022 1491      		lpm r17, Z
 727               		
 728               	 ;  0 "" 2
 729               	.LVL90:
 730               	/* #NOAPP */
 731               	.LBE45:
 825:quantum/quantum.c ****           unregister_code(keycode);
 732               		.loc 1 825 0
 733 0024 812F      		mov r24,r17
 734               	.LVL91:
 735 0026 0E94 0000 		call register_code
 736               	.LVL92:
 826:quantum/quantum.c ****         } else if (ascii_code == 2) {
 737               		.loc 1 826 0
 738 002a 812F      		mov r24,r17
 739 002c 00C0      		rjmp .L63
 740               	.LVL93:
 741               	.L56:
 742               	.LBE44:
 827:quantum/quantum.c ****           // down
 743               		.loc 1 827 0
 744 002e 8230      		cpi r24,lo8(2)
 745 0030 01F4      		brne .L58
 746               	.LBB46:
 747               	.LBB47:
 829:quantum/quantum.c ****           register_code(keycode);
 748               		.loc 1 829 0
 749 0032 E901      		movw r28,r18
 750               	.LVL94:
 751 0034 F901      		movw r30,r18
 752               	.LVL95:
 753               	/* #APP */
 754               	 ;  829 "quantum/quantum.c" 1
 755 0036 8491      		lpm r24, Z
 756               		
 757               	 ;  0 "" 2
 758               	.LVL96:
 759               	/* #NOAPP */
 760               	.LBE47:
 830:quantum/quantum.c ****         } else if (ascii_code == 3) {
 761               		.loc 1 830 0
 762 0038 0E94 0000 		call register_code
 763               	.LVL97:
 764               	.LBE46:
 765 003c 00C0      		rjmp .L57
 766               	.LVL98:
 767               	.L58:
 831:quantum/quantum.c ****           // up
 768               		.loc 1 831 0
 769 003e 8330      		cpi r24,lo8(3)
 770 0040 01F4      		brne .L59
 771               	.LBB48:
 772               	.LBB49:
 833:quantum/quantum.c ****           unregister_code(keycode);
 773               		.loc 1 833 0
 774 0042 E901      		movw r28,r18
 775               	.LVL99:
 776 0044 F901      		movw r30,r18
 777               	.LVL100:
 778               	/* #APP */
 779               	 ;  833 "quantum/quantum.c" 1
 780 0046 8491      		lpm r24, Z
 781               		
 782               	 ;  0 "" 2
 783               	.LVL101:
 784               	/* #NOAPP */
 785               	.L63:
 786               	.LBE49:
 834:quantum/quantum.c ****         } else {
 787               		.loc 1 834 0
 788 0048 0E94 0000 		call unregister_code
 789               	.LVL102:
 790               	.LBE48:
 791 004c 00C0      		rjmp .L57
 792               	.LVL103:
 793               	.L59:
 836:quantum/quantum.c ****         }
 794               		.loc 1 836 0
 795 004e 0E94 0000 		call send_char
 796               	.LVL104:
 797               	.L57:
 838:quantum/quantum.c ****         // interval
 798               		.loc 1 838 0
 799 0052 2196      		adiw r28,1
 800               	.LVL105:
 801               	.LBB50:
 840:quantum/quantum.c ****     }
 802               		.loc 1 840 0
 803 0054 802F      		mov r24,r16
 804               	.LVL106:
 805               	.L60:
 840:quantum/quantum.c ****     }
 806               		.loc 1 840 0 is_stmt 0 discriminator 1
 807 0056 8823      		tst r24
 808 0058 01F0      		breq .L62
 809               	.LVL107:
 810               	.LBB51:
 811               	.LBB52:
 812               		.loc 2 187 0 is_stmt 1
 813 005a EFE9      		ldi r30,lo8(3999)
 814 005c FFE0      		ldi r31,hi8(3999)
 815 005e 3197      	1:	sbiw r30,1
 816 0060 01F4      		brne 1b
 817 0062 00C0      		rjmp .
 818 0064 0000      		nop
 819 0066 8150      		subi r24,lo8(-(-1))
 820               	.LVL108:
 821 0068 00C0      		rjmp .L60
 822               	.LVL109:
 823               	.L54:
 824               	/* epilogue start */
 825               	.LBE52:
 826               	.LBE51:
 827               	.LBE50:
 828               	.LBE42:
 842:quantum/quantum.c **** 
 829               		.loc 1 842 0
 830 006a DF91      		pop r29
 831 006c CF91      		pop r28
 832               	.LVL110:
 833 006e 1F91      		pop r17
 834 0070 0F91      		pop r16
 835               	.LVL111:
 836 0072 0895      		ret
 837               		.cfi_endproc
 838               	.LFE32:
 840               		.section	.text.send_string_P,"ax",@progbits
 841               	.global	send_string_P
 843               	send_string_P:
 844               	.LFB30:
 788:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 845               		.loc 1 788 0
 846               		.cfi_startproc
 847               	.LVL112:
 848               	/* prologue: function */
 849               	/* frame size = 0 */
 850               	/* stack size = 0 */
 851               	.L__stack_usage = 0
 789:quantum/quantum.c **** }
 852               		.loc 1 789 0
 853 0000 60E0      		ldi r22,0
 854 0002 0C94 0000 		jmp send_string_with_delay_P
 855               	.LVL113:
 856               		.cfi_endproc
 857               	.LFE30:
 859               		.section	.text.set_single_persistent_default_layer,"ax",@progbits
 860               	.global	set_single_persistent_default_layer
 862               	set_single_persistent_default_layer:
 863               	.LFB34:
 857:quantum/quantum.c **** 
 858:quantum/quantum.c **** void set_single_persistent_default_layer(uint8_t default_layer) {
 864               		.loc 1 858 0
 865               		.cfi_startproc
 866               	.LVL114:
 867 0000 CF93      		push r28
 868               	.LCFI18:
 869               		.cfi_def_cfa_offset 3
 870               		.cfi_offset 28, -2
 871 0002 DF93      		push r29
 872               	.LCFI19:
 873               		.cfi_def_cfa_offset 4
 874               		.cfi_offset 29, -3
 875               	/* prologue: function */
 876               	/* frame size = 0 */
 877               	/* stack size = 2 */
 878               	.L__stack_usage = 2
 859:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(DEFAULT_LAYER_SONGS)
 860:quantum/quantum.c ****     PLAY_SONG(default_layer_songs[default_layer]);
 861:quantum/quantum.c ****   #endif
 862:quantum/quantum.c ****   eeconfig_update_default_layer(1U<<default_layer);
 879               		.loc 1 862 0
 880 0004 61E0      		ldi r22,lo8(1)
 881 0006 70E0      		ldi r23,0
 882 0008 EB01      		movw r28,r22
 883 000a 00C0      		rjmp 2f
 884               		1:
 885 000c CC0F      		lsl r28
 886 000e DD1F      		rol r29
 887               		2:
 888 0010 8A95      		dec r24
 889 0012 02F4      		brpl 1b
 890 0014 8C2F      		mov r24,r28
 891               	.LVL115:
 892 0016 0E94 0000 		call eeconfig_update_default_layer
 893               	.LVL116:
 863:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 894               		.loc 1 863 0
 895 001a BE01      		movw r22,r28
 896 001c 80E0      		ldi r24,0
 897 001e 90E0      		ldi r25,0
 898               	/* epilogue start */
 864:quantum/quantum.c **** }
 899               		.loc 1 864 0
 900 0020 DF91      		pop r29
 901 0022 CF91      		pop r28
 863:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 902               		.loc 1 863 0
 903 0024 0C94 0000 		jmp default_layer_set
 904               	.LVL117:
 905               		.cfi_endproc
 906               	.LFE34:
 908               		.section	.text.update_tri_layer_state,"ax",@progbits
 909               	.global	update_tri_layer_state
 911               	update_tri_layer_state:
 912               	.LFB35:
 865:quantum/quantum.c **** 
 866:quantum/quantum.c **** uint32_t update_tri_layer_state(uint32_t state, uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 913               		.loc 1 866 0
 914               		.cfi_startproc
 915               	.LVL118:
 916 0000 8F92      		push r8
 917               	.LCFI20:
 918               		.cfi_def_cfa_offset 3
 919               		.cfi_offset 8, -2
 920 0002 9F92      		push r9
 921               	.LCFI21:
 922               		.cfi_def_cfa_offset 4
 923               		.cfi_offset 9, -3
 924 0004 AF92      		push r10
 925               	.LCFI22:
 926               		.cfi_def_cfa_offset 5
 927               		.cfi_offset 10, -4
 928 0006 BF92      		push r11
 929               	.LCFI23:
 930               		.cfi_def_cfa_offset 6
 931               		.cfi_offset 11, -5
 932 0008 CF92      		push r12
 933               	.LCFI24:
 934               		.cfi_def_cfa_offset 7
 935               		.cfi_offset 12, -6
 936 000a DF92      		push r13
 937               	.LCFI25:
 938               		.cfi_def_cfa_offset 8
 939               		.cfi_offset 13, -7
 940 000c EF92      		push r14
 941               	.LCFI26:
 942               		.cfi_def_cfa_offset 9
 943               		.cfi_offset 14, -8
 944 000e FF92      		push r15
 945               	.LCFI27:
 946               		.cfi_def_cfa_offset 10
 947               		.cfi_offset 15, -9
 948 0010 0F93      		push r16
 949               	.LCFI28:
 950               		.cfi_def_cfa_offset 11
 951               		.cfi_offset 16, -10
 952 0012 1F93      		push r17
 953               	.LCFI29:
 954               		.cfi_def_cfa_offset 12
 955               		.cfi_offset 17, -11
 956               	/* prologue: function */
 957               	/* frame size = 0 */
 958               	/* stack size = 10 */
 959               	.L__stack_usage = 10
 960 0014 6B01      		movw r12,r22
 961 0016 7C01      		movw r14,r24
 867:quantum/quantum.c ****   uint32_t mask12 = (1UL << layer1) | (1UL << layer2);
 962               		.loc 1 867 0
 963 0018 81E0      		ldi r24,lo8(1)
 964 001a 90E0      		ldi r25,0
 965 001c A0E0      		ldi r26,0
 966 001e B0E0      		ldi r27,0
 967 0020 4C01      		movw r8,r24
 968 0022 5D01      		movw r10,r26
 969 0024 00C0      		rjmp 2f
 970               		1:
 971 0026 880C      		lsl r8
 972 0028 991C      		rol r9
 973 002a AA1C      		rol r10
 974 002c BB1C      		rol r11
 975               		2:
 976 002e 4A95      		dec r20
 977 0030 02F4      		brpl 1b
 978 0032 AC01      		movw r20,r24
 979 0034 BD01      		movw r22,r26
 980               	.LVL119:
 981 0036 00C0      		rjmp 2f
 982               		1:
 983 0038 440F      		lsl r20
 984 003a 551F      		rol r21
 985 003c 661F      		rol r22
 986 003e 771F      		rol r23
 987               		2:
 988 0040 2A95      		dec r18
 989 0042 02F4      		brpl 1b
 990 0044 4829      		or r20,r8
 991 0046 5929      		or r21,r9
 992 0048 6A29      		or r22,r10
 993 004a 7B29      		or r23,r11
 994               	.LVL120:
 868:quantum/quantum.c ****   uint32_t mask3 = 1UL << layer3;
 995               		.loc 1 868 0
 996 004c 00C0      		rjmp 2f
 997               		1:
 998 004e 880F      		lsl r24
 999 0050 991F      		rol r25
 1000 0052 AA1F      		rol r26
 1001 0054 BB1F      		rol r27
 1002               		2:
 1003 0056 0A95      		dec r16
 1004 0058 02F4      		brpl 1b
 1005               	.LVL121:
 869:quantum/quantum.c ****   return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 1006               		.loc 1 869 0
 1007 005a 8A01      		movw r16,r20
 1008 005c 9B01      		movw r18,r22
 1009               	.LVL122:
 1010 005e 0C21      		and r16,r12
 1011 0060 1D21      		and r17,r13
 1012 0062 2E21      		and r18,r14
 1013 0064 3F21      		and r19,r15
 1014 0066 0417      		cp r16,r20
 1015 0068 1507      		cpc r17,r21
 1016 006a 2607      		cpc r18,r22
 1017 006c 3707      		cpc r19,r23
 1018 006e 01F4      		brne .L67
 1019               		.loc 1 869 0 is_stmt 0 discriminator 1
 1020 0070 BC01      		movw r22,r24
 1021 0072 CD01      		movw r24,r26
 1022               	.LVL123:
 1023 0074 6C29      		or r22,r12
 1024 0076 7D29      		or r23,r13
 1025 0078 8E29      		or r24,r14
 1026 007a 9F29      		or r25,r15
 1027 007c 00C0      		rjmp .L68
 1028               	.L67:
 1029               		.loc 1 869 0 discriminator 2
 1030 007e 8095      		com r24
 1031 0080 9095      		com r25
 1032 0082 A095      		com r26
 1033 0084 B095      		com r27
 1034               	.LVL124:
 1035 0086 BC01      		movw r22,r24
 1036 0088 CD01      		movw r24,r26
 1037 008a 6C21      		and r22,r12
 1038 008c 7D21      		and r23,r13
 1039 008e 8E21      		and r24,r14
 1040 0090 9F21      		and r25,r15
 1041               	.LVL125:
 1042               	.L68:
 1043               	/* epilogue start */
 870:quantum/quantum.c **** }
 1044               		.loc 1 870 0 is_stmt 1 discriminator 4
 1045 0092 1F91      		pop r17
 1046 0094 0F91      		pop r16
 1047 0096 FF90      		pop r15
 1048 0098 EF90      		pop r14
 1049 009a DF90      		pop r13
 1050 009c CF90      		pop r12
 1051               	.LVL126:
 1052 009e BF90      		pop r11
 1053 00a0 AF90      		pop r10
 1054 00a2 9F90      		pop r9
 1055 00a4 8F90      		pop r8
 1056 00a6 0895      		ret
 1057               		.cfi_endproc
 1058               	.LFE35:
 1060               		.section	.text.update_tri_layer,"ax",@progbits
 1061               	.global	update_tri_layer
 1063               	update_tri_layer:
 1064               	.LFB36:
 871:quantum/quantum.c **** 
 872:quantum/quantum.c **** void update_tri_layer(uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 1065               		.loc 1 872 0
 1066               		.cfi_startproc
 1067               	.LVL127:
 1068 0000 0F93      		push r16
 1069               	.LCFI30:
 1070               		.cfi_def_cfa_offset 3
 1071               		.cfi_offset 16, -2
 1072               	/* prologue: function */
 1073               	/* frame size = 0 */
 1074               	/* stack size = 1 */
 1075               	.L__stack_usage = 1
 1076 0002 382F      		mov r19,r24
 1077 0004 262F      		mov r18,r22
 873:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 1078               		.loc 1 873 0
 1079 0006 6091 0000 		lds r22,layer_state
 1080 000a 7091 0000 		lds r23,layer_state+1
 1081 000e 8091 0000 		lds r24,layer_state+2
 1082 0012 9091 0000 		lds r25,layer_state+3
 1083               	.LVL128:
 1084 0016 042F      		mov r16,r20
 1085 0018 432F      		mov r20,r19
 1086               	.LVL129:
 1087 001a 0E94 0000 		call update_tri_layer_state
 1088               	.LVL130:
 1089               	/* epilogue start */
 874:quantum/quantum.c **** }
 1090               		.loc 1 874 0
 1091 001e 0F91      		pop r16
 1092               	.LVL131:
 873:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 1093               		.loc 1 873 0
 1094 0020 0C94 0000 		jmp layer_state_set
 1095               	.LVL132:
 1096               		.cfi_endproc
 1097               	.LFE36:
 1099               		.section	.text.tap_random_base64,"ax",@progbits
 1100               	.global	tap_random_base64
 1102               	tap_random_base64:
 1103               	.LFB37:
 875:quantum/quantum.c **** 
 876:quantum/quantum.c **** void tap_random_base64(void) {
 1104               		.loc 1 876 0
 1105               		.cfi_startproc
 1106 0000 CF93      		push r28
 1107               	.LCFI31:
 1108               		.cfi_def_cfa_offset 3
 1109               		.cfi_offset 28, -2
 1110 0002 DF93      		push r29
 1111               	.LCFI32:
 1112               		.cfi_def_cfa_offset 4
 1113               		.cfi_offset 29, -3
 1114               	/* prologue: function */
 1115               	/* frame size = 0 */
 1116               	/* stack size = 2 */
 1117               	.L__stack_usage = 2
 877:quantum/quantum.c ****   #if defined(__AVR_ATmega32U4__)
 878:quantum/quantum.c ****     uint8_t key = (TCNT0 + TCNT1 + TCNT3 + TCNT4) % 64;
 1118               		.loc 1 878 0
 1119 0004 26B5      		in r18,0x26
 1120 0006 C091 8400 		lds r28,132
 1121 000a D091 8500 		lds r29,132+1
 1122 000e 4091 9400 		lds r20,148
 1123 0012 5091 9500 		lds r21,148+1
 1124 0016 8091 BE00 		lds r24,190
 1125 001a 9091 BF00 		lds r25,190+1
 1126 001e C40F      		add r28,r20
 1127 0020 C20F      		add r28,r18
 1128 0022 8C0F      		add r24,r28
 1129 0024 C82F      		mov r28,r24
 1130 0026 CF73      		andi r28,lo8(63)
 1131               	.LVL133:
 879:quantum/quantum.c ****   #else
 880:quantum/quantum.c ****     uint8_t key = rand() % 64;
 881:quantum/quantum.c ****   #endif
 882:quantum/quantum.c ****   switch (key) {
 1132               		.loc 1 882 0
 1133 0028 CE33      		cpi r28,lo8(62)
 1134 002a 00F4      		brsh .L72
 1135 002c C533      		cpi r28,lo8(53)
 1136 002e 00F4      		brsh .L73
 1137 0030 CA31      		cpi r28,lo8(26)
 1138 0032 00F0      		brlo .L71
 1139 0034 C433      		cpi r28,lo8(52)
 1140 0036 00F4      		brsh .L78
 883:quantum/quantum.c ****     case 0 ... 25:
 884:quantum/quantum.c ****       register_code(KC_LSFT);
 885:quantum/quantum.c ****       register_code(key + KC_A);
 886:quantum/quantum.c ****       unregister_code(key + KC_A);
 887:quantum/quantum.c ****       unregister_code(KC_LSFT);
 888:quantum/quantum.c ****       break;
 889:quantum/quantum.c ****     case 26 ... 51:
 890:quantum/quantum.c ****       register_code(key - 26 + KC_A);
 1141               		.loc 1 890 0
 1142 0038 C651      		subi r28,lo8(-(-22))
 1143               	.LVL134:
 1144 003a 00C0      		rjmp .L81
 1145               	.LVL135:
 1146               	.L72:
 882:quantum/quantum.c ****     case 0 ... 25:
 1147               		.loc 1 882 0
 1148 003c CE33      		cpi r28,lo8(62)
 1149 003e 01F0      		breq .L76
 1150 0040 CF33      		cpi r28,lo8(63)
 1151 0042 01F0      		breq .L77
 1152               	.L71:
 884:quantum/quantum.c ****       register_code(key + KC_A);
 1153               		.loc 1 884 0
 1154 0044 81EE      		ldi r24,lo8(-31)
 1155 0046 0E94 0000 		call register_code
 1156               	.LVL136:
 885:quantum/quantum.c ****       unregister_code(key + KC_A);
 1157               		.loc 1 885 0
 1158 004a CC5F      		subi r28,lo8(-(4))
 1159               	.LVL137:
 1160 004c 8C2F      		mov r24,r28
 1161 004e 0E94 0000 		call register_code
 1162               	.LVL138:
 886:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1163               		.loc 1 886 0
 1164 0052 8C2F      		mov r24,r28
 1165 0054 00C0      		rjmp .L80
 1166               	.LVL139:
 1167               	.L78:
 891:quantum/quantum.c ****       unregister_code(key - 26 + KC_A);
 892:quantum/quantum.c ****       break;
 893:quantum/quantum.c ****     case 52:
 894:quantum/quantum.c ****       register_code(KC_0);
 1168               		.loc 1 894 0
 1169 0056 87E2      		ldi r24,lo8(39)
 1170 0058 0E94 0000 		call register_code
 1171               	.LVL140:
 895:quantum/quantum.c ****       unregister_code(KC_0);
 1172               		.loc 1 895 0
 1173 005c 87E2      		ldi r24,lo8(39)
 1174 005e 00C0      		rjmp .L79
 1175               	.L73:
 896:quantum/quantum.c ****       break;
 897:quantum/quantum.c ****     case 53 ... 61:
 898:quantum/quantum.c ****       register_code(key - 53 + KC_1);
 1176               		.loc 1 898 0
 1177 0060 C751      		subi r28,lo8(-(-23))
 1178               	.LVL141:
 1179               	.L81:
 1180 0062 8C2F      		mov r24,r28
 1181               	.LVL142:
 1182 0064 0E94 0000 		call register_code
 1183               	.LVL143:
 899:quantum/quantum.c ****       unregister_code(key - 53 + KC_1);
 1184               		.loc 1 899 0
 1185 0068 8C2F      		mov r24,r28
 1186 006a 00C0      		rjmp .L79
 1187               	.LVL144:
 1188               	.L76:
 900:quantum/quantum.c ****       break;
 901:quantum/quantum.c ****     case 62:
 902:quantum/quantum.c ****       register_code(KC_LSFT);
 1189               		.loc 1 902 0
 1190 006c 81EE      		ldi r24,lo8(-31)
 1191 006e 0E94 0000 		call register_code
 1192               	.LVL145:
 903:quantum/quantum.c ****       register_code(KC_EQL);
 1193               		.loc 1 903 0
 1194 0072 8EE2      		ldi r24,lo8(46)
 1195 0074 0E94 0000 		call register_code
 1196               	.LVL146:
 904:quantum/quantum.c ****       unregister_code(KC_EQL);
 1197               		.loc 1 904 0
 1198 0078 8EE2      		ldi r24,lo8(46)
 1199               	.LVL147:
 1200               	.L80:
 1201 007a 0E94 0000 		call unregister_code
 1202               	.LVL148:
 905:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1203               		.loc 1 905 0
 1204 007e 81EE      		ldi r24,lo8(-31)
 1205 0080 00C0      		rjmp .L79
 1206               	.LVL149:
 1207               	.L77:
 906:quantum/quantum.c ****       break;
 907:quantum/quantum.c ****     case 63:
 908:quantum/quantum.c ****       register_code(KC_SLSH);
 1208               		.loc 1 908 0
 1209 0082 88E3      		ldi r24,lo8(56)
 1210 0084 0E94 0000 		call register_code
 1211               	.LVL150:
 909:quantum/quantum.c ****       unregister_code(KC_SLSH);
 1212               		.loc 1 909 0
 1213 0088 88E3      		ldi r24,lo8(56)
 1214               	.LVL151:
 1215               	.L79:
 1216               	/* epilogue start */
 910:quantum/quantum.c ****       break;
 911:quantum/quantum.c ****   }
 912:quantum/quantum.c **** }
 1217               		.loc 1 912 0
 1218 008a DF91      		pop r29
 1219 008c CF91      		pop r28
 909:quantum/quantum.c ****       unregister_code(KC_SLSH);
 1220               		.loc 1 909 0
 1221 008e 0C94 0000 		jmp unregister_code
 1222               	.LVL152:
 1223               		.cfi_endproc
 1224               	.LFE37:
 1226               		.section	.text.matrix_scan_quantum,"ax",@progbits
 1227               	.global	matrix_scan_quantum
 1229               	matrix_scan_quantum:
 1230               	.LFB39:
 913:quantum/quantum.c **** 
 914:quantum/quantum.c **** void matrix_init_quantum() {
 915:quantum/quantum.c ****   #ifdef BACKLIGHT_ENABLE
 916:quantum/quantum.c ****     backlight_init_ports();
 917:quantum/quantum.c ****   #endif
 918:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 919:quantum/quantum.c ****     audio_init();
 920:quantum/quantum.c ****   #endif
 921:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
 922:quantum/quantum.c ****     rgb_matrix_init();
 923:quantum/quantum.c ****   #endif
 924:quantum/quantum.c ****   matrix_init_kb();
 925:quantum/quantum.c **** }
 926:quantum/quantum.c **** 
 927:quantum/quantum.c **** uint8_t rgb_matrix_task_counter = 0;
 928:quantum/quantum.c **** 
 929:quantum/quantum.c **** #ifndef RGB_MATRIX_SKIP_FRAMES
 930:quantum/quantum.c ****   #define RGB_MATRIX_SKIP_FRAMES 1
 931:quantum/quantum.c **** #endif
 932:quantum/quantum.c **** 
 933:quantum/quantum.c **** void matrix_scan_quantum() {
 1231               		.loc 1 933 0
 1232               		.cfi_startproc
 1233               	/* prologue: function */
 1234               	/* frame size = 0 */
 1235               	/* stack size = 0 */
 1236               	.L__stack_usage = 0
 934:quantum/quantum.c ****   #if defined(AUDIO_ENABLE)
 935:quantum/quantum.c ****     matrix_scan_music();
 1237               		.loc 1 935 0
 1238 0000 0E94 0000 		call matrix_scan_music
 1239               	.LVL153:
 936:quantum/quantum.c ****   #endif
 937:quantum/quantum.c **** 
 938:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 939:quantum/quantum.c ****     matrix_scan_tap_dance();
 940:quantum/quantum.c ****   #endif
 941:quantum/quantum.c **** 
 942:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 943:quantum/quantum.c ****     matrix_scan_combo();
 944:quantum/quantum.c ****   #endif
 945:quantum/quantum.c **** 
 946:quantum/quantum.c ****   #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
 947:quantum/quantum.c ****     backlight_task();
 948:quantum/quantum.c ****   #endif
 949:quantum/quantum.c **** 
 950:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
 951:quantum/quantum.c ****     rgb_matrix_task();
 952:quantum/quantum.c ****     if (rgb_matrix_task_counter == 0) {
 953:quantum/quantum.c ****       rgb_matrix_update_pwm_buffers();
 954:quantum/quantum.c ****     }
 955:quantum/quantum.c ****     rgb_matrix_task_counter = ((rgb_matrix_task_counter + 1) % (RGB_MATRIX_SKIP_FRAMES + 1));
 956:quantum/quantum.c ****   #endif
 957:quantum/quantum.c **** 
 958:quantum/quantum.c ****   matrix_scan_kb();
 1240               		.loc 1 958 0
 1241 0004 0C94 0000 		jmp matrix_scan_kb
 1242               	.LVL154:
 1243               		.cfi_endproc
 1244               	.LFE39:
 1246               		.section	.text.backlight_set,"ax",@progbits
 1247               		.weak	backlight_set
 1249               	backlight_set:
 1250               	.LFB42:
 959:quantum/quantum.c **** }
 960:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
 961:quantum/quantum.c **** 
 962:quantum/quantum.c **** static const uint8_t backlight_pin = BACKLIGHT_PIN;
 963:quantum/quantum.c **** 
 964:quantum/quantum.c **** // depending on the pin, we use a different output compare unit
 965:quantum/quantum.c **** #if BACKLIGHT_PIN == B7
 966:quantum/quantum.c **** #  define TCCRxA TCCR1A
 967:quantum/quantum.c **** #  define TCCRxB TCCR1B
 968:quantum/quantum.c **** #  define COMxx1 COM1C1
 969:quantum/quantum.c **** #  define OCRxx  OCR1C
 970:quantum/quantum.c **** #  define ICRx   ICR1
 971:quantum/quantum.c **** #elif BACKLIGHT_PIN == B6
 972:quantum/quantum.c **** #  define TCCRxA TCCR1A
 973:quantum/quantum.c **** #  define TCCRxB TCCR1B
 974:quantum/quantum.c **** #  define COMxx1 COM1B1
 975:quantum/quantum.c **** #  define OCRxx  OCR1B
 976:quantum/quantum.c **** #  define ICRx   ICR1
 977:quantum/quantum.c **** #elif BACKLIGHT_PIN == B5
 978:quantum/quantum.c **** #  define TCCRxA TCCR1A
 979:quantum/quantum.c **** #  define TCCRxB TCCR1B
 980:quantum/quantum.c **** #  define COMxx1 COM1A1
 981:quantum/quantum.c **** #  define OCRxx  OCR1A
 982:quantum/quantum.c **** #  define ICRx   ICR1
 983:quantum/quantum.c **** #elif BACKLIGHT_PIN == C6
 984:quantum/quantum.c **** #  define TCCRxA TCCR3A
 985:quantum/quantum.c **** #  define TCCRxB TCCR3B
 986:quantum/quantum.c **** #  define COMxx1 COM1A1
 987:quantum/quantum.c **** #  define OCRxx  OCR3A
 988:quantum/quantum.c **** #  define ICRx   ICR3
 989:quantum/quantum.c **** #else
 990:quantum/quantum.c **** #  define NO_HARDWARE_PWM
 991:quantum/quantum.c **** #endif
 992:quantum/quantum.c **** 
 993:quantum/quantum.c **** #ifndef BACKLIGHT_ON_STATE
 994:quantum/quantum.c **** #define BACKLIGHT_ON_STATE 0
 995:quantum/quantum.c **** #endif
 996:quantum/quantum.c **** 
 997:quantum/quantum.c **** #ifdef NO_HARDWARE_PWM // pwm through software
 998:quantum/quantum.c **** 
 999:quantum/quantum.c **** __attribute__ ((weak))
1000:quantum/quantum.c **** void backlight_init_ports(void)
1001:quantum/quantum.c **** {
1002:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
1003:quantum/quantum.c ****   // DDRx |= n
1004:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
1005:quantum/quantum.c ****   #if BACKLIGHT_ON_STATE == 0
1006:quantum/quantum.c ****     // PORTx &= ~n
1007:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
1008:quantum/quantum.c ****   #else
1009:quantum/quantum.c ****     // PORTx |= n
1010:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
1011:quantum/quantum.c ****   #endif
1012:quantum/quantum.c **** }
1013:quantum/quantum.c **** 
1014:quantum/quantum.c **** __attribute__ ((weak))
1015:quantum/quantum.c **** void backlight_set(uint8_t level) {}
1016:quantum/quantum.c **** 
1017:quantum/quantum.c **** uint8_t backlight_tick = 0;
1018:quantum/quantum.c **** 
1019:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
1020:quantum/quantum.c **** void backlight_task(void) {
1021:quantum/quantum.c ****   if ((0xFFFF >> ((BACKLIGHT_LEVELS - get_backlight_level()) * ((BACKLIGHT_LEVELS + 1) / 2))) & (1 
1022:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
1023:quantum/quantum.c ****       // PORTx &= ~n
1024:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
1025:quantum/quantum.c ****     #else
1026:quantum/quantum.c ****       // PORTx |= n
1027:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
1028:quantum/quantum.c ****     #endif
1029:quantum/quantum.c ****   } else {
1030:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
1031:quantum/quantum.c ****       // PORTx |= n
1032:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
1033:quantum/quantum.c ****     #else
1034:quantum/quantum.c ****       // PORTx &= ~n
1035:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
1036:quantum/quantum.c ****     #endif
1037:quantum/quantum.c ****   }
1038:quantum/quantum.c ****   backlight_tick = (backlight_tick + 1) % 16;
1039:quantum/quantum.c **** }
1040:quantum/quantum.c **** #endif
1041:quantum/quantum.c **** 
1042:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
1043:quantum/quantum.c ****   #ifndef BACKLIGHT_CUSTOM_DRIVER
1044:quantum/quantum.c ****   #error "Backlight breathing only available with hardware PWM. Please disable."
1045:quantum/quantum.c ****   #endif
1046:quantum/quantum.c **** #endif
1047:quantum/quantum.c **** 
1048:quantum/quantum.c **** #else // pwm through timer
1049:quantum/quantum.c **** 
1050:quantum/quantum.c **** #define TIMER_TOP 0xFFFFU
1051:quantum/quantum.c **** 
1052:quantum/quantum.c **** // See http://jared.geek.nz/2013/feb/linear-led-pwm
1053:quantum/quantum.c **** static uint16_t cie_lightness(uint16_t v) {
1054:quantum/quantum.c ****   if (v <= 5243) // if below 8% of max
1055:quantum/quantum.c ****     return v / 9; // same as dividing by 900%
1056:quantum/quantum.c ****   else {
1057:quantum/quantum.c ****     uint32_t y = (((uint32_t) v + 10486) << 8) / (10486 + 0xFFFFUL); // add 16% of max and compare
1058:quantum/quantum.c ****     // to get a useful result with integer division, we shift left in the expression above
1059:quantum/quantum.c ****     // and revert what we've done again after squaring.
1060:quantum/quantum.c ****     y = y * y * y >> 8;
1061:quantum/quantum.c ****     if (y > 0xFFFFUL) // prevent overflow
1062:quantum/quantum.c ****       return 0xFFFFU;
1063:quantum/quantum.c ****     else
1064:quantum/quantum.c ****       return (uint16_t) y;
1065:quantum/quantum.c ****   }
1066:quantum/quantum.c **** }
1067:quantum/quantum.c **** 
1068:quantum/quantum.c **** // range for val is [0..TIMER_TOP]. PWM pin is high while the timer count is below val.
1069:quantum/quantum.c **** static inline void set_pwm(uint16_t val) {
1070:quantum/quantum.c **** 	OCRxx = val;
1071:quantum/quantum.c **** }
1072:quantum/quantum.c **** 
1073:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
1074:quantum/quantum.c **** __attribute__ ((weak))
1075:quantum/quantum.c **** void backlight_set(uint8_t level) {
 1251               		.loc 1 1075 0
 1252               		.cfi_startproc
 1253               	.LVL155:
 1254 0000 CF92      		push r12
 1255               	.LCFI33:
 1256               		.cfi_def_cfa_offset 3
 1257               		.cfi_offset 12, -2
 1258 0002 DF92      		push r13
 1259               	.LCFI34:
 1260               		.cfi_def_cfa_offset 4
 1261               		.cfi_offset 13, -3
 1262 0004 EF92      		push r14
 1263               	.LCFI35:
 1264               		.cfi_def_cfa_offset 5
 1265               		.cfi_offset 14, -4
 1266 0006 FF92      		push r15
 1267               	.LCFI36:
 1268               		.cfi_def_cfa_offset 6
 1269               		.cfi_offset 15, -5
 1270               	/* prologue: function */
 1271               	/* frame size = 0 */
 1272               	/* stack size = 4 */
 1273               	.L__stack_usage = 4
1076:quantum/quantum.c ****   if (level > BACKLIGHT_LEVELS)
 1274               		.loc 1 1076 0
 1275 0008 8530      		cpi r24,lo8(5)
 1276 000a 00F4      		brsh .L88
1077:quantum/quantum.c ****     level = BACKLIGHT_LEVELS;
1078:quantum/quantum.c **** 
1079:quantum/quantum.c ****   if (level == 0) {
 1277               		.loc 1 1079 0
 1278 000c 8111      		cpse r24,__zero_reg__
 1279 000e 00C0      		rjmp .L84
1080:quantum/quantum.c ****     // Turn off PWM control on backlight pin
1081:quantum/quantum.c ****     TCCRxA &= ~(_BV(COMxx1));
 1280               		.loc 1 1081 0
 1281 0010 9091 8000 		lds r25,128
 1282 0014 9F7D      		andi r25,lo8(-33)
 1283 0016 00C0      		rjmp .L90
 1284               	.L88:
1077:quantum/quantum.c ****     level = BACKLIGHT_LEVELS;
 1285               		.loc 1 1077 0
 1286 0018 84E0      		ldi r24,lo8(4)
 1287               	.LVL156:
 1288               	.L84:
1082:quantum/quantum.c ****   } else {
1083:quantum/quantum.c ****     // Turn on PWM control of backlight pin
1084:quantum/quantum.c ****     TCCRxA |= _BV(COMxx1);
 1289               		.loc 1 1084 0
 1290 001a 9091 8000 		lds r25,128
 1291 001e 9062      		ori r25,lo8(32)
 1292               	.L90:
 1293 0020 9093 8000 		sts 128,r25
1085:quantum/quantum.c ****   }
1086:quantum/quantum.c ****   // Set the brightness
1087:quantum/quantum.c ****   set_pwm(cie_lightness(TIMER_TOP * (uint32_t)level / BACKLIGHT_LEVELS));
 1294               		.loc 1 1087 0
 1295 0024 282F      		mov r18,r24
 1296 0026 30E0      		ldi r19,0
 1297 0028 AFEF      		ldi r26,lo8(-1)
 1298 002a BFEF      		ldi r27,lo8(-1)
 1299 002c 0E94 0000 		call __umulhisi3
 1300 0030 DC01      		movw r26,r24
 1301 0032 CB01      		movw r24,r22
 1302               	.LVL157:
 1303 0034 42E0      		ldi r20,2
 1304               		1:
 1305 0036 B695      		lsr r27
 1306 0038 A795      		ror r26
 1307 003a 9795      		ror r25
 1308 003c 8795      		ror r24
 1309 003e 4A95      		dec r20
 1310 0040 01F4      		brne 1b
 1311               	.LVL158:
 1312               	.LBB58:
 1313               	.LBB59:
1054:quantum/quantum.c ****     return v / 9; // same as dividing by 900%
 1314               		.loc 1 1054 0
 1315 0042 8C37      		cpi r24,124
 1316 0044 24E1      		ldi r18,20
 1317 0046 9207      		cpc r25,r18
 1318 0048 A105      		cpc r26,__zero_reg__
 1319 004a B105      		cpc r27,__zero_reg__
 1320               	.LVL159:
 1321 004c 00F4      		brsh .L86
1055:quantum/quantum.c ****   else {
 1322               		.loc 1 1055 0
 1323 004e 69E0      		ldi r22,lo8(9)
 1324 0050 70E0      		ldi r23,0
 1325 0052 0E94 0000 		call __udivmodhi4
 1326               	.LVL160:
 1327 0056 00C0      		rjmp .L87
 1328               	.LVL161:
 1329               	.L86:
 1330               	.LBB60:
1057:quantum/quantum.c ****     // to get a useful result with integer division, we shift left in the expression above
 1331               		.loc 1 1057 0
 1332 0058 8A50      		subi r24,10
 1333 005a 974D      		sbci r25,-41
 1334 005c AF4F      		sbci r26,-1
 1335 005e BF4F      		sbci r27,-1
 1336               	.LVL162:
 1337 0060 6627      		clr r22
 1338 0062 782F      		mov r23,r24
 1339 0064 892F      		mov r24,r25
 1340 0066 9A2F      		mov r25,r26
 1341 0068 25EF      		ldi r18,lo8(-11)
 1342 006a 38E2      		ldi r19,lo8(40)
 1343 006c 41E0      		ldi r20,lo8(1)
 1344 006e 50E0      		ldi r21,0
 1345 0070 0E94 0000 		call __udivmodsi4
 1346 0074 6901      		movw r12,r18
 1347 0076 7A01      		movw r14,r20
 1348               	.LVL163:
1060:quantum/quantum.c ****     if (y > 0xFFFFUL) // prevent overflow
 1349               		.loc 1 1060 0
 1350 0078 CA01      		movw r24,r20
 1351 007a B901      		movw r22,r18
 1352 007c 0E94 0000 		call __mulsi3
 1353 0080 9B01      		movw r18,r22
 1354 0082 AC01      		movw r20,r24
 1355 0084 C701      		movw r24,r14
 1356 0086 B601      		movw r22,r12
 1357 0088 0E94 0000 		call __mulsi3
 1358 008c BB27      		clr r27
 1359 008e A92F      		mov r26,r25
 1360 0090 982F      		mov r25,r24
 1361 0092 872F      		mov r24,r23
 1362               	.LVL164:
1061:quantum/quantum.c ****       return 0xFFFFU;
 1363               		.loc 1 1061 0
 1364 0094 0097      		sbiw r24,0
 1365 0096 21E0      		ldi r18,1
 1366 0098 A207      		cpc r26,r18
 1367 009a B105      		cpc r27,__zero_reg__
 1368 009c 01F0      		breq .L89
1064:quantum/quantum.c ****   }
 1369               		.loc 1 1064 0
 1370 009e BC01      		movw r22,r24
 1371 00a0 00C0      		rjmp .L87
 1372               	.L89:
1062:quantum/quantum.c ****     else
 1373               		.loc 1 1062 0
 1374 00a2 6FEF      		ldi r22,lo8(-1)
 1375 00a4 7FEF      		ldi r23,lo8(-1)
 1376               	.LVL165:
 1377               	.L87:
 1378               	.LBE60:
 1379               	.LBE59:
 1380               	.LBE58:
 1381               	.LBB61:
 1382               	.LBB62:
1070:quantum/quantum.c **** }
 1383               		.loc 1 1070 0
 1384 00a6 7093 8B00 		sts 138+1,r23
 1385 00aa 6093 8A00 		sts 138,r22
 1386               	/* epilogue start */
 1387               	.LBE62:
 1388               	.LBE61:
1088:quantum/quantum.c **** }
 1389               		.loc 1 1088 0
 1390 00ae FF90      		pop r15
 1391 00b0 EF90      		pop r14
 1392 00b2 DF90      		pop r13
 1393 00b4 CF90      		pop r12
 1394 00b6 0895      		ret
 1395               		.cfi_endproc
 1396               	.LFE42:
 1398               		.section	.text.backlight_task,"ax",@progbits
 1399               	.global	backlight_task
 1401               	backlight_task:
 1402               	.LFB43:
1089:quantum/quantum.c **** 
1090:quantum/quantum.c **** void backlight_task(void) {}
 1403               		.loc 1 1090 0
 1404               		.cfi_startproc
 1405               	/* prologue: function */
 1406               	/* frame size = 0 */
 1407               	/* stack size = 0 */
 1408               	.L__stack_usage = 0
 1409 0000 0895      		ret
 1410               		.cfi_endproc
 1411               	.LFE43:
 1413               		.section	.text.backlight_init_ports,"ax",@progbits
 1414               		.weak	backlight_init_ports
 1416               	backlight_init_ports:
 1417               	.LFB44:
1091:quantum/quantum.c **** #endif  // BACKLIGHT_CUSTOM_DRIVER
1092:quantum/quantum.c **** 
1093:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
1094:quantum/quantum.c **** 
1095:quantum/quantum.c **** #define BREATHING_NO_HALT  0
1096:quantum/quantum.c **** #define BREATHING_HALT_OFF 1
1097:quantum/quantum.c **** #define BREATHING_HALT_ON  2
1098:quantum/quantum.c **** #define BREATHING_STEPS 128
1099:quantum/quantum.c **** 
1100:quantum/quantum.c **** static uint8_t breathing_period = BREATHING_PERIOD;
1101:quantum/quantum.c **** static uint8_t breathing_halt = BREATHING_NO_HALT;
1102:quantum/quantum.c **** static uint16_t breathing_counter = 0;
1103:quantum/quantum.c **** 
1104:quantum/quantum.c **** bool is_breathing(void) {
1105:quantum/quantum.c ****     return !!(TIMSK1 & _BV(TOIE1));
1106:quantum/quantum.c **** }
1107:quantum/quantum.c **** 
1108:quantum/quantum.c **** #define breathing_interrupt_enable() do {TIMSK1 |= _BV(TOIE1);} while (0)
1109:quantum/quantum.c **** #define breathing_interrupt_disable() do {TIMSK1 &= ~_BV(TOIE1);} while (0)
1110:quantum/quantum.c **** #define breathing_min() do {breathing_counter = 0;} while (0)
1111:quantum/quantum.c **** #define breathing_max() do {breathing_counter = breathing_period * 244 / 2;} while (0)
1112:quantum/quantum.c **** 
1113:quantum/quantum.c **** void breathing_enable(void)
1114:quantum/quantum.c **** {
1115:quantum/quantum.c ****   breathing_counter = 0;
1116:quantum/quantum.c ****   breathing_halt = BREATHING_NO_HALT;
1117:quantum/quantum.c ****   breathing_interrupt_enable();
1118:quantum/quantum.c **** }
1119:quantum/quantum.c **** 
1120:quantum/quantum.c **** void breathing_pulse(void)
1121:quantum/quantum.c **** {
1122:quantum/quantum.c ****     if (get_backlight_level() == 0)
1123:quantum/quantum.c ****       breathing_min();
1124:quantum/quantum.c ****     else
1125:quantum/quantum.c ****       breathing_max();
1126:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1127:quantum/quantum.c ****     breathing_interrupt_enable();
1128:quantum/quantum.c **** }
1129:quantum/quantum.c **** 
1130:quantum/quantum.c **** void breathing_disable(void)
1131:quantum/quantum.c **** {
1132:quantum/quantum.c ****     breathing_interrupt_disable();
1133:quantum/quantum.c ****     // Restore backlight level
1134:quantum/quantum.c ****     backlight_set(get_backlight_level());
1135:quantum/quantum.c **** }
1136:quantum/quantum.c **** 
1137:quantum/quantum.c **** void breathing_self_disable(void)
1138:quantum/quantum.c **** {
1139:quantum/quantum.c ****   if (get_backlight_level() == 0)
1140:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_OFF;
1141:quantum/quantum.c ****   else
1142:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1143:quantum/quantum.c **** }
1144:quantum/quantum.c **** 
1145:quantum/quantum.c **** void breathing_toggle(void) {
1146:quantum/quantum.c ****   if (is_breathing())
1147:quantum/quantum.c ****     breathing_disable();
1148:quantum/quantum.c ****   else
1149:quantum/quantum.c ****     breathing_enable();
1150:quantum/quantum.c **** }
1151:quantum/quantum.c **** 
1152:quantum/quantum.c **** void breathing_period_set(uint8_t value)
1153:quantum/quantum.c **** {
1154:quantum/quantum.c ****   if (!value)
1155:quantum/quantum.c ****     value = 1;
1156:quantum/quantum.c ****   breathing_period = value;
1157:quantum/quantum.c **** }
1158:quantum/quantum.c **** 
1159:quantum/quantum.c **** void breathing_period_default(void) {
1160:quantum/quantum.c ****   breathing_period_set(BREATHING_PERIOD);
1161:quantum/quantum.c **** }
1162:quantum/quantum.c **** 
1163:quantum/quantum.c **** void breathing_period_inc(void)
1164:quantum/quantum.c **** {
1165:quantum/quantum.c ****   breathing_period_set(breathing_period+1);
1166:quantum/quantum.c **** }
1167:quantum/quantum.c **** 
1168:quantum/quantum.c **** void breathing_period_dec(void)
1169:quantum/quantum.c **** {
1170:quantum/quantum.c ****   breathing_period_set(breathing_period-1);
1171:quantum/quantum.c **** }
1172:quantum/quantum.c **** 
1173:quantum/quantum.c **** /* To generate breathing curve in python:
1174:quantum/quantum.c ****  * from math import sin, pi; [int(sin(x/128.0*pi)**4*255) for x in range(128)]
1175:quantum/quantum.c ****  */
1176:quantum/quantum.c **** static const uint8_t breathing_table[BREATHING_STEPS] PROGMEM = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
1177:quantum/quantum.c **** 
1178:quantum/quantum.c **** // Use this before the cie_lightness function.
1179:quantum/quantum.c **** static inline uint16_t scale_backlight(uint16_t v) {
1180:quantum/quantum.c ****   return v / BACKLIGHT_LEVELS * get_backlight_level();
1181:quantum/quantum.c **** }
1182:quantum/quantum.c **** 
1183:quantum/quantum.c **** /* Assuming a 16MHz CPU clock and a timer that resets at 64k (ICR1), the following interrupt handle
1184:quantum/quantum.c ****  * about 244 times per second.
1185:quantum/quantum.c ****  */
1186:quantum/quantum.c **** ISR(TIMER1_OVF_vect)
1187:quantum/quantum.c **** {
1188:quantum/quantum.c ****   uint16_t interval = (uint16_t) breathing_period * 244 / BREATHING_STEPS;
1189:quantum/quantum.c ****   // resetting after one period to prevent ugly reset at overflow.
1190:quantum/quantum.c ****   breathing_counter = (breathing_counter + 1) % (breathing_period * 244);
1191:quantum/quantum.c ****   uint8_t index = breathing_counter / interval % BREATHING_STEPS;
1192:quantum/quantum.c **** 
1193:quantum/quantum.c ****   if (((breathing_halt == BREATHING_HALT_ON) && (index == BREATHING_STEPS / 2)) ||
1194:quantum/quantum.c ****       ((breathing_halt == BREATHING_HALT_OFF) && (index == BREATHING_STEPS - 1)))
1195:quantum/quantum.c ****   {
1196:quantum/quantum.c ****       breathing_interrupt_disable();
1197:quantum/quantum.c ****   }
1198:quantum/quantum.c **** 
1199:quantum/quantum.c ****   set_pwm(cie_lightness(scale_backlight((uint16_t) pgm_read_byte(&breathing_table[index]) * 0x0101U
1200:quantum/quantum.c **** }
1201:quantum/quantum.c **** 
1202:quantum/quantum.c **** #endif // BACKLIGHT_BREATHING
1203:quantum/quantum.c **** 
1204:quantum/quantum.c **** __attribute__ ((weak))
1205:quantum/quantum.c **** void backlight_init_ports(void)
1206:quantum/quantum.c **** {
 1418               		.loc 1 1206 0
 1419               		.cfi_startproc
 1420               	/* prologue: function */
 1421               	/* frame size = 0 */
 1422               	/* stack size = 0 */
 1423               	.L__stack_usage = 0
1207:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
1208:quantum/quantum.c ****   // DDRx |= n
1209:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
 1424               		.loc 1 1209 0
 1425 0000 269A      		sbi 0x4,6
1210:quantum/quantum.c ****   #if BACKLIGHT_ON_STATE == 0
1211:quantum/quantum.c ****     // PORTx &= ~n
1212:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 1426               		.loc 1 1212 0
 1427 0002 2E98      		cbi 0x5,6
1213:quantum/quantum.c ****   #else
1214:quantum/quantum.c ****     // PORTx |= n
1215:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
1216:quantum/quantum.c ****   #endif
1217:quantum/quantum.c ****   // I could write a wall of text here to explain... but TL;DW
1218:quantum/quantum.c ****   // Go read the ATmega32u4 datasheet.
1219:quantum/quantum.c ****   // And this: http://blog.saikoled.com/post/43165849837/secret-konami-cheat-code-to-high-resolutio
1220:quantum/quantum.c **** 
1221:quantum/quantum.c ****   // Pin PB7 = OCR1C (Timer 1, Channel C)
1222:quantum/quantum.c ****   // Compare Output Mode = Clear on compare match, Channel C = COM1C1=1 COM1C0=0
1223:quantum/quantum.c ****   // (i.e. start high, go low when counter matches.)
1224:quantum/quantum.c ****   // WGM Mode 14 (Fast PWM) = WGM13=1 WGM12=1 WGM11=1 WGM10=0
1225:quantum/quantum.c ****   // Clock Select = clk/1 (no prescaling) = CS12=0 CS11=0 CS10=1
1226:quantum/quantum.c **** 
1227:quantum/quantum.c ****   /*
1228:quantum/quantum.c ****   14.8.3:
1229:quantum/quantum.c ****   "In fast PWM mode, the compare units allow generation of PWM waveforms on the OCnx pins. Setting 
1230:quantum/quantum.c ****   "In fast PWM mode the counter is incremented until the counter value matches either one of the fi
1231:quantum/quantum.c ****   */
1232:quantum/quantum.c ****   TCCRxA = _BV(COMxx1) | _BV(WGM11); // = 0b00001010;
 1428               		.loc 1 1232 0
 1429 0004 82E2      		ldi r24,lo8(34)
 1430 0006 8093 8000 		sts 128,r24
1233:quantum/quantum.c ****   TCCRxB = _BV(WGM13) | _BV(WGM12) | _BV(CS10); // = 0b00011001;
 1431               		.loc 1 1233 0
 1432 000a 89E1      		ldi r24,lo8(25)
 1433 000c 8093 8100 		sts 129,r24
1234:quantum/quantum.c ****   // Use full 16-bit resolution. Counter counts to ICR1 before reset to 0.
1235:quantum/quantum.c ****   ICRx = TIMER_TOP;
 1434               		.loc 1 1235 0
 1435 0010 8FEF      		ldi r24,lo8(-1)
 1436 0012 9FEF      		ldi r25,lo8(-1)
 1437 0014 9093 8700 		sts 134+1,r25
 1438 0018 8093 8600 		sts 134,r24
1236:quantum/quantum.c **** 
1237:quantum/quantum.c ****   backlight_init();
 1439               		.loc 1 1237 0
 1440 001c 0C94 0000 		jmp backlight_init
 1441               	.LVL166:
 1442               		.cfi_endproc
 1443               	.LFE44:
 1445               		.section	.text.matrix_init_quantum,"ax",@progbits
 1446               	.global	matrix_init_quantum
 1448               	matrix_init_quantum:
 1449               	.LFB38:
 914:quantum/quantum.c ****   #ifdef BACKLIGHT_ENABLE
 1450               		.loc 1 914 0
 1451               		.cfi_startproc
 1452               	/* prologue: function */
 1453               	/* frame size = 0 */
 1454               	/* stack size = 0 */
 1455               	.L__stack_usage = 0
 916:quantum/quantum.c ****   #endif
 1456               		.loc 1 916 0
 1457 0000 0E94 0000 		call backlight_init_ports
 1458               	.LVL167:
 919:quantum/quantum.c ****   #endif
 1459               		.loc 1 919 0
 1460 0004 0E94 0000 		call audio_init
 1461               	.LVL168:
 924:quantum/quantum.c **** }
 1462               		.loc 1 924 0
 1463 0008 0C94 0000 		jmp matrix_init_kb
 1464               	.LVL169:
 1465               		.cfi_endproc
 1466               	.LFE38:
 1468               		.section	.text.send_nibble,"ax",@progbits
 1469               	.global	send_nibble
 1471               	send_nibble:
 1472               	.LFB48:
1238:quantum/quantum.c ****   #ifdef BACKLIGHT_BREATHING
1239:quantum/quantum.c ****     breathing_enable();
1240:quantum/quantum.c ****   #endif
1241:quantum/quantum.c **** }
1242:quantum/quantum.c **** 
1243:quantum/quantum.c **** #endif // NO_HARDWARE_PWM
1244:quantum/quantum.c **** 
1245:quantum/quantum.c **** #else // backlight
1246:quantum/quantum.c **** 
1247:quantum/quantum.c **** __attribute__ ((weak))
1248:quantum/quantum.c **** void backlight_init_ports(void) {}
1249:quantum/quantum.c **** 
1250:quantum/quantum.c **** __attribute__ ((weak))
1251:quantum/quantum.c **** void backlight_set(uint8_t level) {}
1252:quantum/quantum.c **** 
1253:quantum/quantum.c **** #endif // backlight
1254:quantum/quantum.c **** 
1255:quantum/quantum.c **** #ifdef HD44780_ENABLED
1256:quantum/quantum.c **** #include "hd44780.h"
1257:quantum/quantum.c **** #endif
1258:quantum/quantum.c **** 
1259:quantum/quantum.c **** 
1260:quantum/quantum.c **** // Functions for spitting out values
1261:quantum/quantum.c **** //
1262:quantum/quantum.c **** 
1263:quantum/quantum.c **** void send_dword(uint32_t number) { // this might not actually work
1264:quantum/quantum.c ****     uint16_t word = (number >> 16);
1265:quantum/quantum.c ****     send_word(word);
1266:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
1267:quantum/quantum.c **** }
1268:quantum/quantum.c **** 
1269:quantum/quantum.c **** void send_word(uint16_t number) {
1270:quantum/quantum.c ****     uint8_t byte = number >> 8;
1271:quantum/quantum.c ****     send_byte(byte);
1272:quantum/quantum.c ****     send_byte(number & 0xFF);
1273:quantum/quantum.c **** }
1274:quantum/quantum.c **** 
1275:quantum/quantum.c **** void send_byte(uint8_t number) {
1276:quantum/quantum.c ****     uint8_t nibble = number >> 4;
1277:quantum/quantum.c ****     send_nibble(nibble);
1278:quantum/quantum.c ****     send_nibble(number & 0xF);
1279:quantum/quantum.c **** }
1280:quantum/quantum.c **** 
1281:quantum/quantum.c **** void send_nibble(uint8_t number) {
 1473               		.loc 1 1281 0
 1474               		.cfi_startproc
 1475               	.LVL170:
 1476 0000 CF93      		push r28
 1477               	.LCFI37:
 1478               		.cfi_def_cfa_offset 3
 1479               		.cfi_offset 28, -2
 1480               	/* prologue: function */
 1481               	/* frame size = 0 */
 1482               	/* stack size = 1 */
 1483               	.L__stack_usage = 1
1282:quantum/quantum.c ****     switch (number) {
 1484               		.loc 1 1282 0
 1485 0002 8A30      		cpi r24,lo8(10)
 1486 0004 00F4      		brsh .L96
 1487 0006 8130      		cpi r24,lo8(1)
 1488 0008 00F4      		brsh .L104
1283:quantum/quantum.c ****         case 0:
1284:quantum/quantum.c ****             register_code(KC_0);
 1489               		.loc 1 1284 0
 1490 000a 87E2      		ldi r24,lo8(39)
 1491               	.LVL171:
 1492 000c 0E94 0000 		call register_code
 1493               	.LVL172:
1285:quantum/quantum.c ****             unregister_code(KC_0);
 1494               		.loc 1 1285 0
 1495 0010 87E2      		ldi r24,lo8(39)
 1496 0012 00C0      		rjmp .L102
 1497               	.LVL173:
 1498               	.L96:
1282:quantum/quantum.c ****     switch (number) {
 1499               		.loc 1 1282 0
 1500 0014 8031      		cpi r24,lo8(16)
 1501 0016 00F4      		brsh .L105
1286:quantum/quantum.c ****             break;
1287:quantum/quantum.c ****         case 1 ... 9:
1288:quantum/quantum.c ****             register_code(KC_1 + (number - 1));
1289:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
1290:quantum/quantum.c ****             break;
1291:quantum/quantum.c ****         case 0xA ... 0xF:
1292:quantum/quantum.c ****             register_code(KC_A + (number - 0xA));
 1502               		.loc 1 1292 0
 1503 0018 CAEF      		ldi r28,lo8(-6)
 1504 001a 00C0      		rjmp .L103
 1505               	.L104:
1288:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
 1506               		.loc 1 1288 0
 1507 001c CDE1      		ldi r28,lo8(29)
 1508               	.L103:
 1509               		.loc 1 1292 0
 1510 001e C80F      		add r28,r24
 1511 0020 8C2F      		mov r24,r28
 1512               	.LVL174:
 1513 0022 0E94 0000 		call register_code
 1514               	.LVL175:
1293:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 1515               		.loc 1 1293 0
 1516 0026 8C2F      		mov r24,r28
 1517               	.L102:
 1518               	/* epilogue start */
1294:quantum/quantum.c ****             break;
1295:quantum/quantum.c ****     }
1296:quantum/quantum.c **** }
 1519               		.loc 1 1296 0
 1520 0028 CF91      		pop r28
1293:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 1521               		.loc 1 1293 0
 1522 002a 0C94 0000 		jmp unregister_code
 1523               	.LVL176:
 1524               	.L105:
 1525               	/* epilogue start */
 1526               		.loc 1 1296 0
 1527 002e CF91      		pop r28
 1528 0030 0895      		ret
 1529               		.cfi_endproc
 1530               	.LFE48:
 1532               		.section	.text.send_byte,"ax",@progbits
 1533               	.global	send_byte
 1535               	send_byte:
 1536               	.LFB47:
1275:quantum/quantum.c ****     uint8_t nibble = number >> 4;
 1537               		.loc 1 1275 0
 1538               		.cfi_startproc
 1539               	.LVL177:
 1540 0000 CF93      		push r28
 1541               	.LCFI38:
 1542               		.cfi_def_cfa_offset 3
 1543               		.cfi_offset 28, -2
 1544               	/* prologue: function */
 1545               	/* frame size = 0 */
 1546               	/* stack size = 1 */
 1547               	.L__stack_usage = 1
 1548 0002 C82F      		mov r28,r24
 1549               	.LVL178:
1277:quantum/quantum.c ****     send_nibble(number & 0xF);
 1550               		.loc 1 1277 0
 1551 0004 8295      		swap r24
 1552               	.LVL179:
 1553 0006 8F70      		andi r24,lo8(15)
 1554 0008 0E94 0000 		call send_nibble
 1555               	.LVL180:
1278:quantum/quantum.c **** }
 1556               		.loc 1 1278 0
 1557 000c 8C2F      		mov r24,r28
 1558 000e 8F70      		andi r24,lo8(15)
 1559               	/* epilogue start */
1279:quantum/quantum.c **** 
 1560               		.loc 1 1279 0
 1561 0010 CF91      		pop r28
 1562               	.LVL181:
1278:quantum/quantum.c **** }
 1563               		.loc 1 1278 0
 1564 0012 0C94 0000 		jmp send_nibble
 1565               	.LVL182:
 1566               		.cfi_endproc
 1567               	.LFE47:
 1569               		.section	.text.send_word,"ax",@progbits
 1570               	.global	send_word
 1572               	send_word:
 1573               	.LFB46:
1269:quantum/quantum.c ****     uint8_t byte = number >> 8;
 1574               		.loc 1 1269 0
 1575               		.cfi_startproc
 1576               	.LVL183:
 1577 0000 CF93      		push r28
 1578               	.LCFI39:
 1579               		.cfi_def_cfa_offset 3
 1580               		.cfi_offset 28, -2
 1581               	/* prologue: function */
 1582               	/* frame size = 0 */
 1583               	/* stack size = 1 */
 1584               	.L__stack_usage = 1
 1585 0002 C82F      		mov r28,r24
 1586               	.LVL184:
1271:quantum/quantum.c ****     send_byte(number & 0xFF);
 1587               		.loc 1 1271 0
 1588 0004 892F      		mov r24,r25
 1589               	.LVL185:
 1590 0006 0E94 0000 		call send_byte
 1591               	.LVL186:
1272:quantum/quantum.c **** }
 1592               		.loc 1 1272 0
 1593 000a 8C2F      		mov r24,r28
 1594               	/* epilogue start */
1273:quantum/quantum.c **** 
 1595               		.loc 1 1273 0
 1596 000c CF91      		pop r28
1272:quantum/quantum.c **** }
 1597               		.loc 1 1272 0
 1598 000e 0C94 0000 		jmp send_byte
 1599               	.LVL187:
 1600               		.cfi_endproc
 1601               	.LFE46:
 1603               		.section	.text.send_dword,"ax",@progbits
 1604               	.global	send_dword
 1606               	send_dword:
 1607               	.LFB45:
1263:quantum/quantum.c ****     uint16_t word = (number >> 16);
 1608               		.loc 1 1263 0
 1609               		.cfi_startproc
 1610               	.LVL188:
 1611 0000 CF92      		push r12
 1612               	.LCFI40:
 1613               		.cfi_def_cfa_offset 3
 1614               		.cfi_offset 12, -2
 1615 0002 DF92      		push r13
 1616               	.LCFI41:
 1617               		.cfi_def_cfa_offset 4
 1618               		.cfi_offset 13, -3
 1619 0004 EF92      		push r14
 1620               	.LCFI42:
 1621               		.cfi_def_cfa_offset 5
 1622               		.cfi_offset 14, -4
 1623 0006 FF92      		push r15
 1624               	.LCFI43:
 1625               		.cfi_def_cfa_offset 6
 1626               		.cfi_offset 15, -5
 1627               	/* prologue: function */
 1628               	/* frame size = 0 */
 1629               	/* stack size = 4 */
 1630               	.L__stack_usage = 4
 1631 0008 6B01      		movw r12,r22
 1632 000a 7C01      		movw r14,r24
 1633               	.LVL189:
1265:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
 1634               		.loc 1 1265 0
 1635 000c C701      		movw r24,r14
 1636 000e 0E94 0000 		call send_word
 1637               	.LVL190:
1266:quantum/quantum.c **** }
 1638               		.loc 1 1266 0
 1639 0012 C601      		movw r24,r12
 1640               	/* epilogue start */
1267:quantum/quantum.c **** 
 1641               		.loc 1 1267 0
 1642 0014 FF90      		pop r15
 1643 0016 EF90      		pop r14
 1644 0018 DF90      		pop r13
 1645 001a CF90      		pop r12
 1646               	.LVL191:
1266:quantum/quantum.c **** }
 1647               		.loc 1 1266 0
 1648 001c 0C94 0000 		jmp send_word
 1649               	.LVL192:
 1650               		.cfi_endproc
 1651               	.LFE45:
 1653               		.section	.text.hex_to_keycode,"ax",@progbits
 1654               		.weak	hex_to_keycode
 1656               	hex_to_keycode:
 1657               	.LFB49:
1297:quantum/quantum.c **** 
1298:quantum/quantum.c **** 
1299:quantum/quantum.c **** __attribute__((weak))
1300:quantum/quantum.c **** uint16_t hex_to_keycode(uint8_t hex)
1301:quantum/quantum.c **** {
 1658               		.loc 1 1301 0
 1659               		.cfi_startproc
 1660               	.LVL193:
 1661               	/* prologue: function */
 1662               	/* frame size = 0 */
 1663               	/* stack size = 0 */
 1664               	.L__stack_usage = 0
1302:quantum/quantum.c ****   hex = hex & 0xF;
 1665               		.loc 1 1302 0
 1666 0000 282F      		mov r18,r24
 1667 0002 2F70      		andi r18,lo8(15)
 1668               	.LVL194:
1303:quantum/quantum.c ****   if (hex == 0x0) {
 1669               		.loc 1 1303 0
 1670 0004 01F0      		breq .L112
 1671 0006 822F      		mov r24,r18
 1672 0008 90E0      		ldi r25,0
1304:quantum/quantum.c ****     return KC_0;
1305:quantum/quantum.c ****   } else if (hex < 0xA) {
 1673               		.loc 1 1305 0
 1674 000a 2A30      		cpi r18,lo8(10)
 1675 000c 00F4      		brsh .L111
1306:quantum/quantum.c ****     return KC_1 + (hex - 0x1);
 1676               		.loc 1 1306 0
 1677 000e 4D96      		adiw r24,29
 1678 0010 0895      		ret
 1679               	.L111:
1307:quantum/quantum.c ****   } else {
1308:quantum/quantum.c ****     return KC_A + (hex - 0xA);
 1680               		.loc 1 1308 0
 1681 0012 0697      		sbiw r24,6
 1682 0014 0895      		ret
 1683               	.L112:
1304:quantum/quantum.c ****   } else if (hex < 0xA) {
 1684               		.loc 1 1304 0
 1685 0016 87E2      		ldi r24,lo8(39)
 1686 0018 90E0      		ldi r25,0
1309:quantum/quantum.c ****   }
1310:quantum/quantum.c **** }
 1687               		.loc 1 1310 0
 1688 001a 0895      		ret
 1689               		.cfi_endproc
 1690               	.LFE49:
 1692               		.section	.text.api_send_unicode,"ax",@progbits
 1693               	.global	api_send_unicode
 1695               	api_send_unicode:
 1696               	.LFB50:
1311:quantum/quantum.c **** 
1312:quantum/quantum.c **** void api_send_unicode(uint32_t unicode) {
 1697               		.loc 1 1312 0
 1698               		.cfi_startproc
 1699               	.LVL195:
 1700               	/* prologue: function */
 1701               	/* frame size = 0 */
 1702               	/* stack size = 0 */
 1703               	.L__stack_usage = 0
 1704 0000 0895      		ret
 1705               		.cfi_endproc
 1706               	.LFE50:
 1708               		.section	.text.led_set_user,"ax",@progbits
 1709               		.weak	led_set_user
 1711               	led_set_user:
 1712               	.LFB51:
1313:quantum/quantum.c **** #ifdef API_ENABLE
1314:quantum/quantum.c ****     uint8_t chunk[4];
1315:quantum/quantum.c ****     dword_to_bytes(unicode, chunk);
1316:quantum/quantum.c ****     MT_SEND_DATA(DT_UNICODE, chunk, 5);
1317:quantum/quantum.c **** #endif
1318:quantum/quantum.c **** }
1319:quantum/quantum.c **** 
1320:quantum/quantum.c **** __attribute__ ((weak))
1321:quantum/quantum.c **** void led_set_user(uint8_t usb_led) {
 1713               		.loc 1 1321 0
 1714               		.cfi_startproc
 1715               	.LVL196:
 1716               	/* prologue: function */
 1717               	/* frame size = 0 */
 1718               	/* stack size = 0 */
 1719               	.L__stack_usage = 0
 1720 0000 0895      		ret
 1721               		.cfi_endproc
 1722               	.LFE51:
 1724               		.section	.text.led_set_kb,"ax",@progbits
 1725               		.weak	led_set_kb
 1727               	led_set_kb:
 1728               	.LFB52:
1322:quantum/quantum.c **** 
1323:quantum/quantum.c **** }
1324:quantum/quantum.c **** 
1325:quantum/quantum.c **** __attribute__ ((weak))
1326:quantum/quantum.c **** void led_set_kb(uint8_t usb_led) {
 1729               		.loc 1 1326 0
 1730               		.cfi_startproc
 1731               	.LVL197:
 1732               	/* prologue: function */
 1733               	/* frame size = 0 */
 1734               	/* stack size = 0 */
 1735               	.L__stack_usage = 0
1327:quantum/quantum.c ****     led_set_user(usb_led);
 1736               		.loc 1 1327 0
 1737 0000 0C94 0000 		jmp led_set_user
 1738               	.LVL198:
 1739               		.cfi_endproc
 1740               	.LFE52:
 1742               		.section	.text.led_init_ports,"ax",@progbits
 1743               		.weak	led_init_ports
 1745               	led_init_ports:
 1746               	.LFB53:
1328:quantum/quantum.c **** }
1329:quantum/quantum.c **** 
1330:quantum/quantum.c **** __attribute__ ((weak))
1331:quantum/quantum.c **** void led_init_ports(void)
1332:quantum/quantum.c **** {
 1747               		.loc 1 1332 0
 1748               		.cfi_startproc
 1749               	/* prologue: function */
 1750               	/* frame size = 0 */
 1751               	/* stack size = 0 */
 1752               	.L__stack_usage = 0
 1753 0000 0895      		ret
 1754               		.cfi_endproc
 1755               	.LFE53:
 1757               		.section	.text.led_set,"ax",@progbits
 1758               		.weak	led_set
 1760               	led_set:
 1761               	.LFB54:
1333:quantum/quantum.c **** 
1334:quantum/quantum.c **** }
1335:quantum/quantum.c **** 
1336:quantum/quantum.c **** __attribute__ ((weak))
1337:quantum/quantum.c **** void led_set(uint8_t usb_led)
1338:quantum/quantum.c **** {
 1762               		.loc 1 1338 0
 1763               		.cfi_startproc
 1764               	.LVL199:
 1765               	/* prologue: function */
 1766               	/* frame size = 0 */
 1767               	/* stack size = 0 */
 1768               	.L__stack_usage = 0
1339:quantum/quantum.c **** 
1340:quantum/quantum.c ****   // Example LED Code
1341:quantum/quantum.c ****   //
1342:quantum/quantum.c ****     // // Using PE6 Caps Lock LED
1343:quantum/quantum.c ****     // if (usb_led & (1<<USB_LED_CAPS_LOCK))
1344:quantum/quantum.c ****     // {
1345:quantum/quantum.c ****     //     // Output high.
1346:quantum/quantum.c ****     //     DDRE |= (1<<6);
1347:quantum/quantum.c ****     //     PORTE |= (1<<6);
1348:quantum/quantum.c ****     // }
1349:quantum/quantum.c ****     // else
1350:quantum/quantum.c ****     // {
1351:quantum/quantum.c ****     //     // Output low.
1352:quantum/quantum.c ****     //     DDRE &= ~(1<<6);
1353:quantum/quantum.c ****     //     PORTE &= ~(1<<6);
1354:quantum/quantum.c ****     // }
1355:quantum/quantum.c **** 
1356:quantum/quantum.c ****   led_set_kb(usb_led);
 1769               		.loc 1 1356 0
 1770 0000 0C94 0000 		jmp led_set_kb
 1771               	.LVL200:
 1772               		.cfi_endproc
 1773               	.LFE54:
 1775               		.section	.text.startup_user,"ax",@progbits
 1776               		.weak	startup_user
 1778               	startup_user:
 1779               	.LFB55:
1357:quantum/quantum.c **** }
1358:quantum/quantum.c **** 
1359:quantum/quantum.c **** 
1360:quantum/quantum.c **** //------------------------------------------------------------------------------
1361:quantum/quantum.c **** // Override these functions in your keymap file to play different tunes on
1362:quantum/quantum.c **** // different events such as startup and bootloader jump
1363:quantum/quantum.c **** 
1364:quantum/quantum.c **** __attribute__ ((weak))
1365:quantum/quantum.c **** void startup_user() {}
 1780               		.loc 1 1365 0
 1781               		.cfi_startproc
 1782               	/* prologue: function */
 1783               	/* frame size = 0 */
 1784               	/* stack size = 0 */
 1785               	.L__stack_usage = 0
 1786 0000 0895      		ret
 1787               		.cfi_endproc
 1788               	.LFE55:
 1790               		.section	.text.shutdown_user,"ax",@progbits
 1791               		.weak	shutdown_user
 1793               	shutdown_user:
 1794               	.LFB56:
1366:quantum/quantum.c **** 
1367:quantum/quantum.c **** __attribute__ ((weak))
1368:quantum/quantum.c **** void shutdown_user() {}
 1795               		.loc 1 1368 0
 1796               		.cfi_startproc
 1797               	/* prologue: function */
 1798               	/* frame size = 0 */
 1799               	/* stack size = 0 */
 1800               	.L__stack_usage = 0
 1801 0000 0895      		ret
 1802               		.cfi_endproc
 1803               	.LFE56:
 1805               		.section	.text.reset_keyboard,"ax",@progbits
 1806               	.global	reset_keyboard
 1808               	reset_keyboard:
 1809               	.LFB27:
 145:quantum/quantum.c ****   clear_keyboard();
 1810               		.loc 1 145 0
 1811               		.cfi_startproc
 145:quantum/quantum.c ****   clear_keyboard();
 1812               		.loc 1 145 0
 1813 0000 CF93      		push r28
 1814               	.LCFI44:
 1815               		.cfi_def_cfa_offset 3
 1816               		.cfi_offset 28, -2
 1817 0002 DF93      		push r29
 1818               	.LCFI45:
 1819               		.cfi_def_cfa_offset 4
 1820               		.cfi_offset 29, -3
 1821               	/* prologue: function */
 1822               	/* frame size = 0 */
 1823               	/* stack size = 2 */
 1824               	.L__stack_usage = 2
 146:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 1825               		.loc 1 146 0
 1826 0004 0E94 0000 		call clear_keyboard
 1827               	.LVL201:
 151:quantum/quantum.c ****   uint16_t timer_start = timer_read();
 1828               		.loc 1 151 0
 1829 0008 0E94 0000 		call music_all_notes_off
 1830               	.LVL202:
 152:quantum/quantum.c ****   PLAY_SONG(goodbye_song);
 1831               		.loc 1 152 0
 1832 000c 0E94 0000 		call timer_read
 1833               	.LVL203:
 1834 0010 EC01      		movw r28,r24
 1835               	.LVL204:
 153:quantum/quantum.c ****   shutdown_user();
 1836               		.loc 1 153 0
 1837 0012 40E0      		ldi r20,0
 1838 0014 63E0      		ldi r22,lo8(3)
 1839 0016 70E0      		ldi r23,0
 1840 0018 80E0      		ldi r24,lo8(goodbye_song)
 1841 001a 90E0      		ldi r25,hi8(goodbye_song)
 1842               	.LVL205:
 1843 001c 0E94 0000 		call play_notes
 1844               	.LVL206:
 154:quantum/quantum.c ****   while(timer_elapsed(timer_start) < 250)
 1845               		.loc 1 154 0
 1846 0020 0E94 0000 		call shutdown_user
 1847               	.LVL207:
 1848               	.L121:
 155:quantum/quantum.c ****     wait_ms(1);
 1849               		.loc 1 155 0
 1850 0024 CE01      		movw r24,r28
 1851 0026 0E94 0000 		call timer_elapsed
 1852               	.LVL208:
 1853 002a 8A3F      		cpi r24,-6
 1854 002c 9105      		cpc r25,__zero_reg__
 1855 002e 00F4      		brsh .L123
 1856               	.LVL209:
 1857               	.LBB63:
 1858               	.LBB64:
 1859               		.loc 2 187 0
 1860 0030 8FE9      		ldi r24,lo8(3999)
 1861 0032 9FE0      		ldi r25,hi8(3999)
 1862 0034 0197      	1:	sbiw r24,1
 1863 0036 01F4      		brne 1b
 1864 0038 00C0      		rjmp .
 1865 003a 0000      		nop
 1866 003c 00C0      		rjmp .L121
 1867               	.LVL210:
 1868               	.L123:
 1869               	.LBE64:
 1870               	.LBE63:
 157:quantum/quantum.c **** #else
 1871               		.loc 1 157 0
 1872 003e 0E94 0000 		call stop_all_notes
 1873               	.LVL211:
 1874               	/* epilogue start */
 166:quantum/quantum.c **** 
 1875               		.loc 1 166 0
 1876 0042 DF91      		pop r29
 1877 0044 CF91      		pop r28
 1878               	.LVL212:
 165:quantum/quantum.c **** }
 1879               		.loc 1 165 0
 1880 0046 0C94 0000 		jmp bootloader_jump
 1881               	.LVL213:
 1882               		.cfi_endproc
 1883               	.LFE27:
 1885               		.section	.text.process_record_quantum,"ax",@progbits
 1886               	.global	process_record_quantum
 1888               	process_record_quantum:
 1889               	.LFB28:
 190:quantum/quantum.c **** 
 1890               		.loc 1 190 0
 1891               		.cfi_startproc
 1892               	.LVL214:
 1893 0000 FF92      		push r15
 1894               	.LCFI46:
 1895               		.cfi_def_cfa_offset 3
 1896               		.cfi_offset 15, -2
 1897 0002 0F93      		push r16
 1898               	.LCFI47:
 1899               		.cfi_def_cfa_offset 4
 1900               		.cfi_offset 16, -3
 1901 0004 1F93      		push r17
 1902               	.LCFI48:
 1903               		.cfi_def_cfa_offset 5
 1904               		.cfi_offset 17, -4
 1905 0006 CF93      		push r28
 1906               	.LCFI49:
 1907               		.cfi_def_cfa_offset 6
 1908               		.cfi_offset 28, -5
 1909 0008 DF93      		push r29
 1910               	.LCFI50:
 1911               		.cfi_def_cfa_offset 7
 1912               		.cfi_offset 29, -6
 1913               	/* prologue: function */
 1914               	/* frame size = 0 */
 1915               	/* stack size = 5 */
 1916               	.L__stack_usage = 5
 1917 000a 8C01      		movw r16,r24
 193:quantum/quantum.c ****   uint16_t keycode;
 1918               		.loc 1 193 0
 1919 000c FC01      		movw r30,r24
 1920 000e C081      		ld r28,Z
 1921 0010 D181      		ldd r29,Z+1
 1922               	.LVL215:
 198:quantum/quantum.c ****       uint8_t layer;
 1923               		.loc 1 198 0
 1924 0012 8091 0000 		lds r24,disable_action_cache
 1925               	.LVL216:
 1926 0016 8111      		cpse r24,__zero_reg__
 1927 0018 00C0      		rjmp .L125
 1928               	.LBB65:
 201:quantum/quantum.c ****         layer = layer_switch_get_layer(key);
 1929               		.loc 1 201 0
 1930 001a 8281      		ldd r24,Z+2
 1931 001c 8823      		tst r24
 1932 001e 01F0      		breq .L126
 1933               	.LVL217:
 202:quantum/quantum.c ****         update_source_layers_cache(key, layer);
 1934               		.loc 1 202 0
 1935 0020 CE01      		movw r24,r28
 1936 0022 0E94 0000 		call layer_switch_get_layer
 1937               	.LVL218:
 1938 0026 F82E      		mov r15,r24
 1939               	.LVL219:
 203:quantum/quantum.c ****       } else {
 1940               		.loc 1 203 0
 1941 0028 682F      		mov r22,r24
 1942 002a CE01      		movw r24,r28
 1943 002c 0E94 0000 		call update_source_layers_cache
 1944               	.LVL220:
 1945 0030 00C0      		rjmp .L127
 1946               	.LVL221:
 1947               	.L126:
 205:quantum/quantum.c ****       }
 1948               		.loc 1 205 0
 1949 0032 CE01      		movw r24,r28
 1950 0034 0E94 0000 		call read_source_layers_cache
 1951               	.LVL222:
 1952 0038 F82E      		mov r15,r24
 1953               	.LVL223:
 1954               	.L127:
 207:quantum/quantum.c ****     } else
 1955               		.loc 1 207 0
 1956 003a BE01      		movw r22,r28
 1957 003c 8F2D      		mov r24,r15
 1958 003e 00C0      		rjmp .L306
 1959               	.LVL224:
 1960               	.L125:
 1961               	.LBE65:
 210:quantum/quantum.c **** 
 1962               		.loc 1 210 0
 1963 0040 CE01      		movw r24,r28
 1964 0042 0E94 0000 		call layer_switch_get_layer
 1965               	.LVL225:
 1966 0046 BE01      		movw r22,r28
 1967               	.L306:
 1968 0048 0E94 0000 		call keymap_key_to_keycode
 1969               	.LVL226:
 1970 004c EC01      		movw r28,r24
 1971               	.LVL227:
 232:quantum/quantum.c ****   #if defined(RGB_MATRIX_ENABLE) && defined(RGB_MATRIX_KEYPRESSES)
 1972               		.loc 1 232 0
 1973 004e B801      		movw r22,r16
 1974 0050 0E94 0000 		call process_record_kb
 1975               	.LVL228:
 240:quantum/quantum.c ****   #endif
 1976               		.loc 1 240 0
 1977 0054 8823      		tst r24
 1978 0056 01F4      		brne .+2
 1979 0058 00C0      		rjmp .L244
 240:quantum/quantum.c ****   #endif
 1980               		.loc 1 240 0 is_stmt 0 discriminator 2
 1981 005a B801      		movw r22,r16
 1982 005c CE01      		movw r24,r28
 1983 005e 0E94 0000 		call process_audio
 1984               	.LVL229:
 232:quantum/quantum.c ****   #if defined(RGB_MATRIX_ENABLE) && defined(RGB_MATRIX_KEYPRESSES)
 1985               		.loc 1 232 0 is_stmt 1 discriminator 2
 1986 0062 8823      		tst r24
 1987 0064 01F4      		brne .+2
 1988 0066 00C0      		rjmp .L244
 246:quantum/quantum.c ****   #endif
 1989               		.loc 1 246 0 discriminator 3
 1990 0068 B801      		movw r22,r16
 1991 006a CE01      		movw r24,r28
 1992 006c 0E94 0000 		call process_music
 1993               	.LVL230:
 240:quantum/quantum.c ****   #endif
 1994               		.loc 1 240 0 discriminator 3
 1995 0070 8823      		tst r24
 1996 0072 01F4      		brne .+2
 1997 0074 00C0      		rjmp .L244
 284:quantum/quantum.c ****     case RESET:
 1998               		.loc 1 284 0
 1999 0076 C83C      		cpi r28,-56
 2000 0078 FCE5      		ldi r31,92
 2001 007a DF07      		cpc r29,r31
 2002 007c 01F4      		brne .L313
 434:quantum/quantum.c ****       rgblight_increase_speed();
 2003               		.loc 1 434 0
 2004 007e F801      		movw r30,r16
 2005 0080 8281      		ldd r24,Z+2
 2006 0082 8823      		tst r24
 2007 0084 01F4      		brne .+2
 2008 0086 00C0      		rjmp .L244
 435:quantum/quantum.c ****     }
 2009               		.loc 1 435 0
 2010 0088 0E94 0000 		call rgblight_increase_speed
 2011               	.LVL231:
 2012 008c 00C0      		rjmp .L244
 2013               	.L313:
 284:quantum/quantum.c ****     case RESET:
 2014               		.loc 1 284 0
 2015 008e C93C      		cpi r28,-55
 2016 0090 8CE5      		ldi r24,92
 2017 0092 D807      		cpc r29,r24
 2018 0094 00F0      		brlo .+2
 2019 0096 00C0      		rjmp .L207
 2020 0098 C03C      		cpi r28,-64
 2021 009a 9CE5      		ldi r25,92
 2022 009c D907      		cpc r29,r25
 2023 009e 01F4      		brne .L314
 328:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 2024               		.loc 1 328 0
 2025 00a0 F801      		movw r30,r16
 2026 00a2 8281      		ldd r24,Z+2
 2027 00a4 8823      		tst r24
 2028 00a6 01F4      		brne .+2
 2029 00a8 00C0      		rjmp .L244
 2030               	.LBB66:
 329:quantum/quantum.c ****       if(shifted) {
 2031               		.loc 1 329 0
 2032 00aa 0E94 0000 		call get_mods
 2033               	.LVL232:
 2034 00ae 8272      		andi r24,lo8(34)
 2035               	.LVL233:
 330:quantum/quantum.c ****         rgblight_step_reverse();
 2036               		.loc 1 330 0
 2037 00b0 01F0      		breq .L136
 2038               	.LVL234:
 2039               	.L138:
 331:quantum/quantum.c ****       }
 2040               		.loc 1 331 0
 2041 00b2 0E94 0000 		call rgblight_step_reverse
 2042               	.LVL235:
 2043 00b6 00C0      		rjmp .L244
 2044               	.L314:
 2045               	.LBE66:
 284:quantum/quantum.c ****     case RESET:
 2046               		.loc 1 284 0
 2047 00b8 C13C      		cpi r28,-63
 2048 00ba ECE5      		ldi r30,92
 2049 00bc DE07      		cpc r29,r30
 2050 00be 00F0      		brlo .L315
 2051 00c0 F801      		movw r30,r16
 2052 00c2 8281      		ldd r24,Z+2
 2053 00c4 C43C      		cpi r28,-60
 2054 00c6 FCE5      		ldi r31,92
 2055 00c8 DF07      		cpc r29,r31
 2056 00ca 01F4      		brne .+2
 2057 00cc 00C0      		rjmp .L141
 2058 00ce 00F0      		brlo .+2
 2059 00d0 00C0      		rjmp .L210
 2060 00d2 C23C      		cpi r28,-62
 2061 00d4 ECE5      		ldi r30,92
 2062 00d6 DE07      		cpc r29,r30
 2063 00d8 01F4      		brne .+2
 2064 00da 00C0      		rjmp .L139
 2065 00dc 00F0      		brlo .+2
 2066 00de 00C0      		rjmp .L316
 342:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 2067               		.loc 1 342 0
 2068 00e0 8823      		tst r24
 2069 00e2 01F4      		brne .+2
 2070 00e4 00C0      		rjmp .L244
 2071               	.LBB67:
 343:quantum/quantum.c ****       if(shifted) {
 2072               		.loc 1 343 0
 2073 00e6 0E94 0000 		call get_mods
 2074               	.LVL236:
 2075 00ea 8272      		andi r24,lo8(34)
 2076               	.LVL237:
 344:quantum/quantum.c ****         rgblight_step();
 2077               		.loc 1 344 0
 2078 00ec 01F0      		breq .L138
 2079               	.LVL238:
 2080               	.L136:
 2081               	.LBE67:
 2082               	.LBB68:
 334:quantum/quantum.c ****       }
 2083               		.loc 1 334 0
 2084 00ee 0E94 0000 		call rgblight_step
 2085               	.LVL239:
 2086 00f2 00C0      		rjmp .L244
 2087               	.L315:
 2088               	.LBE68:
 284:quantum/quantum.c ****     case RESET:
 2089               		.loc 1 284 0
 2090 00f4 C531      		cpi r28,21
 2091 00f6 FCE5      		ldi r31,92
 2092 00f8 DF07      		cpc r29,r31
 2093 00fa 00F0      		brlo .+2
 2094 00fc 00C0      		rjmp .L209
 2095 00fe C230      		cpi r28,2
 2096 0100 8CE5      		ldi r24,92
 2097 0102 D807      		cpc r29,r24
 2098 0104 00F4      		brsh .+2
 2099 0106 00C0      		rjmp .L317
 536:quantum/quantum.c ****         // MAGIC actions (BOOTMAGIC without the boot)
 2100               		.loc 1 536 0
 2101 0108 F801      		movw r30,r16
 2102 010a 8281      		ldd r24,Z+2
 2103 010c 8823      		tst r24
 2104 010e 01F4      		brne .+2
 2105 0110 00C0      		rjmp .L165
 538:quantum/quantum.c ****             eeconfig_init();
 2106               		.loc 1 538 0
 2107 0112 0E94 0000 		call eeconfig_is_enabled
 2108               	.LVL240:
 2109 0116 8111      		cpse r24,__zero_reg__
 2110 0118 00C0      		rjmp .L166
 539:quantum/quantum.c ****         }
 2111               		.loc 1 539 0
 2112 011a 0E94 0000 		call eeconfig_init
 2113               	.LVL241:
 2114               	.L166:
 542:quantum/quantum.c ****         switch (keycode)
 2115               		.loc 1 542 0
 2116 011e 0E94 0000 		call eeconfig_read_keymap
 2117               	.LVL242:
 2118 0122 90E0      		ldi r25,0
 2119 0124 9093 0000 		sts keymap_config+1,r25
 2120 0128 8093 0000 		sts keymap_config,r24
 543:quantum/quantum.c ****         {
 2121               		.loc 1 543 0
 2122 012c FE01      		movw r30,r28
 2123 012e E350      		subi r30,3
 2124 0130 FC45      		sbci r31,92
 2125 0132 E231      		cpi r30,18
 2126 0134 F105      		cpc r31,__zero_reg__
 2127 0136 00F4      		brsh .L167
 2128 0138 E050      		subi r30,lo8(-(gs(.L169)))
 2129 013a F040      		sbci r31,hi8(-(gs(.L169)))
 608:quantum/quantum.c ****             break;
 2130               		.loc 1 608 0
 2131 013c 8091 0000 		lds r24,keymap_config
 543:quantum/quantum.c ****         {
 2132               		.loc 1 543 0
 2133 0140 0C94 0000 		jmp __tablejump2__
 2134               		.section	.progmem.gcc_sw_table.process_record_quantum,"a",@progbits
 2135               		.p2align	1
 2136               	.L169:
 2137 0000 0000      		.word gs(.L168)
 2138 0002 0000      		.word gs(.L170)
 2139 0004 0000      		.word gs(.L171)
 2140 0006 0000      		.word gs(.L172)
 2141 0008 0000      		.word gs(.L173)
 2142 000a 0000      		.word gs(.L174)
 2143 000c 0000      		.word gs(.L175)
 2144 000e 0000      		.word gs(.L176)
 2145 0010 0000      		.word gs(.L177)
 2146 0012 0000      		.word gs(.L178)
 2147 0014 0000      		.word gs(.L179)
 2148 0016 0000      		.word gs(.L180)
 2149 0018 0000      		.word gs(.L181)
 2150 001a 0000      		.word gs(.L182)
 2151 001c 0000      		.word gs(.L183)
 2152 001e 0000      		.word gs(.L184)
 2153 0020 0000      		.word gs(.L185)
 2154 0022 0000      		.word gs(.L186)
 2155               		.section	.text.process_record_quantum
 2156               	.L167:
 546:quantum/quantum.c ****             break;
 2157               		.loc 1 546 0
 2158 0144 8091 0000 		lds r24,keymap_config
 2159 0148 8160      		ori r24,lo8(1<<0)
 2160 014a 00C0      		rjmp .L307
 2161               	.L168:
 549:quantum/quantum.c ****             break;
 2162               		.loc 1 549 0
 2163 014c 8260      		ori r24,lo8(1<<1)
 2164 014e 00C0      		rjmp .L307
 2165               	.L170:
 552:quantum/quantum.c ****             break;
 2166               		.loc 1 552 0
 2167 0150 8460      		ori r24,lo8(1<<2)
 2168 0152 00C0      		rjmp .L307
 2169               	.L171:
 555:quantum/quantum.c ****             break;
 2170               		.loc 1 555 0
 2171 0154 8860      		ori r24,lo8(1<<3)
 2172 0156 00C0      		rjmp .L307
 2173               	.L172:
 558:quantum/quantum.c ****             break;
 2174               		.loc 1 558 0
 2175 0158 8061      		ori r24,lo8(1<<4)
 2176 015a 00C0      		rjmp .L307
 2177               	.L173:
 561:quantum/quantum.c ****             break;
 2178               		.loc 1 561 0
 2179 015c 8062      		ori r24,lo8(1<<5)
 2180 015e 00C0      		rjmp .L307
 2181               	.L174:
 564:quantum/quantum.c ****             break;
 2182               		.loc 1 564 0
 2183 0160 8064      		ori r24,lo8(1<<6)
 2184 0162 00C0      		rjmp .L307
 2185               	.L175:
 567:quantum/quantum.c ****             break;
 2186               		.loc 1 567 0
 2187 0164 8068      		ori r24,lo8(1<<7)
 2188 0166 00C0      		rjmp .L307
 2189               	.L176:
 571:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 2190               		.loc 1 571 0
 2191 0168 8460      		ori r24,lo8(4)
 2192 016a 8860      		ori r24,lo8(1<<3)
 2193 016c 8093 0000 		sts keymap_config,r24
 573:quantum/quantum.c ****             #endif
 2194               		.loc 1 573 0
 2195 0170 40E0      		ldi r20,0
 2196 0172 64E0      		ldi r22,lo8(4)
 2197 0174 70E0      		ldi r23,0
 2198 0176 80E0      		ldi r24,lo8(ag_swap_song)
 2199 0178 90E0      		ldi r25,hi8(ag_swap_song)
 2200 017a 00C0      		rjmp .L308
 2201               	.L177:
 577:quantum/quantum.c ****             break;
 2202               		.loc 1 577 0
 2203 017c 8E7F      		andi r24,lo8(~(1<<0))
 2204 017e 00C0      		rjmp .L307
 2205               	.L178:
 580:quantum/quantum.c ****             break;
 2206               		.loc 1 580 0
 2207 0180 8D7F      		andi r24,lo8(~(1<<1))
 2208 0182 00C0      		rjmp .L307
 2209               	.L179:
 583:quantum/quantum.c ****             break;
 2210               		.loc 1 583 0
 2211 0184 8B7F      		andi r24,lo8(~(1<<2))
 2212 0186 00C0      		rjmp .L307
 2213               	.L180:
 586:quantum/quantum.c ****             break;
 2214               		.loc 1 586 0
 2215 0188 877F      		andi r24,lo8(~(1<<3))
 2216 018a 00C0      		rjmp .L307
 2217               	.L181:
 589:quantum/quantum.c ****             break;
 2218               		.loc 1 589 0
 2219 018c 8F7E      		andi r24,lo8(~(1<<4))
 2220 018e 00C0      		rjmp .L307
 2221               	.L182:
 592:quantum/quantum.c ****             break;
 2222               		.loc 1 592 0
 2223 0190 8F7D      		andi r24,lo8(~(1<<5))
 2224 0192 00C0      		rjmp .L307
 2225               	.L183:
 595:quantum/quantum.c ****             break;
 2226               		.loc 1 595 0
 2227 0194 8F7B      		andi r24,lo8(~(1<<6))
 2228 0196 00C0      		rjmp .L307
 2229               	.L184:
 598:quantum/quantum.c ****             break;
 2230               		.loc 1 598 0
 2231 0198 8F77      		andi r24,lo8(~(1<<7))
 2232 019a 00C0      		rjmp .L307
 2233               	.L185:
 602:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 2234               		.loc 1 602 0
 2235 019c 8B7F      		andi r24,lo8(-5)
 2236 019e 877F      		andi r24,lo8(~(1<<3))
 2237 01a0 8093 0000 		sts keymap_config,r24
 604:quantum/quantum.c ****             #endif
 2238               		.loc 1 604 0
 2239 01a4 40E0      		ldi r20,0
 2240 01a6 62E0      		ldi r22,lo8(2)
 2241 01a8 70E0      		ldi r23,0
 2242 01aa 80E0      		ldi r24,lo8(ag_norm_song)
 2243 01ac 90E0      		ldi r25,hi8(ag_norm_song)
 2244               	.L308:
 2245 01ae 0E94 0000 		call play_notes
 2246               	.LVL243:
 606:quantum/quantum.c ****           case MAGIC_TOGGLE_NKRO:
 2247               		.loc 1 606 0
 2248 01b2 00C0      		rjmp .L187
 2249               	.L186:
 608:quantum/quantum.c ****             break;
 2250               		.loc 1 608 0
 2251 01b4 87FB      		bst r24,7
 2252 01b6 2227      		clr r18
 2253 01b8 20F9      		bld r18,0
 2254 01ba 91E0      		ldi r25,lo8(1)
 2255 01bc 9227      		eor r25,r18
 2256 01be 90FB      		bst r25,0
 2257 01c0 87F9      		bld r24,7
 2258               	.L307:
 2259 01c2 8093 0000 		sts keymap_config,r24
 2260               	.L187:
 613:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 2261               		.loc 1 613 0
 2262 01c6 8091 0000 		lds r24,keymap_config
 2263 01ca 0E94 0000 		call eeconfig_update_keymap
 2264               	.LVL244:
 614:quantum/quantum.c **** 
 2265               		.loc 1 614 0
 2266 01ce 0E94 0000 		call clear_keyboard
 2267               	.LVL245:
 616:quantum/quantum.c ****       }
 2268               		.loc 1 616 0
 2269 01d2 00C0      		rjmp .L244
 2270               	.L317:
 284:quantum/quantum.c ****     case RESET:
 2271               		.loc 1 284 0
 2272 01d4 C115      		cp r28,__zero_reg__
 2273 01d6 9CE5      		ldi r25,92
 2274 01d8 D907      		cpc r29,r25
 2275 01da 01F0      		breq .L131
 2276 01dc C130      		cpi r28,1
 2277 01de DC45      		sbci r29,92
 2278 01e0 01F0      		breq .L133
 2279               	.L206:
 735:quantum/quantum.c ****       shift_interrupted[1] = true;
 2280               		.loc 1 735 0
 2281 01e2 81E0      		ldi r24,lo8(1)
 2282 01e4 8093 0000 		sts shift_interrupted,r24
 736:quantum/quantum.c ****       break;
 2283               		.loc 1 736 0
 2284 01e8 8093 0000 		sts shift_interrupted+1,r24
 2285               	.L165:
 741:quantum/quantum.c **** }
 2286               		.loc 1 741 0
 2287 01ec C801      		movw r24,r16
 2288               	/* epilogue start */
 742:quantum/quantum.c **** 
 2289               		.loc 1 742 0
 2290 01ee DF91      		pop r29
 2291 01f0 CF91      		pop r28
 2292               	.LVL246:
 2293 01f2 1F91      		pop r17
 2294 01f4 0F91      		pop r16
 2295               	.LVL247:
 2296 01f6 FF90      		pop r15
 741:quantum/quantum.c **** }
 2297               		.loc 1 741 0
 2298 01f8 0C94 0000 		jmp process_action_kb
 2299               	.LVL248:
 2300               	.L131:
 286:quantum/quantum.c ****         reset_keyboard();
 2301               		.loc 1 286 0
 2302 01fc F801      		movw r30,r16
 2303 01fe 8281      		ldd r24,Z+2
 2304 0200 8823      		tst r24
 2305 0202 01F4      		brne .+2
 2306 0204 00C0      		rjmp .L244
 287:quantum/quantum.c ****       }
 2307               		.loc 1 287 0
 2308 0206 0E94 0000 		call reset_keyboard
 2309               	.LVL249:
 2310 020a 00C0      		rjmp .L244
 2311               	.L133:
 291:quantum/quantum.c ****           debug_enable = true;
 2312               		.loc 1 291 0
 2313 020c F801      		movw r30,r16
 2314 020e 8281      		ldd r24,Z+2
 2315 0210 8823      		tst r24
 2316 0212 01F4      		brne .+2
 2317 0214 00C0      		rjmp .L244
 292:quantum/quantum.c ****           print("DEBUG: enabled.\n");
 2318               		.loc 1 292 0
 2319 0216 8091 0000 		lds r24,debug_config
 2320 021a 8160      		ori r24,lo8(1<<0)
 2321 021c 8093 0000 		sts debug_config,r24
 293:quantum/quantum.c ****       }
 2322               		.loc 1 293 0
 2323 0220 80E0      		ldi r24,lo8(__c.3520)
 2324 0222 90E0      		ldi r25,hi8(__c.3520)
 2325 0224 0E94 0000 		call xputs
 2326               	.LVL250:
 2327 0228 00C0      		rjmp .L244
 2328               	.L209:
 284:quantum/quantum.c ****     case RESET:
 2329               		.loc 1 284 0
 2330 022a C531      		cpi r28,21
 2331 022c FCE5      		ldi r31,92
 2332 022e DF07      		cpc r29,r31
 2333 0230 01F4      		brne .L318
 2334               	.LBB69:
 681:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 2335               		.loc 1 681 0
 2336 0232 0E94 0000 		call get_mods
 2337               	.LVL251:
 2338 0236 282F      		mov r18,r24
 2339               	.LVL252:
 714:quantum/quantum.c ****         grave_esc_was_shifted = shifted;
 2340               		.loc 1 714 0
 2341 0238 F801      		movw r30,r16
 2342 023a 8281      		ldd r24,Z+2
 2343 023c 4091 0000 		lds r20,keyboard_report
 2344 0240 5091 0000 		lds r21,keyboard_report+1
 2345 0244 8823      		tst r24
 2346 0246 01F0      		breq .L201
 681:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 2347               		.loc 1 681 0
 2348 0248 2A7A      		andi r18,lo8(-86)
 2349               	.LVL253:
 715:quantum/quantum.c ****         add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 2350               		.loc 1 715 0
 2351 024a 91E0      		ldi r25,lo8(1)
 2352 024c 01F4      		brne .L202
 2353 024e 90E0      		ldi r25,0
 2354               	.L202:
 2355 0250 9093 0000 		sts grave_esc_was_shifted,r25
 716:quantum/quantum.c ****       }
 2356               		.loc 1 716 0
 2357 0254 9111      		cpse r25,__zero_reg__
 2358 0256 00C0      		rjmp .L214
 2359 0258 69E2      		ldi r22,lo8(41)
 2360 025a 00C0      		rjmp .L203
 2361               	.L214:
 2362 025c 65E3      		ldi r22,lo8(53)
 2363               	.L203:
 2364               	.LVL254:
 2365               	.LBB70:
 2366               	.LBB71:
 2367               		.file 3 "tmk_core/common/action_util.h"
   1:tmk_core/common/action_util.h **** /*
   2:tmk_core/common/action_util.h **** Copyright 2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action_util.h **** 
   4:tmk_core/common/action_util.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action_util.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action_util.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action_util.h **** (at your option) any later version.
   8:tmk_core/common/action_util.h **** 
   9:tmk_core/common/action_util.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action_util.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action_util.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action_util.h **** GNU General Public License for more details.
  13:tmk_core/common/action_util.h **** 
  14:tmk_core/common/action_util.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action_util.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action_util.h **** */
  17:tmk_core/common/action_util.h **** #ifndef ACTION_UTIL_H
  18:tmk_core/common/action_util.h **** #define ACTION_UTIL_H
  19:tmk_core/common/action_util.h **** 
  20:tmk_core/common/action_util.h **** #include <stdint.h>
  21:tmk_core/common/action_util.h **** #include "report.h"
  22:tmk_core/common/action_util.h **** 
  23:tmk_core/common/action_util.h **** #ifdef __cplusplus
  24:tmk_core/common/action_util.h **** extern "C" {
  25:tmk_core/common/action_util.h **** #endif
  26:tmk_core/common/action_util.h **** 
  27:tmk_core/common/action_util.h **** extern report_keyboard_t *keyboard_report;
  28:tmk_core/common/action_util.h **** 
  29:tmk_core/common/action_util.h **** void send_keyboard_report(void);
  30:tmk_core/common/action_util.h **** 
  31:tmk_core/common/action_util.h **** /* key */
  32:tmk_core/common/action_util.h **** inline void add_key(uint8_t key) {
  33:tmk_core/common/action_util.h ****   add_key_to_report(keyboard_report, key);
 2368               		.loc 3 33 0 discriminator 4
 2369 025e CA01      		movw r24,r20
 2370 0260 0E94 0000 		call add_key_to_report
 2371               	.LVL255:
 2372 0264 00C0      		rjmp .L204
 2373               	.LVL256:
 2374               	.L201:
 2375               	.LBE71:
 2376               	.LBE70:
 719:quantum/quantum.c ****       }
 2377               		.loc 1 719 0
 2378 0266 8091 0000 		lds r24,grave_esc_was_shifted
 2379 026a 8111      		cpse r24,__zero_reg__
 2380 026c 00C0      		rjmp .L215
 2381 026e 69E2      		ldi r22,lo8(41)
 2382 0270 00C0      		rjmp .L205
 2383               	.L215:
 2384 0272 65E3      		ldi r22,lo8(53)
 2385               	.L205:
 2386               	.LVL257:
 2387               	.LBB72:
 2388               	.LBB73:
  34:tmk_core/common/action_util.h **** }
  35:tmk_core/common/action_util.h **** 
  36:tmk_core/common/action_util.h **** inline void del_key(uint8_t key) {
  37:tmk_core/common/action_util.h ****   del_key_from_report(keyboard_report, key);
 2389               		.loc 3 37 0 discriminator 4
 2390 0274 CA01      		movw r24,r20
 2391 0276 0E94 0000 		call del_key_from_report
 2392               	.LVL258:
 2393               	.L204:
 2394               	.LBE73:
 2395               	.LBE72:
 722:quantum/quantum.c ****       return false;
 2396               		.loc 1 722 0
 2397 027a 0E94 0000 		call send_keyboard_report
 2398               	.LVL259:
 723:quantum/quantum.c ****     }
 2399               		.loc 1 723 0
 2400 027e 00C0      		rjmp .L244
 2401               	.L318:
 2402               	.LBE69:
 284:quantum/quantum.c ****     case RESET:
 2403               		.loc 1 284 0
 2404 0280 CF3B      		cpi r28,-65
 2405 0282 DC45      		sbci r29,92
 2406 0284 01F0      		breq .+2
 2407 0286 00C0      		rjmp .L206
 317:quantum/quantum.c ****     #else
 2408               		.loc 1 317 0
 2409 0288 F801      		movw r30,r16
 2410 028a 8281      		ldd r24,Z+2
 2411 028c 8823      		tst r24
 2412 028e 01F4      		brne .+2
 2413 0290 00C0      		rjmp .L244
 321:quantum/quantum.c ****       #ifdef SPLIT_KEYBOARD
 2414               		.loc 1 321 0
 2415 0292 0E94 0000 		call rgblight_toggle
 2416               	.LVL260:
 2417 0296 00C0      		rjmp .L244
 2418               	.L141:
 384:quantum/quantum.c ****     #else
 2419               		.loc 1 384 0
 2420 0298 8823      		tst r24
 2421 029a 01F4      		brne .+2
 2422 029c 00C0      		rjmp .L244
 388:quantum/quantum.c ****       #ifdef SPLIT_KEYBOARD
 2423               		.loc 1 388 0
 2424 029e 0E94 0000 		call rgblight_increase_sat
 2425               	.LVL261:
 2426 02a2 00C0      		rjmp .L244
 2427               	.L139:
 358:quantum/quantum.c ****     #else
 2428               		.loc 1 358 0
 2429 02a4 8823      		tst r24
 2430 02a6 01F4      		brne .+2
 2431 02a8 00C0      		rjmp .L244
 362:quantum/quantum.c ****       #ifdef SPLIT_KEYBOARD
 2432               		.loc 1 362 0
 2433 02aa 0E94 0000 		call rgblight_increase_hue
 2434               	.LVL262:
 2435 02ae 00C0      		rjmp .L244
 2436               	.L316:
 371:quantum/quantum.c ****     #else
 2437               		.loc 1 371 0
 2438 02b0 8823      		tst r24
 2439 02b2 01F4      		brne .+2
 2440 02b4 00C0      		rjmp .L244
 375:quantum/quantum.c ****       #ifdef SPLIT_KEYBOARD
 2441               		.loc 1 375 0
 2442 02b6 0E94 0000 		call rgblight_decrease_hue
 2443               	.LVL263:
 2444 02ba 00C0      		rjmp .L244
 2445               	.L210:
 284:quantum/quantum.c ****     case RESET:
 2446               		.loc 1 284 0
 2447 02bc C63C      		cpi r28,-58
 2448 02be 9CE5      		ldi r25,92
 2449 02c0 D907      		cpc r29,r25
 2450 02c2 01F4      		brne .L319
 410:quantum/quantum.c ****     #else
 2451               		.loc 1 410 0
 2452 02c4 8823      		tst r24
 2453 02c6 01F4      		brne .+2
 2454 02c8 00C0      		rjmp .L244
 414:quantum/quantum.c ****       #ifdef SPLIT_KEYBOARD
 2455               		.loc 1 414 0
 2456 02ca 0E94 0000 		call rgblight_increase_val
 2457               	.LVL264:
 2458 02ce 00C0      		rjmp .L244
 2459               	.L319:
 284:quantum/quantum.c ****     case RESET:
 2460               		.loc 1 284 0
 2461 02d0 C73C      		cpi r28,-57
 2462 02d2 DC45      		sbci r29,92
 2463 02d4 00F4      		brsh .L320
 397:quantum/quantum.c ****     #else
 2464               		.loc 1 397 0
 2465 02d6 8823      		tst r24
 2466 02d8 01F4      		brne .+2
 2467 02da 00C0      		rjmp .L244
 401:quantum/quantum.c ****       #ifdef SPLIT_KEYBOARD
 2468               		.loc 1 401 0
 2469 02dc 0E94 0000 		call rgblight_decrease_sat
 2470               	.LVL265:
 2471 02e0 00C0      		rjmp .L244
 2472               	.L320:
 423:quantum/quantum.c ****     #else
 2473               		.loc 1 423 0
 2474 02e2 8823      		tst r24
 2475 02e4 01F4      		brne .+2
 2476 02e6 00C0      		rjmp .L244
 427:quantum/quantum.c ****       #ifdef SPLIT_KEYBOARD
 2477               		.loc 1 427 0
 2478 02e8 0E94 0000 		call rgblight_decrease_val
 2479               	.LVL266:
 2480 02ec 00C0      		rjmp .L244
 2481               	.L207:
 284:quantum/quantum.c ****     case RESET:
 2482               		.loc 1 284 0
 2483 02ee C03D      		cpi r28,-48
 2484 02f0 FCE5      		ldi r31,92
 2485 02f2 DF07      		cpc r29,r31
 2486 02f4 01F4      		brne .L321
 497:quantum/quantum.c ****       rgblight_mode(24);
 2487               		.loc 1 497 0
 2488 02f6 F801      		movw r30,r16
 2489 02f8 8281      		ldd r24,Z+2
 2490 02fa 8823      		tst r24
 2491 02fc 01F4      		brne .+2
 2492 02fe 00C0      		rjmp .L244
 498:quantum/quantum.c ****     }
 2493               		.loc 1 498 0
 2494 0300 88E1      		ldi r24,lo8(24)
 2495               	.L309:
 456:quantum/quantum.c ****       }
 2496               		.loc 1 456 0
 2497 0302 0E94 0000 		call rgblight_mode
 2498               	.LVL267:
 2499 0306 00C0      		rjmp .L244
 2500               	.L321:
 284:quantum/quantum.c ****     case RESET:
 2501               		.loc 1 284 0
 2502 0308 C13D      		cpi r28,-47
 2503 030a 8CE5      		ldi r24,92
 2504 030c D807      		cpc r29,r24
 2505 030e 00F0      		brlo .+2
 2506 0310 00C0      		rjmp .L211
 2507 0312 F801      		movw r30,r16
 2508 0314 8281      		ldd r24,Z+2
 2509 0316 CC3C      		cpi r28,-52
 2510 0318 FCE5      		ldi r31,92
 2511 031a DF07      		cpc r29,r31
 2512 031c 01F4      		brne .L322
 461:quantum/quantum.c ****       if ((6 <= rgblight_get_mode()) && (rgblight_get_mode() < 8)) {
 2513               		.loc 1 461 0
 2514 031e 8823      		tst r24
 2515 0320 01F4      		brne .+2
 2516 0322 00C0      		rjmp .L244
 462:quantum/quantum.c ****         rgblight_step();
 2517               		.loc 1 462 0
 2518 0324 0E94 0000 		call rgblight_get_mode
 2519               	.LVL268:
 2520 0328 6630      		cpi r22,6
 2521 032a 7105      		cpc r23,__zero_reg__
 2522 032c 8105      		cpc r24,__zero_reg__
 2523 032e 9105      		cpc r25,__zero_reg__
 2524 0330 00F0      		brlo .L151
 462:quantum/quantum.c ****         rgblight_step();
 2525               		.loc 1 462 0 is_stmt 0 discriminator 1
 2526 0332 0E94 0000 		call rgblight_get_mode
 2527               	.LVL269:
 2528 0336 6830      		cpi r22,8
 2529 0338 7105      		cpc r23,__zero_reg__
 2530 033a 8105      		cpc r24,__zero_reg__
 2531 033c 9105      		cpc r25,__zero_reg__
 2532 033e 00F4      		brsh .+2
 2533 0340 00C0      		rjmp .L136
 2534               	.L151:
 465:quantum/quantum.c ****       }
 2535               		.loc 1 465 0 is_stmt 1
 2536 0342 86E0      		ldi r24,lo8(6)
 2537 0344 00C0      		rjmp .L309
 2538               	.L322:
 284:quantum/quantum.c ****     case RESET:
 2539               		.loc 1 284 0
 2540 0346 CD3C      		cpi r28,-51
 2541 0348 9CE5      		ldi r25,92
 2542 034a D907      		cpc r29,r25
 2543 034c 00F4      		brsh .L212
 2544 034e CA3C      		cpi r28,-54
 2545 0350 ECE5      		ldi r30,92
 2546 0352 DE07      		cpc r29,r30
 2547 0354 01F4      		brne .L323
 444:quantum/quantum.c ****       rgblight_mode(1);
 2548               		.loc 1 444 0
 2549 0356 8823      		tst r24
 2550 0358 01F4      		brne .+2
 2551 035a 00C0      		rjmp .L244
 445:quantum/quantum.c ****       #ifdef SPLIT_KEYBOARD
 2552               		.loc 1 445 0
 2553 035c 81E0      		ldi r24,lo8(1)
 2554 035e 00C0      		rjmp .L309
 2555               	.L323:
 284:quantum/quantum.c ****     case RESET:
 2556               		.loc 1 284 0
 2557 0360 CB3C      		cpi r28,-53
 2558 0362 DC45      		sbci r29,92
 2559 0364 00F4      		brsh .L324
 439:quantum/quantum.c ****       rgblight_decrease_speed();
 2560               		.loc 1 439 0
 2561 0366 8823      		tst r24
 2562 0368 01F4      		brne .+2
 2563 036a 00C0      		rjmp .L244
 440:quantum/quantum.c ****     }
 2564               		.loc 1 440 0
 2565 036c 0E94 0000 		call rgblight_decrease_speed
 2566               	.LVL270:
 2567 0370 00C0      		rjmp .L244
 2568               	.L324:
 452:quantum/quantum.c ****       if ((2 <= rgblight_get_mode()) && (rgblight_get_mode() < 5)) {
 2569               		.loc 1 452 0
 2570 0372 8823      		tst r24
 2571 0374 01F4      		brne .+2
 2572 0376 00C0      		rjmp .L244
 453:quantum/quantum.c ****         rgblight_step();
 2573               		.loc 1 453 0
 2574 0378 0E94 0000 		call rgblight_get_mode
 2575               	.LVL271:
 2576 037c 6230      		cpi r22,2
 2577 037e 7105      		cpc r23,__zero_reg__
 2578 0380 8105      		cpc r24,__zero_reg__
 2579 0382 9105      		cpc r25,__zero_reg__
 2580 0384 00F0      		brlo .L149
 453:quantum/quantum.c ****         rgblight_step();
 2581               		.loc 1 453 0 is_stmt 0 discriminator 1
 2582 0386 0E94 0000 		call rgblight_get_mode
 2583               	.LVL272:
 2584 038a 6530      		cpi r22,5
 2585 038c 7105      		cpc r23,__zero_reg__
 2586 038e 8105      		cpc r24,__zero_reg__
 2587 0390 9105      		cpc r25,__zero_reg__
 2588 0392 00F4      		brsh .+2
 2589 0394 00C0      		rjmp .L136
 2590               	.L149:
 456:quantum/quantum.c ****       }
 2591               		.loc 1 456 0 is_stmt 1
 2592 0396 82E0      		ldi r24,lo8(2)
 2593 0398 00C0      		rjmp .L309
 2594               	.L212:
 284:quantum/quantum.c ****     case RESET:
 2595               		.loc 1 284 0
 2596 039a CE3C      		cpi r28,-50
 2597 039c 9CE5      		ldi r25,92
 2598 039e D907      		cpc r29,r25
 2599 03a0 01F4      		brne .L325
 479:quantum/quantum.c ****       if ((15 <= rgblight_get_mode()) && (rgblight_get_mode() < 20)) {
 2600               		.loc 1 479 0
 2601 03a2 8823      		tst r24
 2602 03a4 01F4      		brne .+2
 2603 03a6 00C0      		rjmp .L244
 480:quantum/quantum.c ****         rgblight_step();
 2604               		.loc 1 480 0
 2605 03a8 0E94 0000 		call rgblight_get_mode
 2606               	.LVL273:
 2607 03ac 6F30      		cpi r22,15
 2608 03ae 7105      		cpc r23,__zero_reg__
 2609 03b0 8105      		cpc r24,__zero_reg__
 2610 03b2 9105      		cpc r25,__zero_reg__
 2611 03b4 00F0      		brlo .L155
 480:quantum/quantum.c ****         rgblight_step();
 2612               		.loc 1 480 0 is_stmt 0 discriminator 1
 2613 03b6 0E94 0000 		call rgblight_get_mode
 2614               	.LVL274:
 2615 03ba 6431      		cpi r22,20
 2616 03bc 7105      		cpc r23,__zero_reg__
 2617 03be 8105      		cpc r24,__zero_reg__
 2618 03c0 9105      		cpc r25,__zero_reg__
 2619 03c2 00F4      		brsh .+2
 2620 03c4 00C0      		rjmp .L136
 2621               	.L155:
 483:quantum/quantum.c ****       }
 2622               		.loc 1 483 0 is_stmt 1
 2623 03c6 8FE0      		ldi r24,lo8(15)
 2624 03c8 00C0      		rjmp .L309
 2625               	.L325:
 284:quantum/quantum.c ****     case RESET:
 2626               		.loc 1 284 0
 2627 03ca CF3C      		cpi r28,-49
 2628 03cc DC45      		sbci r29,92
 2629 03ce 00F4      		brsh .L326
 470:quantum/quantum.c ****       if ((9 <= rgblight_get_mode()) && (rgblight_get_mode() < 14)) {
 2630               		.loc 1 470 0
 2631 03d0 8823      		tst r24
 2632 03d2 01F4      		brne .+2
 2633 03d4 00C0      		rjmp .L244
 471:quantum/quantum.c ****         rgblight_step();
 2634               		.loc 1 471 0
 2635 03d6 0E94 0000 		call rgblight_get_mode
 2636               	.LVL275:
 2637 03da 6930      		cpi r22,9
 2638 03dc 7105      		cpc r23,__zero_reg__
 2639 03de 8105      		cpc r24,__zero_reg__
 2640 03e0 9105      		cpc r25,__zero_reg__
 2641 03e2 00F0      		brlo .L153
 471:quantum/quantum.c ****         rgblight_step();
 2642               		.loc 1 471 0 is_stmt 0 discriminator 1
 2643 03e4 0E94 0000 		call rgblight_get_mode
 2644               	.LVL276:
 2645 03e8 6E30      		cpi r22,14
 2646 03ea 7105      		cpc r23,__zero_reg__
 2647 03ec 8105      		cpc r24,__zero_reg__
 2648 03ee 9105      		cpc r25,__zero_reg__
 2649 03f0 00F4      		brsh .+2
 2650 03f2 00C0      		rjmp .L136
 2651               	.L153:
 474:quantum/quantum.c ****       }
 2652               		.loc 1 474 0 is_stmt 1
 2653 03f4 89E0      		ldi r24,lo8(9)
 2654 03f6 00C0      		rjmp .L309
 2655               	.L326:
 488:quantum/quantum.c ****       if ((21 <= rgblight_get_mode()) && (rgblight_get_mode() < 23)) {
 2656               		.loc 1 488 0
 2657 03f8 8823      		tst r24
 2658 03fa 01F4      		brne .+2
 2659 03fc 00C0      		rjmp .L244
 489:quantum/quantum.c ****         rgblight_step();
 2660               		.loc 1 489 0
 2661 03fe 0E94 0000 		call rgblight_get_mode
 2662               	.LVL277:
 2663 0402 6531      		cpi r22,21
 2664 0404 7105      		cpc r23,__zero_reg__
 2665 0406 8105      		cpc r24,__zero_reg__
 2666 0408 9105      		cpc r25,__zero_reg__
 2667 040a 00F0      		brlo .L157
 489:quantum/quantum.c ****         rgblight_step();
 2668               		.loc 1 489 0 is_stmt 0 discriminator 1
 2669 040c 0E94 0000 		call rgblight_get_mode
 2670               	.LVL278:
 2671 0410 6731      		cpi r22,23
 2672 0412 7105      		cpc r23,__zero_reg__
 2673 0414 8105      		cpc r24,__zero_reg__
 2674 0416 9105      		cpc r25,__zero_reg__
 2675 0418 00F4      		brsh .+2
 2676 041a 00C0      		rjmp .L136
 2677               	.L157:
 492:quantum/quantum.c ****       }
 2678               		.loc 1 492 0 is_stmt 1
 2679 041c 85E1      		ldi r24,lo8(21)
 2680 041e 00C0      		rjmp .L309
 2681               	.L211:
 284:quantum/quantum.c ****     case RESET:
 2682               		.loc 1 284 0
 2683 0420 C43D      		cpi r28,-44
 2684 0422 FCE5      		ldi r31,92
 2685 0424 DF07      		cpc r29,r31
 2686 0426 01F4      		brne .L327
 642:quantum/quantum.c ****         shift_interrupted[1] = false;
 2687               		.loc 1 642 0
 2688 0428 F801      		movw r30,r16
 2689 042a 8281      		ldd r24,Z+2
 2690 042c 8823      		tst r24
 2691 042e 01F0      		breq .L194
 2692               	.L199:
 643:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 2693               		.loc 1 643 0
 2694 0430 1092 0000 		sts shift_interrupted+1,__zero_reg__
 644:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 2695               		.loc 1 644 0
 2696 0434 0E94 0000 		call timer_read
 2697               	.LVL279:
 2698 0438 9093 0000 		sts scs_timer+2+1,r25
 2699 043c 8093 0000 		sts scs_timer+2,r24
 645:quantum/quantum.c ****       }
 2700               		.loc 1 645 0
 2701 0440 80E2      		ldi r24,lo8(32)
 2702               	.L311:
 2703 0442 0E94 0000 		call register_mods
 2704               	.LVL280:
 2705 0446 00C0      		rjmp .L244
 2706               	.L194:
 654:quantum/quantum.c ****           register_code(RSPC_KEY);
 2707               		.loc 1 654 0
 2708 0448 8091 0000 		lds r24,shift_interrupted+1
 2709 044c 8111      		cpse r24,__zero_reg__
 2710 044e 00C0      		rjmp .L196
 654:quantum/quantum.c ****           register_code(RSPC_KEY);
 2711               		.loc 1 654 0 is_stmt 0 discriminator 1
 2712 0450 8091 0000 		lds r24,scs_timer+2
 2713 0454 9091 0000 		lds r25,scs_timer+2+1
 2714 0458 0E94 0000 		call timer_elapsed
 2715               	.LVL281:
 2716 045c 883C      		cpi r24,-56
 2717 045e 9105      		cpc r25,__zero_reg__
 2718 0460 00F4      		brsh .L196
 655:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 2719               		.loc 1 655 0 is_stmt 1
 2720 0462 87E2      		ldi r24,lo8(39)
 2721 0464 0E94 0000 		call register_code
 2722               	.LVL282:
 656:quantum/quantum.c ****         }
 2723               		.loc 1 656 0
 2724 0468 87E2      		ldi r24,lo8(39)
 2725 046a 0E94 0000 		call unregister_code
 2726               	.LVL283:
 2727               	.L196:
 658:quantum/quantum.c ****       }
 2728               		.loc 1 658 0
 2729 046e 80E2      		ldi r24,lo8(32)
 2730               	.L310:
 2731 0470 0E94 0000 		call unregister_mods
 2732               	.LVL284:
 2733 0474 00C0      		rjmp .L244
 2734               	.L327:
 284:quantum/quantum.c ****     case RESET:
 2735               		.loc 1 284 0
 2736 0476 C53D      		cpi r28,-43
 2737 0478 8CE5      		ldi r24,92
 2738 047a D807      		cpc r29,r24
 2739 047c 00F0      		brlo .+2
 2740 047e 00C0      		rjmp .L213
 2741 0480 F801      		movw r30,r16
 2742 0482 8281      		ldd r24,Z+2
 2743 0484 C23D      		cpi r28,-46
 2744 0486 FCE5      		ldi r31,92
 2745 0488 DF07      		cpc r29,r31
 2746 048a 01F4      		brne .L328
 511:quantum/quantum.c ****       rgblight_mode(35);
 2747               		.loc 1 511 0
 2748 048c 8823      		tst r24
 2749 048e 01F4      		brne .+2
 2750 0490 00C0      		rjmp .L244
 512:quantum/quantum.c ****     }
 2751               		.loc 1 512 0
 2752 0492 83E2      		ldi r24,lo8(35)
 2753 0494 00C0      		rjmp .L309
 2754               	.L328:
 284:quantum/quantum.c ****     case RESET:
 2755               		.loc 1 284 0
 2756 0496 C33D      		cpi r28,-45
 2757 0498 DC45      		sbci r29,92
 2758 049a 00F4      		brsh .L329
 502:quantum/quantum.c ****       if ((25 <= rgblight_get_mode()) && (rgblight_get_mode() < 34)) {
 2759               		.loc 1 502 0
 2760 049c 8823      		tst r24
 2761 049e 01F4      		brne .+2
 2762 04a0 00C0      		rjmp .L244
 503:quantum/quantum.c ****         rgblight_step();
 2763               		.loc 1 503 0
 2764 04a2 0E94 0000 		call rgblight_get_mode
 2765               	.LVL285:
 2766 04a6 6931      		cpi r22,25
 2767 04a8 7105      		cpc r23,__zero_reg__
 2768 04aa 8105      		cpc r24,__zero_reg__
 2769 04ac 9105      		cpc r25,__zero_reg__
 2770 04ae 00F0      		brlo .L160
 503:quantum/quantum.c ****         rgblight_step();
 2771               		.loc 1 503 0 is_stmt 0 discriminator 1
 2772 04b0 0E94 0000 		call rgblight_get_mode
 2773               	.LVL286:
 2774 04b4 6232      		cpi r22,34
 2775 04b6 7105      		cpc r23,__zero_reg__
 2776 04b8 8105      		cpc r24,__zero_reg__
 2777 04ba 9105      		cpc r25,__zero_reg__
 2778 04bc 00F4      		brsh .+2
 2779 04be 00C0      		rjmp .L136
 2780               	.L160:
 506:quantum/quantum.c ****       }
 2781               		.loc 1 506 0 is_stmt 1
 2782 04c0 89E1      		ldi r24,lo8(25)
 2783 04c2 00C0      		rjmp .L309
 2784               	.L329:
 620:quantum/quantum.c ****         shift_interrupted[0] = false;
 2785               		.loc 1 620 0
 2786 04c4 8823      		tst r24
 2787 04c6 01F0      		breq .L189
 621:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 2788               		.loc 1 621 0
 2789 04c8 1092 0000 		sts shift_interrupted,__zero_reg__
 622:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 2790               		.loc 1 622 0
 2791 04cc 0E94 0000 		call timer_read
 2792               	.LVL287:
 2793 04d0 9093 0000 		sts scs_timer+1,r25
 2794 04d4 8093 0000 		sts scs_timer,r24
 623:quantum/quantum.c ****       }
 2795               		.loc 1 623 0
 2796 04d8 82E0      		ldi r24,lo8(2)
 2797 04da 00C0      		rjmp .L311
 2798               	.L189:
 632:quantum/quantum.c ****           register_code(LSPO_KEY);
 2799               		.loc 1 632 0
 2800 04dc 8091 0000 		lds r24,shift_interrupted
 2801 04e0 8111      		cpse r24,__zero_reg__
 2802 04e2 00C0      		rjmp .L191
 632:quantum/quantum.c ****           register_code(LSPO_KEY);
 2803               		.loc 1 632 0 is_stmt 0 discriminator 1
 2804 04e4 8091 0000 		lds r24,scs_timer
 2805 04e8 9091 0000 		lds r25,scs_timer+1
 2806 04ec 0E94 0000 		call timer_elapsed
 2807               	.LVL288:
 2808 04f0 883C      		cpi r24,-56
 2809 04f2 9105      		cpc r25,__zero_reg__
 2810 04f4 00F4      		brsh .L191
 633:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 2811               		.loc 1 633 0 is_stmt 1
 2812 04f6 86E2      		ldi r24,lo8(38)
 2813 04f8 0E94 0000 		call register_code
 2814               	.LVL289:
 634:quantum/quantum.c ****         }
 2815               		.loc 1 634 0
 2816 04fc 86E2      		ldi r24,lo8(38)
 2817 04fe 0E94 0000 		call unregister_code
 2818               	.LVL290:
 2819               	.L191:
 636:quantum/quantum.c ****       }
 2820               		.loc 1 636 0
 2821 0502 82E0      		ldi r24,lo8(2)
 2822 0504 00C0      		rjmp .L310
 2823               	.L213:
 284:quantum/quantum.c ****     case RESET:
 2824               		.loc 1 284 0
 2825 0506 C83D      		cpi r28,-40
 2826 0508 ECE5      		ldi r30,92
 2827 050a DE07      		cpc r29,r30
 2828 050c 01F4      		brne .L330
 518:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 2829               		.loc 1 518 0
 2830 050e F801      		movw r30,r16
 2831 0510 8281      		ldd r24,Z+2
 2832 0512 8823      		tst r24
 2833 0514 01F0      		breq .L244
 519:quantum/quantum.c ****       }
 2834               		.loc 1 519 0
 2835 0516 80E0      		ldi r24,0
 2836 0518 00C0      		rjmp .L312
 2837               	.L330:
 284:quantum/quantum.c ****     case RESET:
 2838               		.loc 1 284 0
 2839 051a C93D      		cpi r28,-39
 2840 051c FCE5      		ldi r31,92
 2841 051e DF07      		cpc r29,r31
 2842 0520 01F4      		brne .L331
 523:quantum/quantum.c ****         set_output(OUTPUT_USB);
 2843               		.loc 1 523 0
 2844 0522 F801      		movw r30,r16
 2845 0524 8281      		ldd r24,Z+2
 2846 0526 8823      		tst r24
 2847 0528 01F0      		breq .L244
 524:quantum/quantum.c ****       }
 2848               		.loc 1 524 0
 2849 052a 82E0      		ldi r24,lo8(2)
 2850               	.L312:
 2851 052c 0E94 0000 		call set_output
 2852               	.LVL291:
 2853 0530 00C0      		rjmp .L244
 2854               	.L331:
 284:quantum/quantum.c ****     case RESET:
 2855               		.loc 1 284 0
 2856 0532 C53D      		cpi r28,-43
 2857 0534 DC45      		sbci r29,92
 2858 0536 01F0      		breq .+2
 2859 0538 00C0      		rjmp .L206
 664:quantum/quantum.c ****         shift_interrupted[1] = false;
 2860               		.loc 1 664 0
 2861 053a F801      		movw r30,r16
 2862 053c 8281      		ldd r24,Z+2
 2863 053e 8111      		cpse r24,__zero_reg__
 2864 0540 00C0      		rjmp .L199
 669:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 2865               		.loc 1 669 0
 2866 0542 8091 0000 		lds r24,shift_interrupted+1
 2867 0546 8111      		cpse r24,__zero_reg__
 2868 0548 00C0      		rjmp .L196
 669:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 2869               		.loc 1 669 0 is_stmt 0 discriminator 1
 2870 054a 8091 0000 		lds r24,scs_timer+2
 2871 054e 9091 0000 		lds r25,scs_timer+2+1
 2872 0552 0E94 0000 		call timer_elapsed
 2873               	.LVL292:
 2874 0556 883C      		cpi r24,-56
 2875 0558 9105      		cpc r25,__zero_reg__
 2876 055a 00F0      		brlo .+2
 2877 055c 00C0      		rjmp .L196
 670:quantum/quantum.c ****         register_code(SFTENT_KEY);
 2878               		.loc 1 670 0 is_stmt 1
 2879 055e 80E2      		ldi r24,lo8(32)
 2880 0560 0E94 0000 		call unregister_mods
 2881               	.LVL293:
 671:quantum/quantum.c ****         unregister_code(SFTENT_KEY);
 2882               		.loc 1 671 0
 2883 0564 88E2      		ldi r24,lo8(40)
 2884 0566 0E94 0000 		call register_code
 2885               	.LVL294:
 672:quantum/quantum.c ****       }
 2886               		.loc 1 672 0
 2887 056a 88E2      		ldi r24,lo8(40)
 2888 056c 0E94 0000 		call unregister_code
 2889               	.LVL295:
 2890               	.L244:
 742:quantum/quantum.c **** 
 2891               		.loc 1 742 0
 2892 0570 80E0      		ldi r24,0
 2893               	/* epilogue start */
 2894 0572 DF91      		pop r29
 2895 0574 CF91      		pop r28
 2896               	.LVL296:
 2897 0576 1F91      		pop r17
 2898 0578 0F91      		pop r16
 2899               	.LVL297:
 2900 057a FF90      		pop r15
 2901 057c 0895      		ret
 2902               		.cfi_endproc
 2903               	.LFE28:
 2905               		.section	.progmem.data.__c.3520,"a",@progbits
 2908               	__c.3520:
 2909 0000 4445 4255 		.string	"DEBUG: enabled.\n"
 2909      473A 2065 
 2909      6E61 626C 
 2909      6564 2E0A 
 2909      00
 2910               	.global	rgb_matrix_task_counter
 2911               		.section	.bss.rgb_matrix_task_counter,"aw",@nobits
 2914               	rgb_matrix_task_counter:
 2915 0000 00        		.zero	1
 2916               		.weak	ascii_to_keycode_lut
 2917               		.section	.progmem.data.ascii_to_keycode_lut,"a",@progbits
 2920               	ascii_to_keycode_lut:
 2921 0000 00        		.byte	0
 2922 0001 00        		.byte	0
 2923 0002 00        		.byte	0
 2924 0003 00        		.byte	0
 2925 0004 00        		.byte	0
 2926 0005 00        		.byte	0
 2927 0006 00        		.byte	0
 2928 0007 00        		.byte	0
 2929 0008 2A        		.byte	42
 2930 0009 2B        		.byte	43
 2931 000a 28        		.byte	40
 2932 000b 00        		.byte	0
 2933 000c 00        		.byte	0
 2934 000d 00        		.byte	0
 2935 000e 00        		.byte	0
 2936 000f 00        		.byte	0
 2937 0010 00        		.byte	0
 2938 0011 00        		.byte	0
 2939 0012 00        		.byte	0
 2940 0013 00        		.byte	0
 2941 0014 00        		.byte	0
 2942 0015 00        		.byte	0
 2943 0016 00        		.byte	0
 2944 0017 00        		.byte	0
 2945 0018 00        		.byte	0
 2946 0019 00        		.byte	0
 2947 001a 00        		.byte	0
 2948 001b 29        		.byte	41
 2949 001c 00        		.byte	0
 2950 001d 00        		.byte	0
 2951 001e 00        		.byte	0
 2952 001f 00        		.byte	0
 2953 0020 2C        		.byte	44
 2954 0021 1E        		.byte	30
 2955 0022 34        		.byte	52
 2956 0023 20        		.byte	32
 2957 0024 21        		.byte	33
 2958 0025 22        		.byte	34
 2959 0026 24        		.byte	36
 2960 0027 34        		.byte	52
 2961 0028 26        		.byte	38
 2962 0029 27        		.byte	39
 2963 002a 25        		.byte	37
 2964 002b 2E        		.byte	46
 2965 002c 36        		.byte	54
 2966 002d 2D        		.byte	45
 2967 002e 37        		.byte	55
 2968 002f 38        		.byte	56
 2969 0030 27        		.byte	39
 2970 0031 1E        		.byte	30
 2971 0032 1F        		.byte	31
 2972 0033 20        		.byte	32
 2973 0034 21        		.byte	33
 2974 0035 22        		.byte	34
 2975 0036 23        		.byte	35
 2976 0037 24        		.byte	36
 2977 0038 25        		.byte	37
 2978 0039 26        		.byte	38
 2979 003a 33        		.byte	51
 2980 003b 33        		.byte	51
 2981 003c 36        		.byte	54
 2982 003d 2E        		.byte	46
 2983 003e 37        		.byte	55
 2984 003f 38        		.byte	56
 2985 0040 1F        		.byte	31
 2986 0041 04        		.byte	4
 2987 0042 05        		.byte	5
 2988 0043 06        		.byte	6
 2989 0044 07        		.byte	7
 2990 0045 08        		.byte	8
 2991 0046 09        		.byte	9
 2992 0047 0A        		.byte	10
 2993 0048 0B        		.byte	11
 2994 0049 0C        		.byte	12
 2995 004a 0D        		.byte	13
 2996 004b 0E        		.byte	14
 2997 004c 0F        		.byte	15
 2998 004d 10        		.byte	16
 2999 004e 11        		.byte	17
 3000 004f 12        		.byte	18
 3001 0050 13        		.byte	19
 3002 0051 14        		.byte	20
 3003 0052 15        		.byte	21
 3004 0053 16        		.byte	22
 3005 0054 17        		.byte	23
 3006 0055 18        		.byte	24
 3007 0056 19        		.byte	25
 3008 0057 1A        		.byte	26
 3009 0058 1B        		.byte	27
 3010 0059 1C        		.byte	28
 3011 005a 1D        		.byte	29
 3012 005b 2F        		.byte	47
 3013 005c 31        		.byte	49
 3014 005d 30        		.byte	48
 3015 005e 23        		.byte	35
 3016 005f 2D        		.byte	45
 3017 0060 35        		.byte	53
 3018 0061 04        		.byte	4
 3019 0062 05        		.byte	5
 3020 0063 06        		.byte	6
 3021 0064 07        		.byte	7
 3022 0065 08        		.byte	8
 3023 0066 09        		.byte	9
 3024 0067 0A        		.byte	10
 3025 0068 0B        		.byte	11
 3026 0069 0C        		.byte	12
 3027 006a 0D        		.byte	13
 3028 006b 0E        		.byte	14
 3029 006c 0F        		.byte	15
 3030 006d 10        		.byte	16
 3031 006e 11        		.byte	17
 3032 006f 12        		.byte	18
 3033 0070 13        		.byte	19
 3034 0071 14        		.byte	20
 3035 0072 15        		.byte	21
 3036 0073 16        		.byte	22
 3037 0074 17        		.byte	23
 3038 0075 18        		.byte	24
 3039 0076 19        		.byte	25
 3040 0077 1A        		.byte	26
 3041 0078 1B        		.byte	27
 3042 0079 1C        		.byte	28
 3043 007a 1D        		.byte	29
 3044 007b 2F        		.byte	47
 3045 007c 31        		.byte	49
 3046 007d 30        		.byte	48
 3047 007e 35        		.byte	53
 3048 007f 4C        		.byte	76
 3049               		.weak	ascii_to_shift_lut
 3050               		.section	.progmem.data.ascii_to_shift_lut,"a",@progbits
 3053               	ascii_to_shift_lut:
 3054 0000 00        		.byte	0
 3055 0001 00        		.byte	0
 3056 0002 00        		.byte	0
 3057 0003 00        		.byte	0
 3058 0004 00        		.byte	0
 3059 0005 00        		.byte	0
 3060 0006 00        		.byte	0
 3061 0007 00        		.byte	0
 3062 0008 00        		.byte	0
 3063 0009 00        		.byte	0
 3064 000a 00        		.byte	0
 3065 000b 00        		.byte	0
 3066 000c 00        		.byte	0
 3067 000d 00        		.byte	0
 3068 000e 00        		.byte	0
 3069 000f 00        		.byte	0
 3070 0010 00        		.byte	0
 3071 0011 00        		.byte	0
 3072 0012 00        		.byte	0
 3073 0013 00        		.byte	0
 3074 0014 00        		.byte	0
 3075 0015 00        		.byte	0
 3076 0016 00        		.byte	0
 3077 0017 00        		.byte	0
 3078 0018 00        		.byte	0
 3079 0019 00        		.byte	0
 3080 001a 00        		.byte	0
 3081 001b 00        		.byte	0
 3082 001c 00        		.byte	0
 3083 001d 00        		.byte	0
 3084 001e 00        		.byte	0
 3085 001f 00        		.byte	0
 3086 0020 00        		.byte	0
 3087 0021 01        		.byte	1
 3088 0022 01        		.byte	1
 3089 0023 01        		.byte	1
 3090 0024 01        		.byte	1
 3091 0025 01        		.byte	1
 3092 0026 01        		.byte	1
 3093 0027 00        		.byte	0
 3094 0028 01        		.byte	1
 3095 0029 01        		.byte	1
 3096 002a 01        		.byte	1
 3097 002b 01        		.byte	1
 3098 002c 00        		.byte	0
 3099 002d 00        		.byte	0
 3100 002e 00        		.byte	0
 3101 002f 00        		.byte	0
 3102 0030 00        		.byte	0
 3103 0031 00        		.byte	0
 3104 0032 00        		.byte	0
 3105 0033 00        		.byte	0
 3106 0034 00        		.byte	0
 3107 0035 00        		.byte	0
 3108 0036 00        		.byte	0
 3109 0037 00        		.byte	0
 3110 0038 00        		.byte	0
 3111 0039 00        		.byte	0
 3112 003a 01        		.byte	1
 3113 003b 00        		.byte	0
 3114 003c 01        		.byte	1
 3115 003d 00        		.byte	0
 3116 003e 01        		.byte	1
 3117 003f 01        		.byte	1
 3118 0040 01        		.byte	1
 3119 0041 01        		.byte	1
 3120 0042 01        		.byte	1
 3121 0043 01        		.byte	1
 3122 0044 01        		.byte	1
 3123 0045 01        		.byte	1
 3124 0046 01        		.byte	1
 3125 0047 01        		.byte	1
 3126 0048 01        		.byte	1
 3127 0049 01        		.byte	1
 3128 004a 01        		.byte	1
 3129 004b 01        		.byte	1
 3130 004c 01        		.byte	1
 3131 004d 01        		.byte	1
 3132 004e 01        		.byte	1
 3133 004f 01        		.byte	1
 3134 0050 01        		.byte	1
 3135 0051 01        		.byte	1
 3136 0052 01        		.byte	1
 3137 0053 01        		.byte	1
 3138 0054 01        		.byte	1
 3139 0055 01        		.byte	1
 3140 0056 01        		.byte	1
 3141 0057 01        		.byte	1
 3142 0058 01        		.byte	1
 3143 0059 01        		.byte	1
 3144 005a 01        		.byte	1
 3145 005b 00        		.byte	0
 3146 005c 00        		.byte	0
 3147 005d 00        		.byte	0
 3148 005e 01        		.byte	1
 3149 005f 01        		.byte	1
 3150 0060 00        		.byte	0
 3151 0061 00        		.byte	0
 3152 0062 00        		.byte	0
 3153 0063 00        		.byte	0
 3154 0064 00        		.byte	0
 3155 0065 00        		.byte	0
 3156 0066 00        		.byte	0
 3157 0067 00        		.byte	0
 3158 0068 00        		.byte	0
 3159 0069 00        		.byte	0
 3160 006a 00        		.byte	0
 3161 006b 00        		.byte	0
 3162 006c 00        		.byte	0
 3163 006d 00        		.byte	0
 3164 006e 00        		.byte	0
 3165 006f 00        		.byte	0
 3166 0070 00        		.byte	0
 3167 0071 00        		.byte	0
 3168 0072 00        		.byte	0
 3169 0073 00        		.byte	0
 3170 0074 00        		.byte	0
 3171 0075 00        		.byte	0
 3172 0076 00        		.byte	0
 3173 0077 00        		.byte	0
 3174 0078 00        		.byte	0
 3175 0079 00        		.byte	0
 3176 007a 00        		.byte	0
 3177 007b 01        		.byte	1
 3178 007c 01        		.byte	1
 3179 007d 01        		.byte	1
 3180 007e 01        		.byte	1
 3181 007f 00        		.byte	0
 3182               		.section	.bss.grave_esc_was_shifted,"aw",@nobits
 3185               	grave_esc_was_shifted:
 3186 0000 00        		.zero	1
 3187               		.section	.bss.scs_timer,"aw",@nobits
 3190               	scs_timer:
 3191 0000 0000 0000 		.zero	4
 3192               		.section	.bss.shift_interrupted,"aw",@nobits
 3195               	shift_interrupted:
 3196 0000 0000      		.zero	2
 3197               	.global	ag_swap_song
 3198               		.section	.data.ag_swap_song,"aw",@progbits
 3201               	ag_swap_song:
 3202 0000 48        		.byte	72
 3203 0001 F1        		.byte	-15
 3204 0002 76        		.byte	118
 3205 0003 44        		.byte	68
 3206 0004 00        		.byte	0
 3207 0005 00        		.byte	0
 3208 0006 C0        		.byte	-64
 3209 0007 40        		.byte	64
 3210 0008 00        		.byte	0
 3211 0009 00        		.byte	0
 3212 000a 5C        		.byte	92
 3213 000b 44        		.byte	68
 3214 000c 00        		.byte	0
 3215 000d 00        		.byte	0
 3216 000e C0        		.byte	-64
 3217 000f 40        		.byte	64
 3218 0010 48        		.byte	72
 3219 0011 F1        		.byte	-15
 3220 0012 76        		.byte	118
 3221 0013 44        		.byte	68
 3222 0014 00        		.byte	0
 3223 0015 00        		.byte	0
 3224 0016 C0        		.byte	-64
 3225 0017 40        		.byte	64
 3226 0018 00        		.byte	0
 3227 0019 00        		.byte	0
 3228 001a 5C        		.byte	92
 3229 001b 44        		.byte	68
 3230 001c 00        		.byte	0
 3231 001d 00        		.byte	0
 3232 001e C0        		.byte	-64
 3233 001f 40        		.byte	64
 3234               	.global	ag_norm_song
 3235               		.section	.data.ag_norm_song,"aw",@progbits
 3238               	ag_norm_song:
 3239 0000 00        		.byte	0
 3240 0001 00        		.byte	0
 3241 0002 5C        		.byte	92
 3242 0003 44        		.byte	68
 3243 0004 00        		.byte	0
 3244 0005 00        		.byte	0
 3245 0006 00        		.byte	0
 3246 0007 41        		.byte	65
 3247 0008 00        		.byte	0
 3248 0009 00        		.byte	0
 3249 000a 5C        		.byte	92
 3250 000b 44        		.byte	68
 3251 000c 00        		.byte	0
 3252 000d 00        		.byte	0
 3253 000e 00        		.byte	0
 3254 000f 41        		.byte	65
 3255               	.global	goodbye_song
 3256               		.section	.data.goodbye_song,"aw",@progbits
 3259               	goodbye_song:
 3260 0000 52        		.byte	82
 3261 0001 D0        		.byte	-48
 3262 0002 24        		.byte	36
 3263 0003 45        		.byte	69
 3264 0004 00        		.byte	0
 3265 0005 00        		.byte	0
 3266 0006 00        		.byte	0
 3267 0007 41        		.byte	65
 3268 0008 00        		.byte	0
 3269 0009 00        		.byte	0
 3270 000a DC        		.byte	-36
 3271 000b 44        		.byte	68
 3272 000c 00        		.byte	0
 3273 000d 00        		.byte	0
 3274 000e 00        		.byte	0
 3275 000f 41        		.byte	65
 3276 0010 52        		.byte	82
 3277 0011 D0        		.byte	-48
 3278 0012 A4        		.byte	-92
 3279 0013 44        		.byte	68
 3280 0014 00        		.byte	0
 3281 0015 00        		.byte	0
 3282 0016 40        		.byte	64
 3283 0017 41        		.byte	65
 3284               		.text
 3285               	.Letext0:
 3286               		.file 4 "c:\\msys64\\home\\cris almanza\\qmk_utils\\avr8-gnu-toolchain\\avr\\include\\stdint.h"
 3287               		.file 5 "tmk_core/common/keyboard.h"
 3288               		.file 6 "tmk_core/common/action.h"
 3289               		.file 7 "tmk_core/common/report.h"
 3290               		.file 8 "tmk_core/common/debug.h"
 3291               		.file 9 "quantum/keycode_config.h"
 3292               		.file 10 "tmk_core/common/keycode.h"
 3293               		.file 11 "quantum/quantum_keycodes.h"
 3294               		.file 12 "tmk_core/protocol/lufa/outputselect.h"
 3295               		.file 13 "quantum/quantum.h"
 3296               		.file 14 "tmk_core/common/eeconfig.h"
 3297               		.file 15 "tmk_core/common/action_layer.h"
 3298               		.file 16 "quantum/process_keycode/process_music.h"
 3299               		.file 17 "tmk_core/common/backlight.h"
 3300               		.file 18 "quantum/audio/audio.h"
 3301               		.file 19 "tmk_core/common/bootloader.h"
 3302               		.file 20 "tmk_core/common/timer.h"
 3303               		.file 21 "quantum/rgblight.h"
 3304               		.file 22 "quantum/keymap.h"
 3305               		.file 23 "quantum/process_keycode/process_audio.h"
 3306               		.file 24 "tmk_core/common/avr/xprintf.h"
DEFINED SYMBOLS
                            *ABS*:00000000 quantum.c
C:\msys64\tmp\cc1z3P6a.s:2      *ABS*:0000003e __SP_H__
C:\msys64\tmp\cc1z3P6a.s:3      *ABS*:0000003d __SP_L__
C:\msys64\tmp\cc1z3P6a.s:4      *ABS*:0000003f __SREG__
C:\msys64\tmp\cc1z3P6a.s:5      *ABS*:00000000 __tmp_reg__
C:\msys64\tmp\cc1z3P6a.s:6      *ABS*:00000001 __zero_reg__
C:\msys64\tmp\cc1z3P6a.s:12     .text.do_code16:00000000 do_code16
C:\msys64\tmp\cc1z3P6a.s:129    .text.qk_register_weak_mods:00000000 qk_register_weak_mods
C:\msys64\tmp\cc1z3P6a.s:159    .text.qk_register_mods:00000000 qk_register_mods
C:\msys64\tmp\cc1z3P6a.s:189    .text.qk_unregister_weak_mods:00000000 qk_unregister_weak_mods
C:\msys64\tmp\cc1z3P6a.s:219    .text.qk_unregister_mods:00000000 qk_unregister_mods
C:\msys64\tmp\cc1z3P6a.s:250    .text.register_code16:00000000 register_code16
C:\msys64\tmp\cc1z3P6a.s:306    .text.unregister_code16:00000000 unregister_code16
C:\msys64\tmp\cc1z3P6a.s:361    .text.process_action_kb:00000000 process_action_kb
C:\msys64\tmp\cc1z3P6a.s:380    .text.process_record_user:00000000 process_record_user
C:\msys64\tmp\cc1z3P6a.s:399    .text.process_record_kb:00000000 process_record_kb
C:\msys64\tmp\cc1z3P6a.s:417    .text.send_char:00000000 send_char
C:\msys64\tmp\cc1z3P6a.s:2920   .progmem.data.ascii_to_keycode_lut:00000000 ascii_to_keycode_lut
C:\msys64\tmp\cc1z3P6a.s:3053   .progmem.data.ascii_to_shift_lut:00000000 ascii_to_shift_lut
C:\msys64\tmp\cc1z3P6a.s:503    .text.send_string_with_delay:00000000 send_string_with_delay
C:\msys64\tmp\cc1z3P6a.s:648    .text.send_string:00000000 send_string
C:\msys64\tmp\cc1z3P6a.s:667    .text.send_string_with_delay_P:00000000 send_string_with_delay_P
C:\msys64\tmp\cc1z3P6a.s:843    .text.send_string_P:00000000 send_string_P
C:\msys64\tmp\cc1z3P6a.s:862    .text.set_single_persistent_default_layer:00000000 set_single_persistent_default_layer
C:\msys64\tmp\cc1z3P6a.s:911    .text.update_tri_layer_state:00000000 update_tri_layer_state
C:\msys64\tmp\cc1z3P6a.s:1063   .text.update_tri_layer:00000000 update_tri_layer
C:\msys64\tmp\cc1z3P6a.s:1102   .text.tap_random_base64:00000000 tap_random_base64
C:\msys64\tmp\cc1z3P6a.s:1229   .text.matrix_scan_quantum:00000000 matrix_scan_quantum
C:\msys64\tmp\cc1z3P6a.s:1249   .text.backlight_set:00000000 backlight_set
C:\msys64\tmp\cc1z3P6a.s:1401   .text.backlight_task:00000000 backlight_task
C:\msys64\tmp\cc1z3P6a.s:1416   .text.backlight_init_ports:00000000 backlight_init_ports
C:\msys64\tmp\cc1z3P6a.s:1448   .text.matrix_init_quantum:00000000 matrix_init_quantum
C:\msys64\tmp\cc1z3P6a.s:1471   .text.send_nibble:00000000 send_nibble
C:\msys64\tmp\cc1z3P6a.s:1535   .text.send_byte:00000000 send_byte
C:\msys64\tmp\cc1z3P6a.s:1572   .text.send_word:00000000 send_word
C:\msys64\tmp\cc1z3P6a.s:1606   .text.send_dword:00000000 send_dword
C:\msys64\tmp\cc1z3P6a.s:1656   .text.hex_to_keycode:00000000 hex_to_keycode
C:\msys64\tmp\cc1z3P6a.s:1695   .text.api_send_unicode:00000000 api_send_unicode
C:\msys64\tmp\cc1z3P6a.s:1711   .text.led_set_user:00000000 led_set_user
C:\msys64\tmp\cc1z3P6a.s:1727   .text.led_set_kb:00000000 led_set_kb
C:\msys64\tmp\cc1z3P6a.s:1745   .text.led_init_ports:00000000 led_init_ports
C:\msys64\tmp\cc1z3P6a.s:1760   .text.led_set:00000000 led_set
C:\msys64\tmp\cc1z3P6a.s:1778   .text.startup_user:00000000 startup_user
C:\msys64\tmp\cc1z3P6a.s:1793   .text.shutdown_user:00000000 shutdown_user
C:\msys64\tmp\cc1z3P6a.s:1808   .text.reset_keyboard:00000000 reset_keyboard
C:\msys64\tmp\cc1z3P6a.s:3259   .data.goodbye_song:00000000 goodbye_song
C:\msys64\tmp\cc1z3P6a.s:1888   .text.process_record_quantum:00000000 process_record_quantum
C:\msys64\tmp\cc1z3P6a.s:3201   .data.ag_swap_song:00000000 ag_swap_song
C:\msys64\tmp\cc1z3P6a.s:3238   .data.ag_norm_song:00000000 ag_norm_song
C:\msys64\tmp\cc1z3P6a.s:3195   .bss.shift_interrupted:00000000 shift_interrupted
C:\msys64\tmp\cc1z3P6a.s:2908   .progmem.data.__c.3520:00000000 __c.3520
C:\msys64\tmp\cc1z3P6a.s:3185   .bss.grave_esc_was_shifted:00000000 grave_esc_was_shifted
C:\msys64\tmp\cc1z3P6a.s:3190   .bss.scs_timer:00000000 scs_timer
C:\msys64\tmp\cc1z3P6a.s:2914   .bss.rgb_matrix_task_counter:00000000 rgb_matrix_task_counter

UNDEFINED SYMBOLS
add_weak_mods
send_keyboard_report
del_weak_mods
register_code
unregister_code
eeconfig_update_default_layer
default_layer_set
layer_state
layer_state_set
matrix_scan_music
matrix_scan_kb
__umulhisi3
__udivmodhi4
__udivmodsi4
__mulsi3
backlight_init
audio_init
matrix_init_kb
clear_keyboard
music_all_notes_off
timer_read
play_notes
timer_elapsed
stop_all_notes
bootloader_jump
disable_action_cache
layer_switch_get_layer
update_source_layers_cache
read_source_layers_cache
keymap_key_to_keycode
process_audio
process_music
rgblight_increase_speed
get_mods
rgblight_step_reverse
rgblight_step
eeconfig_is_enabled
eeconfig_init
eeconfig_read_keymap
keymap_config
__tablejump2__
eeconfig_update_keymap
debug_config
xputs
keyboard_report
add_key_to_report
del_key_from_report
rgblight_toggle
rgblight_increase_sat
rgblight_increase_hue
rgblight_decrease_hue
rgblight_increase_val
rgblight_decrease_sat
rgblight_decrease_val
rgblight_mode
rgblight_get_mode
rgblight_decrease_speed
register_mods
unregister_mods
set_output
__do_copy_data
__do_clear_bss
